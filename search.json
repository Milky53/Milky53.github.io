[{"title":"article title","url":"/2022/02/26/article-title/","content":"test"},{"title":"test action","url":"/2022/02/26/test-action/","content":"第1题  图像放大缩小一、实验要求设一幅大小为M×N的灰度图像I中，现要变成（放大或缩小）为 P×Q的图像J，请写出J的生成算法。\n【要编写出程序，以及算法描述】【参考函数：imresize() 】 \n二、算法描述（一）最近邻插值法\n根据原始图像大小M×N和变化后的图像大小P×Q，分别计算宽度缩放因子n=N/Q和高度缩放因子m=M/P。\n创建大小为P×Q的目标图像矩阵。\n遍历目标图像中每个像素(i,j)，横纵坐标分别与缩放因子n和m相乘，并四舍五入取整，得到对应原始图像的坐标(x,y)。\n将原始图像(x,y)处的灰度值写入目标图像(i,j)处。\n重复步骤3~4直至目标图像的所有像素写完。\n\n（二）双线性插值法\n根据原始图像大小M×N和变化后的图像大小P×Q，分别计算宽度缩放因子n=N/Q和高度缩放因子m=M/P；\n创建大小为P×Q的目标图像矩阵；\n遍历目标图像中每个像素(i,j)，横纵坐标分别与缩放因子n和m相乘，得到对应原始图像的亚坐标(ii,jj)；\n取亚坐标的整数部分(x,y)和小数部分(u,v);\n根据亚坐标与相邻四个像素点的关系，利用双线性插值公式f(x+u,x+v) = (1-u)(1-v)f(x,y) + (1-u)vf(x,y+1) + u(1-v)f(x+1,y) + uvf(x+1,y+1),计算亚坐标处的灰度值；\n将亚坐标处的灰度值写入目标图像(i,j)处；\n重复步骤3~6直至目标图像的所有像素写完。\n\n三、实验代码图像放大缩小函数：my_resize.m\nfunction newimg = my_imresize(I,new_height,new_width,way)% 利用双线性插值法、最近邻算法将图像放大缩小% I是读入的图像矩阵,dstHeight、dstWidth是放大或缩小后的高和宽% newimg是输出的图像矩阵if new_height &lt;= 0 || new_width &lt;= 0    error(\"放大或缩小后的高和宽应该大于0！\");end[height,width,chanel] = size(I);n = width / new_width;    %宽度缩放因子m = height / new_height;  %高度缩放因子newimg = zeros(new_height,new_width,chanel);%利用双线性插值公式，从新矩阵映射回原图像if way==\"bilinear\"    for i = 1:new_height        for j = 1:new_width            ii = i*m; jj = j*n;            %映射回原图像的亚坐标            x = floor(ii); y = floor(jj);  %亚坐标的整数部分            u = ii-x; v = jj-y;            %亚坐标的小数部分            x = x+1;y = y+1;               %MATLAB中坐标从1开始            %边界处理            if (x&lt;1)                x=1;            end            if (y&lt;1)                y=1;            end            if ((x+1)&gt;width)                   x=width-1;            end            if ((y+1)&gt;height)                y=height-1;            end           newimg(i,j,:)=(1-u)*(1-v)*I(x,y,:)+u*(1-v)*I(x+1,y,:)+(1-u)*v*I(x,y+1,:)+u*v*I(x+1,y+1,:);        end    endend%利用最近邻插值公式，从新矩阵映射回原图像if way==\"nearest\"    for i = 1:new_height        for j = 1:new_width            x = round(i*m); y = round(j*n);            %映射回原图像的亚坐标            x = x+1;y = y+1;               %MATLAB中坐标从1开始            %边界处理            if (x&lt;1)                x=1;            end            if (y&lt;1)                y=1;            end            if ((x+1)&gt;width)                   x=width-1;            end            if ((y+1)&gt;height)                y=height-1;            end           newimg(i,j,:)=I(x,y,:);        end    endend%转化成uint8才能正常显示newimg = uint8(newimg); \n\n调用示例：run.m\nI1 = imread('cameraman.tif');J1 = my_imresize(I1,512,1024,\"bilinear\");J2 = my_imresize(I1,512,1024,\"nearest\");J3 = my_imresize(I1,128,128,\"bilinear\");figure,imshow(I1),title('原图:256*256');figure,imshow(J1),title('放大后的图像:512*1024(双线性插值法）');figure,imshow(J2),title('放大后的图像:512*1024(最近邻插值法）');figure,imshow(J3),title('缩小后的图像:128*128(双线性插值法）');I1 = imread('lena.jpeg');J1 = my_imresize(I1,512,1024,\"bilinear\");J2 = my_imresize(I1,512,1024,\"nearest\");J3 = my_imresize(I1,128,128,\"bilinear\");figure,imshow(I1),title('原图:256*256');figure,imshow(J1),title('放大后的图像:512*1024(双线性插值法）');figure,imshow(J2),title('放大后的图像:512*1024(最近邻插值法）');figure,imshow(J3),title('缩小后的图像:128*128(双线性插值法）');\n\n第2题  图像旋转一、实验要求设一幅大小为M×N的灰度图像I中，现要将其逆时针旋转 a度，得到图像J，请写出J的生成算法。\n【要编写出程序，以及算法描述】【测试时，应含多种角度，锐角、钝角；应有灰度图像及彩色图像的测试】\n【参考函数：imrotate()】\n二、算法描述\n利用原始图像大小M×N、图像旋转角度a和图像旋转的性质，根据如下公式，开辟新矩阵存放旋转后的目标图像H×W（加绝对值是为了避免当a为锐角时对应的三角函数值为负数）。\n\n根据如下公式，定义旋转矩阵R，并求其逆矩阵R’。$$\\left[ \n  \\right]  \\left[   \\right]  \\left[   \\right]$$\n\n遍历目标图像中每个像素(i,j)，通过左乘逆矩阵R’求得当前像素(i,j)对应原始图像的亚坐标(ii,jj)。\n\n若采用最近邻插值法，则将(ii,jj)四舍五入取整，得到对应原始图像的坐标(x,y)，将原始图像(x,y)处的灰度值写入目标图像(i,j)处，并进入步骤6，否则进入步骤5。\n\n若采用双线性插值法，则取亚坐标的整数部分(x,y)和小数部分(u,v)，利用双线性插值公式f(x+u,x+v) = (1-u)(1-v)f(x,y) + (1-u)vf(x,y+1) + u(1-v)f(x+1,y) + uvf(x+1,y+1),计算亚坐标处的灰度值，将亚坐标处的灰度值写入目标图像(i,j)处。\n\n重复步骤3~5直至目标图像的所有像素写完。\n\n\n三、实验代码图像旋转函数：my_imrotate.m\nfunction newimg = my_imrotate(I,angle,way)% 利用最近邻插值法、双线性插值法将图像旋转% I是读入的图像矩阵,angle是旋转角度，way是插值算法% newimg是输出的图像矩阵a = angle / 180 * pi;R = [cos(a), -sin(a); sin(a), cos(a)]; %旋转矩阵R = R'; %求逆矩阵[height,width,chanel] = size(I);new_height = ceil(height * abs(cos(a)) + width * abs(sin(a)));  %顺时针旋转时加上绝对值new_width = ceil(height * abs(sin(a)) + width * abs(cos(a)));newimg = zeros(new_height,new_width,chanel);center1 = [height;width] / 2;center2 = [new_height;new_width] / 2;%利用双线性插值公式，从新矩阵映射回原图像if way==\"bilinear\"    for i = 1:new_height       for j = 1:new_width          dst = [i; j];          %将图像中心先移到原点，与矩阵相乘后，再移回图像中心          src = (R * (dst - center2) + center1);           %双线性插值          a = floor(src); %向下取整          offset = src - a;  %计算的偏移量          u = offset(1);  %x的偏移量          v = offset(2);  %y的偏移量          x = a(1);          y = a(2);          % 逆向进行像素查找          if (src(1) &gt;= 1 &amp;&amp; src(1) &lt;= height - 1 &amp;&amp; src(2) &gt;= 1 &amp;&amp; src(2) &lt;= width - 1)             newimg(i,j,:) = (1-u)*(1-v)*I(x, y, :) + (1 - u) * v * I(x, y + 1, :) + u * (1 - v) * I(x + 1, y, :) + u * v * I(x + 1, y + 1, :);           end       end    endend%利用最近邻插值公式，从新矩阵映射回原图像if way==\"nearest\"    for i = 1:new_height           for j = 1:new_width              dst = [i; j];              %将图像中心先移到原点，与矩阵相乘后，再移回图像中心              src = round(R * (dst - center2) + center1);      %四舍五入近邻插值              % 逆向进行像素查找              if (src(1) &gt;= 1 &amp;&amp; src(1) &lt;= height &amp;&amp; src(2) &gt;= 1 &amp;&amp; src(2) &lt;= width)                 newimg(i,j,:) = I(src(1), src(2),:);               end           end    endendnewimg = uint8(newimg);end\n\n调用示例：run.m\nI1 = imread('cameraman.tif');J1 = my_imrotate(I1,30,\"bilinear\");Q1 = my_imrotate(I1,30,\"nearest\");figure,imshow(I1),title('原图');figure,imshow(J1),title('逆时针旋转30°后的图像(双线性插值法)');figure,imshow(Q1),title('逆时针旋转30°后的图像(最近邻插值法)');I2 = imread('lena.jpeg');J2 = my_imrotate(I2,285,\"bilinear\");Q2 = my_imrotate(I2,285,\"nearest\");figure,imshow(I2),title('原图');figure,imshow(J2),title('逆时针旋转285°后的图像(双线性插值法)');figure,imshow(Q2),title('逆时针旋转285°后的图像(最近邻插值法)');\n\n第3题  直方图均衡化一、实验要求 设一幅大小为M×N的灰度图像I中，灰度为g的像素数为h(g)。 请写出对图像I进行直方图均衡化，得到图像J的计算方法。【参考函数：histeq】【自我练习】\n二、算法描述\n统计各灰度级的像素数。\n计算各个灰度级的概率。\n遍历每个灰度级，将当前灰度级之前的所有灰度级概率累加，得到当前灰度级的累计概率，重复该步骤直至所有灰度级的累计概率计算完毕。\n根据公式，计算每个灰度级对应的新的灰度级（L为灰度级跨度，此处为255）。\n将旧灰度映射得到新的灰度，即更新整张图片的灰度。\n\n第4题  直方图规定化一、实验要求设一幅大小为M×N的灰度图像I中，灰度为g的像素数为h(g)。另给定一个直方图t(g)。 请写出对图像I进行变换的方法，使得变换后的新图像的直方图与t相同（近似相等)。\n【要编写出程序，只测试灰度图像】\n二、算法描述\n利用以下算法，分别计算原图像与规定图像的累计直方图概率分布cum_p1和cum_p2。\n（1）统计各灰度级的像素数；\n（2）计算各个灰度级的概率；\n（3）遍历每个灰度级，将当前灰度级之前的所有灰度级概率累加，得到当前灰度级的累计概率；\n（4）重复步骤（3）直至所有灰度级的累计概率计算完毕。\n\n创建大小为1×256灰度映射表data。\n\n遍历原图累计直方图概率，在规定累计直方图概率中，寻找和当前概率最接近的值，并把它的灰度值变成自己的，记录在data表里。\n\n重复步骤3直至data内所有灰度级都映射完毕。\n\n创建大小为M×N的目标图像。\n\n遍历原图中的每个像素，根据映射表data将当前像素的灰度值映射为新的灰度值，并写入目标图像的对应像素中。\n\n重复步骤6直至目标图像的所有像素写完。\n\n\n三、实验代码求累计直方图概率函数：cum_hist.m\nfunction cum_p = cum_hist(I)% 求累计直方图概率函数% I是读入的图像矩阵% cum_p是输出的累计直方图概率%获取图片的长和宽，用于计算总像素，即M*N[M,N]=size(I);%num 这里是先统计各灰度的像素数，后面会变换为概率num=zeros(1,256);%统计各灰度的像素数for i=1:M    for j=1:N        num(I(i,j)+1)=num(I(i,j)+1)+1;    endend%计算各个灰度级的概率p=num/(M*N); %计算累积直方图概率cum_p=zeros(1,256);for i=1:256    for j=1:i        cum_p(i)=cum_p(i)+p(j);    endend\n\n直方图规定化函数：hist_spe.m\nfunction newimg = hist_spe(A,B)% 利用SML映射算法进行直方图规定化% A是原图矩阵，B是规定图矩阵% newimg是原图经过直方图规定化后的新图cum_p1=cum_hist(A);    %求原图的累计直方图概率cum_p2=cum_hist(B);    %求规定图的累计直方图概率%SML映射表data=zeros(1,256);%SML 从原图累计直方图开始，在规定累加直方图寻找和自己最接近的值，然后把它的灰度值变成自己的。for i=1:256    min=abs(cum_p1(i)-cum_p2(1));    for j=2:256        if  abs(cum_p1(i)-cum_p2(j))&lt;min            min=abs(cum_p1(i)-cum_p2(j));            data(i)=j-1;                 %灰度从0开始        end    endend%利用SML映射表，转换原图像newimg=A;[M,N]=size(A);%转换算法for i=1:M    for j=1:N        newimg(i,j)=data(A(i,j)+1);    endendnewimg = uint8(newimg);end\n\n调用示例：run.m\nI1 = imread('lena.tif');I2 = imread('cameraman.tif');J = hist_spe(I1,I2);subplot(3,2,1),imshow(I1),title('原图')subplot(3,2,2),imhist(I1),title('原图直方图')subplot(3,2,3),imshow(I2),title('规定图')subplot(3,2,4),imhist(I2),title('规定图直方图')subplot(3,2,5),imshow(J),title('直方图规定化后的图像')subplot(3,2,6),imhist(J),title('直方图规定化后的图像直方图')\n\n第5题  图像灰度的对数 / 指数变换一、实验要求 设一幅图像的整体偏暗，在暗区中不同对象较难分辨。为了增强暗区中的对象，应选用灰度的对数变换，还是指数变换？请给出具体的变换方法。【自我练习】\n二、算法描述对数变换：\n\n将图像I的灰度值转化为浮点型L。\n\n根据如下公式，对L进行对数变换。\n\n显示变换后的图像S，此时暗区灰度增强。\n\n\n第6题  图像灰度的分段线性拉伸一、实验要求 对一幅灰度图像，给出灰度分段线性变换方法，使得新图像中 5%的像素的灰度变为0， 5%的像素灰度变为255。【自我练习】\n二、算法描述\n对所有像素的灰度值从小到大进行排序，统计各灰度级的像素数。\n\n计算各个灰度级的概率。\n\n从小到大遍历每个灰度级，将当前灰度级之前的所有灰度级概率累加，得到当前灰度级的前向累计概率，重复该步骤直至所有灰度级的累计概率计算完毕。\n\n从大到小遍历每个灰度级，将当前灰度级之前的所有灰度级概率累加，得到当前灰度级的后向累计概率，重复该步骤直至所有灰度级的累计概率计算完毕。\n\n取与5%最接近的前向累计概率s(g)对应的灰度级g，记为a；取与5%最接近的后向累计概率t(g)对应的灰度级g，记为b。\n\n根据如下公式，对灰度进行变换。\n\n显示变换后的图像。\n\n\n第7题  高斯模板生成一、实验要求 请写出生成 （2N+1）×（2N+1）大小的高斯模板H（方差为sigma）的方法。【自我练习】 \n二、算法描述\n利用meshgrid(-N:N,-N:N)函数，生成以模板中心位置为坐标原点的（2N+1）×（2N+1）大小的采样点矩阵。\n\n根据如下公式，将采样点坐标代入即可形成高斯模板H，其中取1。\n\n\n三、实验代码[x,y]=meshgrid(-4:4,-4:4);h2=exp((-x.*x-y.*y)/2)/(2*pi);\n\n第8题  高斯一阶导模板生成一、实验要求 请写出生成 （2N+1）×（2N+1）大小的高斯一阶导数模板HX(水平方向的梯度)、HY（垂直方向的梯度）（高斯的方差为sigma）的方法。【自我练习】 \n二、算法描述\n利用meshgrid(-N:N,-N:N)函数，生成以模板中心位置为坐标原点的（2N+1）×（2N+1）大小的采样点矩阵。\n\n根据如下公式，将采样点坐标代入，即可形成高斯一阶导数模板HX和HY，其中取1。\n\n\n三、实验代码[x,y]=meshgrid(-4:4,-4:4);h_x=x*exp((-x.*x-y.*y)/2)/(-2*pi);h_y=y*exp((-x.*x-y.*y)/2)/(-2*pi);\n\n第9题  线性滤波一、实验要求请写出使用大小为（2N+1）×（2N+1）模板H对图像I进行滤波，生成图像J的方法。\n  设计一个能够对图像进行平滑的线性滤波器（模板）。\n  设计一个能够对图像进行锐化的线性滤波器（模板）。【自我练习】 \n二、算法描述平滑线性滤波器：\n\n创建 （2N+1）×（2N+1）大小的矩阵H，创建与图像I大小相同的矩阵J，并初始化为0。\n\n将矩阵H内的各个值设为，形成均值滤波器H。\n\n根据如下公式，将均值滤波器模板H中心与图像I中某像素重合，将模板系数与模板下对应像素相乘，并将所有乘积相加后的值赋予矩阵J中与模板中心对应的像素。\n\n重复步骤3，直至图像I中所有像素访问完毕，图像J生成。\n\n\n锐化线性滤波器：\n\n创建 3×3大小的矩阵H，创建与图像I大小相同的矩阵J，并初始化为0。\n\n将矩阵H内的各个值设为如下对应各值，形成拉普拉斯滤波器H。\n\n\n\n0\n1\n0\n\n\n\n1\n-4\n1\n\n\n0\n1\n0\n\n\n\n根据如下公式，将拉普拉斯滤波器模板H中心与图像I中某像素重合，将模板系数与模板下对应像素相乘，并将所有乘积相加后的值赋予矩阵J中与模板中心对应的像素。\n\n重复步骤3，直至图像I中所有像素访问完毕，图像J生成。\n\n\n第10题  中值滤波一、实验要求请写出使用大小为3×3的模板对图像I进行中值滤波，生成图像J的方法。【自我练习】 \n二、算法描述\n设置模中值滤波模板H大小为3×3，创建与图像I大小相同的矩阵J，并初始化为0。\n\n将中值滤波模板H中心与图像I中某像素重合，将模板大小下的对应像素按灰度值从小到大排序，取中间值赋予矩阵J中与模板中心对应的像素，即如下公式所示。\n\n\n重复步骤2，直至图像I中所有像素访问完毕，图像J生成。\n\n\n第11题  中值滤波的特性一、实验要求试简述中值滤波的特性和适用场合。\n设计一个能保持图像中细小尺寸的边缘（如线状目标）的滤波方法。【自我练习】 \n二、算法描述特性：\n\n对某些输入信号中值滤波的不变性：对某些特定的输入信号，如在窗口2n + 1内单调增加或单调减少的序列，中值滤波输出信号仍保持输入信号不变，利用这个特点，可以使中值滤波既能去除图像中的噪声，又能保持图像中一些物体的边缘。\n\n中值滤波去噪声性：对随机噪声的抑制能力，中值滤波性能要比平均值滤波差些。但对于脉冲干扰来讲，特别是脉冲宽度小于m/2，相距较远的窄脉冲，中值滤波是很有效的。\n\n中值滤波的频谱特性：中值滤波频谱特性起伏不大，其均值比较平坦，可以认为信号经中值滤波后，频谱基本不变。\n\n视觉与中值滤波的关系：在图像传输过程中，外部干扰和系统内部干扰会给图像带来很多的随机噪声干扰，利用中值滤波就能很好地消除这些干扰，而中值滤波对图像信号的衰减又不影响人眼对图像的感觉。\n\n\n适用场合：\n​    中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、均值滤波等带来的图像细节模糊，而且在抑制图像随机脉冲噪声方面甚为有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用。\n设计：利用14题的双边滤波\n第12题  统计排序滤波一、实验要求​    最大值滤波的实现方法是什么？使用最大值滤波会产生何种效果？\n​    最小值滤波的实现方法是什么？使用最小值滤波会产生何种效果？【自我练习】 \n二、算法描述最大值滤波：\n\n设置模中值滤波模板H大小为n×n，创建与图像I大小相同的矩阵J，并初始化为0。\n\n将中值滤波模板H中心与图像I中某像素重合，将模板大小下的对应像素按灰度值从小到大排序，取最大值赋予矩阵J中与模板中心对应的像素，即如下公式所示。\n\n\n重复步骤2，直至图像I中所有像素访问完毕，图像J生成。\n相当于实现了膨胀，这种滤波器对于发现图像中的最亮点非常有用。同样，因为胡椒噪声的值非常低，可以用这种滤波器降低它。\n\n\n最小值滤波：\n\n设置模中值滤波模板H大小为n×n，创建与图像I大小相同的矩阵J，并初始化为0。\n\n将中值滤波模板H中心与图像I中某像素重合，将模板大小下的对应像素按灰度值从小到大排序，取最大值赋予矩阵J中与模板中心对应的像素，即如下公式所示。\n\n\n重复步骤2，直至图像I中所有像素访问完毕，图像J生成。\n相当于实现了腐蚀，这种滤波器对于发现图像中的最暗点非常有用。同样,它可以降低盐粒噪声。\n\n\n第13题  各向异性滤波一、实验要求​    编写程序，实现各向异性滤波。\n​    提示：自适应的滤波，一个点P的邻域中的像素点与P的灰度值接近，则权重大，否则权重小。该滤波方法能否保持区域之间的边界不被模糊；而区域内部会变得平坦（斑块化）【自我练习】 \n二、算法描述\n初始化参数迭代次数t、k和的值，创建与原图I大小相同的目标图像矩阵It，并初始化为0。\n遍历各个像素，根据如下公式对当前像素的四个方向分别求偏导，计算当前像素的散度。\n\n\n\n根据如下公式，计算当前像素四个方向上的导热系数。\n\n\n\n根据如下公式，计算当前像素扩散后的新值，并将其赋予矩阵It中对应的像素。\n\n\n\n重复步骤2-4，直至每个像素遍历完毕后，再用已扩散图像的重新进行扩散，直至扩散次数达到迭代次数t。\n\n三、实现代码clear all;close all;clc; k=15;           %控制平滑lambda=0.15;    %控制平滑N=20;           %迭代次数img=double(imread('lena.jpg'));imshow(img,[]);[m n]=size(img); imgn=zeros(m,n);for i=1:N     for p=2:m-1        for q=2:n-1            %当前像素的散度，对四个方向分别求偏导，局部不同方向上的变化量，            %如果变化较多，就证明是边界，想方法保留边界            NI=img(p-1,q)-img(p,q);            SI=img(p+1,q)-img(p,q);            EI=img(p,q-1)-img(p,q);            WI=img(p,q+1)-img(p,q);                        %四个方向上的导热系数，该方向变化越大，求得的值越小，从而达到保留边界的目的            cN=exp(-NI^2/(k*k));            cS=exp(-SI^2/(k*k));            cE=exp(-EI^2/(k*k));            cW=exp(-WI^2/(k*k));                        imgn(p,q)=img(p,q)+lambda*(cN*NI+cS*SI+cE*EI+cW*WI);  %扩散后的新值              end    end        img=imgn;       %整个图像扩散完毕，用已扩散图像的重新扩散。end figure;imshow(imgn,[]);\n\n第14题  双边滤波一、实验要求​    编写程序，实现双边滤波。\n​    根据灰度和空间位置的远近，决定邻域中像素的权重。【自我练习】 \n二、算法描述\n初始化参数w（滤波器边长的1/2）、σd（定义域方差）和σr（值域方差）的值，创建与原图I大小相同的目标图像矩阵J，并初始化为0。\n根据如下公式，利用像素空间距离，计算定义域核G。\n\n\n\n遍历各个像素，根据如下公式，利用像素灰度差值，计算当前核作用区域的值域核H 。\n\n\n\n根据如下公式，将值域核H和定义域核G点乘，得到双边权重函数F。\n\n\n\n根据如下公式，计算当前像素的新值，并将其赋予矩阵J中对应的像素。\n\n\n\n重复步骤3-5,直至图像I中所有像素访问完毕，图像J生成。\n\n第15题  非局部均值滤波一、实验要求​    Non Local Means 的基本思想是什么？【自我练习】 \n二、算法描述基本思想：当前像素的估计值由图像中与它具有相似邻域结构的像素加权平均得到。\n\n其中，d表示以p，q为中心点的邻域块之间的欧式距离，f表示一个单调递减函数，约束距离越近的权重值越大。C(p)为归一化系数。\n\n\n以当前的像素点为中心，设置一个搜索框（搜索框半径为r）。以当前像素点为中心，设置一个当前块（块的半径为f）。以搜索框中某一个像素点位中心，设置一个参考块（块的半径为f）\n\n根据如下公式，求参考块与当前块的距离，将距离代入单调递减函数，求参考块与当前块的权重。权重与参考块的灰度值矩阵相乘，得到一个与参考块同样大小的块（输出块）\n2.1 在搜索框中，滑动参考块，则求得一个输出块；最终对于一个当前块，(2r+1)*(2r+1)个输出块。\n\n\n\n遍历完整个图像后，某一个像素点的滤波值就等于叠加在该点上所有的输出块中对应位置处的值的和，再除以总的叠加次数。\n\n\n第16题  傅里叶变换一、实验要求​    写出二维离散傅立叶变换、反变换的计算公式。【自我练习】 \n二、算法描述二维离散傅立叶变换：\n\n\n二维离散傅立叶反变换：\n\n\n第17题  基于频域滤波的基本步骤一、实验要求写出基于频域的低通滤波的步骤。\n编写程序（可以调用 FFT、 IFFT等函数），实现基于频域的滤波。\n二、算法描述\n读取图像。\n\n利用fft2()函数，将图像进行傅里叶变换，从空间域转换到频率域，得到频谱。\n\n利用fftshift()函数；将频谱进行中心化操作，将低频信号移到中间，高频信号移到四周。\n\n若为低通滤波，则根据如下公式，构造高斯低通滤波器（其中D(u,v)是点(u,v)距频率原点的距离、D0为截止频率），并进入步骤6，否则进入步骤5。\n\n\n若为高通滤波，则根据如下公式，构造高斯高通滤波器（其中D(u,v)是点(u,v)距频率原点的距离、D0为截止频率）。\n\n将低通滤波器和经过傅里叶变换、中心化操作后的频谱点乘（相当于将高频率的傅里叶系数变为0）。\n\n利用ifftshift()函数，将点乘后的结果进行反中心操作，将中心平移回原来位置。\n\n利用fft2()函数，进行反傅里叶变换，从频率域变换到空间域。\n\n取实数部分，并显示图像。\n\n\n三、实验代码低通滤波：low_pass_filtering.m\n%使用高斯低通滤波器实现基于频率的滤波（图像平滑去噪）clear all;d0=40;  %高斯滤波器的阈值image=imread('cameraman_noise.tif');[M ,N]=size(image);img_f = fft2(double(image));    %傅里叶变换得到频谱img_f=fftshift(img_f);          %移到中间m_mid=floor(M/2);%中心点坐标n_mid=floor(N/2);  h = zeros(M,N);%高斯低通滤波器构造for i = 1:M    for j = 1:N        d = ((i-m_mid)^2+(j-n_mid)^2);        h(i,j) = exp(-(d)/(2*(d0^2)));          endendimg_lpf = h.*img_f;                  %高斯滤波器和傅里叶变换后的频谱点乘img_lpf=ifftshift(img_lpf);           %中心平移回原来状态img_lpf=uint8(real(ifft2(img_lpf)));  %反傅里叶变换,取实数部分subplot(1,2,1);imshow(image);title('原图');subplot(1,2,2);imshow(img_lpf);title('高斯低通滤波d=40');\n\n高通滤波：high_pass_filtering.m\n%使用高斯高通滤波器实现基于频率的滤波（提取图像轮廓）clear all;d0=20;  %高斯滤波器的阈值image=imread('moon.tif');[M ,N]=size(image);img_f = fft2(double(image));    %傅里叶变换得到频谱img_f=fftshift(img_f);          %移到中间m_mid=floor(M/2);%中心点坐标n_mid=floor(N/2);  h = zeros(M,N);      %高斯高通滤波器构造for i = 1:M    for j = 1:N        d = ((i-m_mid)^2+(j-n_mid)^2);        h(i,j) = 1-exp(-(d)/(2*(d0^2)));          endendimg_lpf = h.*img_f;                  %高斯滤波器和傅里叶变换后的频谱点乘img_lpf=ifftshift(img_lpf);           %中心平移回原来状态img_lpf=uint8(real(ifft2(img_lpf)));  %反傅里叶变换,取实数部分subplot(1,2,1);imshow(image);title('原图');subplot(1,2,2);imshow(img_lpf);title('高斯高通滤波d=20');\n\n边界平滑：把边缘坐标提取出来，对边缘坐标低通滤波\nclose all;clear;% STEP1:  读入图像，二值化；求区域的边界，并以红色画出边界%              注意，仅画出了第一条边界I=imread('edge_smooth.png');BW = 1-im2bw(I);   [b c]=bwboundaries(BW);    %边界提取，返回一个含有n个单元数组 。B is a P-by-1 cell array, where P is the number of objects  and holes.e=b{1};                    %K表示B单元数组中的第k个元素。即代表第k个边界区域。1即为第一个边界figure,imshow(BW);         hold on; plot(e(:,2),e(:,1),'r');   %设置所有点，颜色，线宽等。e(:,2)表示x，e(:,1)表示y% STEP 2： 由边界点，组成一个 n*2 的矩阵%                n 为边界上点的个数，每行的2个值即为一个点的坐标%  将该矩阵视为一个图像，进行平滑，得到的就是平滑后的坐标值len=floor(size(e,1)/2);   %floor表示向下取整eF=fft2(e);          %对边界点进行傅里叶变换efs=fftshift(eF);    %频率中心化efs(1:len-20,:)=0;efs(end-len+19:end,:)=0;rf=fftshift(efs); Q=real(ifft2(rf));     %取复数的实部数值 figure,plot(e(:,2),-e(:,1)); hold on,plot(Q(:,2),-Q(:,1),'r'); 看成 % 为了更好的比对，显示平滑前、后的图像。 figure,imshow(BW); hold on; plot(e(:,2),e(:,1),'r'); hold on, plot(Q(:,2),Q(:,1),'g');\n\n边界平滑算法：\n\n读入图像，二值化，并用bwboundaries（）函数求区域边界。\n\n将边界点看成一个n*2的矩阵，对该矩阵进行平滑：\n2.1 利用fft2()函数，将矩阵进行傅里叶变换，从空间域转换到频率域，得到频谱。\n2.2 利用fftshift()函数，将频谱进行中心化操作，将低频信号移到中间，高频信号移到四周。\n2.3 对中心化操作后频谱，将其四周某范围内的傅里叶系数置为0，达到抑制高频信号的作用。\n\n利用ifftshift()函数，将抑制后的结果进行反中心操作，将中心平移回原来位置。\n\n利用fft2()函数，进行反傅里叶变换，从频率域变换到空间域。\n\n取实数部分，即可得到平滑后的边界。\n\n\n卷积的性质：公式\n\n\n\n\n\n\n\n\n第18题  Otsu阈值分割一、实验要求请写出求 Otsu阈值（即最大类间距准则）的计算方法。\n试证明采用最大类间距准则计算出的阈值与采用最小类内距准则计算出的阈值相同。【自我练习】\n二、算法描述\n初始化参数总灰度值hui_all、最大方差ICV_t为0。\n\n根据图像大小，计算总像素number_all。\n\n遍历整幅图像，统计图像总灰度值hui_all，并利用总像素number_all计算图像灰度值的总平均值M。\n\n将阈值t设为0~255之间的一个数，把原图像分为A部分（灰度值&gt;=t）与B部分（灰度值&lt;t），并不断遍历试探最优t值。\n4.1 不断重置A、B部分总灰度值hui_A、hui_B，A、B部分总像素number_A、number_B为0；\n4.2 遍历原图像每个像素的灰度值，统计得到hui_A、hui_B、number_A、number_B的值，利用如下公式，得到A、B部分像素分别占图像总像素的比列PA、PB，及A、B部分的平均灰度MA、MB。\n\n\n4.3 根据如下公式，计算类间方差ICV。\n\n\n4.4 判断ICV与当前最大方差ICV_t的大小，若ICV&gt;ICV_t，则将ICV的值赋给ICV_t，并用k记录下此时方差对应的阈值t。\n\n经过步骤4不断的试探，k最终记录的是最大类间方差对应的最优阈值，将其输出。\n\n\n证明：\n\n\n**第19题  **K-means 聚类分割一、实验要求请写出C 均值（K-means）聚类分割的基本步骤。【自我练习】\n二、算法描述\n指定初始化参数聚类数量k（如k=2，即分两类）。\n随机选择k个初始聚类中心点μk的初始值（即k个初始阈值）。\n对于每一个像素，求其灰度值与k个中心的距离，将该像素归到距离最短的中心所在的类。\n对于每一类中的所有像素，计算其灰度值的均值，并将该值作为该类新的聚类中心。\n重复步2~3，直到聚类中心不再变化或达到设定的迭代次数。\n求得的k个聚类中心即为划定好的k个阈值，根据这个k个阈值即可将图像分割为k个不同的部分。\n\n第20题  Canny算子检测边缘一、实验要求请写出Canny算子检测边缘的详细步骤。\n二、算法描述\n高斯平滑\n根据以下公式，生成高斯模板，利用它对图像进行平滑，消除图像中的噪声，降低伪边缘的识别。\n\n计算梯度的幅值和方向\n（1）构造边缘差分算子（Sobel算子），如下所示：（2）利用Sobel算子计算图像水平和垂直方向的差分Gx和Gy，并根据如下公式计算梯度幅值和梯度角度。（3）根据梯度角度θ，将某点的梯度方向近似到水平、垂直或两个对角线四个方向之一，从而确定梯度方向。\n（4）根据梯度幅值G，可以选定合适的高阈值maxVal和低阈值minVal，用于之后的双阈值策略区分边缘像素。\n\n非极大值抑制\n保留局部最大梯度而抑制所有其它梯度值：\n将当前点与同梯度方向上其它点进行梯度幅值的比较，如果当前点的梯度幅值是最大的，则保留其值，否则抑制，即设为0（在此步骤，非极大值抑制达到了边缘细化的效果）。\n\n双阈值策略\n利用步骤2中设置的高阈值maxVal和低阈值minVal，划分强弱边缘：\n\n大于maxVal的点都被检测为强边缘，设为1；\n\n小于minVal的点都被检测为非边缘，设为0；\n\n对于中间的点（弱边缘点），如果与确定为边缘的像素点邻接，则判定为强边缘，设为1，否则为非边缘，设为0 (即判断领域8个像素点中有无强边缘点)。\n\n\n\n\n三、实验代码生成高斯模板函数：gaussian_filter.m\nfunction gaussian_matrix = gaussian_filter(size, sigma)    gaussian_matrix = zeros(size, size);    coef = 1 / (2 * 3.14159265 * sigma * sigma);    total_sum = 0;    for i = 1:size        for j = 1:size            x2 = (j - (size + 1)  / 2)^2;            y2 = (i - (size + 1)  / 2)^2;            gaussian_matrix(i, j) = coef * exp(-(x2 + y2) / (2 * sigma * sigma));            total_sum = total_sum + gaussian_matrix(i, j);        end    end    % 使得矩阵中所有元素和为1    gaussian_matrix = gaussian_matrix / total_sum;end\n\n计算梯度幅值及方向函数：compute_grad.m\nfunction [grad, grad_direction] = compute_grad(img_filter)    % 索贝尔算子    sobel = [-1.0 0.0 1.0;-2.0 0.0 2.0;-1.0 0.0 1.0];    % 计算图像的sobel水平梯度     gradx=conv2(img_filter, sobel, 'same');    % gradx = imfilter(apple_filter, sobel, 'replicate');    % 计算图像的sobel垂直梯度     grady=conv2(img_filter, sobel', 'same');    % grady = imfilter(apple_filter, sobel', 'replicate');    % 得到图像的sobel梯度以及方向, 使用绝对值代替平方开方    grad=sqrt(gradx.^2+grady.^2);    grad_direction = atan(grady./gradx);end\n\n非极大值抑制函数：non_maximum_restrain.m\nfunction canny = non_maximum_restrain(grad, grad_direction)    [m, n] = size(grad_direction);    sector = zeros(m, n);    canny = zeros(m, n);    % 构造    % 2 1 0    % 3 x 3    % 0 1 2    for i=1:m        for j=1:n            angle = grad_direction(i, j);            if (angle &lt; 3*pi/4) &amp;&amp; (angle &gt;= pi/4)                sector(i, j) = 0;                elseif (angle &lt; pi/4) &amp;&amp; (angle &gt;= -pi/4)                sector(i, j) = 3;                elseif (angle &lt; -pi/4) &amp;&amp; (angle &gt;= -3*pi/4)                sector(i, j) = 2;                else                sector(i, j) = 1;                end            end    end    % 判断每一点像素的梯度方向，并和该方向上的数值进行比较    for i=2:m-1        for j=2:n-1            if (sector(i, j) == 0) % 45度                if ((grad(i, j) &gt; grad(i - 1, j + 1) &amp;&amp; grad(i, j) &gt; grad(i + 1, j - 1)) || (grad(i, j) &gt; grad(i, j + 1) &amp;&amp; grad(i, j) &gt; grad(i, j - 1)) || (grad(i, j) &gt; grad(i - 1, j) &amp;&amp; grad(i, j) &gt; grad(i + 1, j)))                    canny(i,j) = grad(i, j);                else                    canny(i, j) = 0;                end            end            if (sector(i, j) == 1) % 90度                if (grad(i, j) &gt; grad(i - 1, j) &amp;&amp; grad(i, j) &gt; grad(i + 1, j))                    canny(i,j) = grad(i, j);                else                    canny(i, j) = 0;                end            end            if (sector(i, j) == 2) % 135度                if ((grad(i, j) &gt; grad(i - 1, j - 1) &amp;&amp; grad(i, j) &gt; grad(i + 1, j + 1))|| (grad(i, j) &gt; grad(i, j + 1) &amp;&amp; grad(i, j) &gt; grad(i, j - 1)) || (grad(i, j) &gt; grad(i - 1, j) &amp;&amp; grad(i, j) &gt; grad(i + 1, j)))                    canny(i,j) = grad(i, j);                else                    canny(i, j) = 0;                end            end            if (sector(i, j) == 3) % 180度                if (grad(i, j) &gt; grad(i, j + 1) &amp;&amp; grad(i, j) &gt; grad(i, j - 1))                    canny(i,j) = grad(i, j);                else                    canny(i, j) = 0;                end            end        end    endend\n\n双阈值策略函数：dual_threshold_detection.m\nfunction canny2 = dual_threshold_detection(canny, low_th, high_th)    [m, n] = size(canny);    canny2 = zeros(m, n);    for i=2:m-1        for j=2:n-1            if (canny(i, j) &lt; low_th)                canny2(i,j) = 0;            elseif (canny(i, j) &gt; high_th)                canny2(i, j) = canny(i, j);            else                neighbor_matrix = [canny(i-1, j-1), canny(i, j-1), canny(i+1, j-1);...                                   canny(i-1, j), canny(i, j), canny(i+1, j);...                                   canny(i-1, j+1), canny(i, j+1), canny(i+1, j+1);];                max_neighbour = max(neighbor_matrix);                if (max_neighbour &gt; high_th)                    canny2(i, j) = canny(i, j);                else                    canny2(i,j) = 0;                end            end        end    endend\n\n调用示例：run.m\n%% =============== Part 0: 读取图像 ================apple = imread('lena.jpeg');apple_gray = double(rgb2gray(apple));figure(1);subplot(1,2,1);imshow(uint8(apple_gray));title('原图')%% =============== Part 1: 高斯平滑处理 ================% 生成高斯模版H = gaussian_filter(5, 0.8);apple_filter = imfilter(apple_gray, H, 'replicate');%% =============== Part 2: 索贝尔算子计算梯度值及方向 ================[grad, grad_direction] = compute_grad(apple_filter);%% =============== Part 3: 非极大值抑制 ================canny1 = non_maximum_restrain(grad, grad_direction);%% =============== Part 4: 双阈值检测 ================canny11 = dual_threshold_detection(canny1, 50, 100);subplot(1,2,2);imshow(uint8(canny11));title('canny边缘检测结果')\n\n第21题  区域标记一、实验要求设有一幅二值图像（元素取值为0或1），请生成该图像的标记图像。（即第一个连通区域中的每一个白色像素的值都置为1，第二个连通区域中的每一个白色像素的值都置为2，依此类推。区域编号可不考虑顺序）\n二、算法描述（一）队列法        (变式若为灰度图，给定阈值范围[T1,T2]内的像素为一个区域)\n创建和二值图像大小相同的标记矩阵，元素置为0（0表示未标记，1表示已标记），初始化label=1，\n遍历二值图像矩阵，若当前像素值为1，且对应标记矩阵元素未标记（即为0），将该点入队，并标上区域编号label，\n若队列不空，对于队首像素的8邻域像素点进行考察，如果该点未越界、灰度值为1、且未被标记过，则入队，并且标上当前编号label，8领域像素点判断完毕则将该队首元素出队；当队列为空时，一个连通区域标记完成，label+1，\n重复步骤2~3，直到二值图像遍历完成，\n将标记矩阵以彩色标记的形式输出，并输出连通区域的个数。\n\n（二）”画卷”法\n创建和二值图像大小相同的标记矩阵，元素置为0（0表示未标记，1表示已标记）。\n\n逐行扫描图像，把每一行中连续的白色像素组成一个序列称为一个团，并记下它的起点start、它的终点end以及它所在的行号。\n\n对于所有行里的团（除第一行外），若它与前一行中的所有团都不相邻，则给它一个新的标号；如果它仅与上一行中1个团相邻，则将相邻团的标号赋给它；如果它与上一行的2个及以上的团相邻，则相邻团中的最小标号幅给它，并将上一行的这几个团的标号写入等价对，说明它们属于一类。\n\n重复步骤2~3，直到二值图像遍历完成。\n\n将等价对转换为等价序列，从1开始，给每个等价序列赋一个标号。\n\n遍历开始团的标号，查找等价序列，给予它们新的标号。\n\n将每个团的标号填入标记矩阵中。\n\n将标记矩阵以彩色标记的形式输出，并输出连通区域的个数。\n\n\n三、实验代码区域标记函数（队列法）：mybwlabel.m\nfunction [conn,num] = mybwlabel( I )% 对二值图区域标记% 输入：I是二值图矩阵% 输出：tmp是标记矩阵，num是连通区域个数[m n] = size(I);conn = zeros(m,n);     %标记矩阵label = 1;queue = [];  %用二维数组模拟队列，一列是一个点的坐标，第一行代表x，第二行代表y%和当前像素坐标相加得到八个邻域坐标(左上、左、左下、上、下、右上、右、右下)neighbour = [-1 -1;-1 0;-1 1;0 -1;0 1;1 -1;1 0;1 1]; %图像周围一圈不遍历，防止越界for i = 2 : m-1     for j = 2 : n-1        if I(i,j) == 1 &amp;&amp; conn(i,j) == 0 %属于目标区域且未标记才处理                      conn(i,j) = label;            queue = [i;j];  %记录当前点坐标            while ~isempty(queue) %队列不空，这里没有出队操作，队列中的每一个元素的8领域都判断一遍                index = [queue(1,1),queue(2,1)];      %队列第一个元素的x,y坐标                         for k = 1 : 8               %8邻域搜索                    cur_index = index + neighbour(k,:);  %得到周围8邻域的坐标点                    if cur_index(1) &gt;= 2 &amp;&amp; cur_index(1) &lt;= m - 1 &amp;&amp; cur_index(2) &gt;= 2 &amp;&amp; cur_index(2) &lt;= n - 1 %防止坐标越界                        if I(cur_index(1),cur_index(2)) == 1 &amp;&amp; conn(cur_index(1),cur_index(2)) ==0  %如果当前像素邻域像素为1并且标记图像的这个邻域像素没有被标记，那么标记                            conn(cur_index(1),cur_index(2)) = label;                            queue = [queue [cur_index(1);cur_index(2)]];                        end                      end                              end               queue(:,1) = []; %队列中第一列的坐标出队            end                label = label+1;                    end    endendnum = label - 1; %连通区域的个数end\n\n调用示例：run.m\nI = imread('bwimg.tif');[B,num1] = mybwlabel(I);subplot(1,2,1),imshow(I),title('原图');subplot(1,2,2),imshow(label2rgb(B)),title({'区域标记',['区域个数=',num2str(num1)]});\n\n第22题  边界跟踪一、实验要求设一幅二值图像中，只有一个白色区域，试给出求该区域外围轮廓线的方法（要求按顺时针的顺序给出各点的坐标，即行/列号）。\n二、算法描述\n对图像进行逐行查找（从上到下，从左到右），找到第一个值为1的点，用P0表示。\n\n定义变量dir=7，用于记录搜索方向，如下所示，dir取不同的值代表不同的方向。\n\n\n\n5\n6\n7\n\n\n\n4\nx\n0\n\n\n3\n2\n1\n\n\n\n按顺时针方向顺序依次判断当前点的8个3×3邻居是否为1，从以下的方向开始搜索领域：\n（1）(dir+7)mod8，当dir为偶数时；\n（2）(dir+6)mod8，当dir为奇数时。\n找到的第一个不为0的点为新的边界元素，记为Pn，并更新dir的值。\n\n如果当前的边界点Pn的坐标等于找到的第2个边界点P1的坐标，而且它前一个边界点Pn-1的坐标又与起始点P0的坐标相同，则算法停止；否则，重复步骤3。\n\n输出边界坐标。\n\n\n三、实验代码边界跟踪函数：my_bwboundary.m\nfunction C = my_bwboundary(BW)[m,n]=size(BW);Itemp=zeros(m+2,n+2);                     % we create a '0' frame around the image to avoid border problemsItemp(2:(m+1),2:(n+1))=BW;BW=Itemp;BW = BW - imerode(BW,[0 1 0 ; 1 1 1 ; 0 1 0]);  BW = bwmorph(BW,'thin',Inf);                    % to be sure to have strictly 8-connected contourif (sum(sum(BW))&lt;3),                            % we consider that less than 3 pixels cannot make a contour    C=[0 0];     return; end;[row,col]=find(BW,1);  C=[0 0 ; 0 0];k=0;ended=0;direction=7;while(ended==0),    k=k+1;    found_next=0;          while(found_next==0),        switch mod(direction,8),            case 0,                if (BW(row, col+1)==1),                    row=row;                    col=col+1;                    C(k,:)=[row col];                    found_next=1;                end;            case 1;                if (BW(row+1, col+1)==1),                    row=row+1;                    col=col+1;                    C(k,:)=[row col];                    found_next=1;                end;            case 2;                if (BW(row+1, col)==1),                    row=row+1;                    col=col;                    C(k,:)=[row col];                    found_next=1;                end;            case 3;                if (BW(row+1, col-1)==1),                    row=row+1;                    col=col-1;                    C(k,:)=[row col];                    found_next=1;                end;            case 4;                if (BW(row, col-1)==1),                    row=row;                    col=col-1;                    C(k,:)=[row col];                    found_next=1;                end;            case 5;                if (BW(row-1, col-1)==1),                    row=row-1;                    col=col-1;                    C(k,:)=[row col];                    found_next=1;                end;            case 6;                if (BW(row-1, col)==1),                    row=row-1;                    col=col;                    C(k,:)=[row col];                    found_next=1;                end;            case 7;                if (BW(row-1, col+1)==1),                    row=row-1;                    col=col+1;                    C(k,:)=[row col];                    found_next=1;                end;                        end        if (found_next==0), direction=direction+1; end;            end        if(and((length(C)&gt;3),(([C(1,:) C(2,:)]==[C((end-1),:) C(end,:)])))),        ended=1;     end;        if mod(direction,2)              %direction为奇数时        direction=mod(direction+6,8);    else                             %direction为偶数时        direction=mod(direction+7,8);    endendC=C(1:(end-1),:);               % the first and last points in the list are the same (circular list)C=C-1;                          % to go back to the original coordinates (without the '0' frame)\n\n调用示例：run.m\nI1=rgb2gray(imread('test1.bmp'));I2=rgb2gray(imread('test2.bmp'));C1 = my_bwboundary(I1);C2 = my_bwboundary(I2);figure, imshow(I1);figure, plot(C1(:,2),C1(:,1),'*');set(gca,'XAxisLocation','top'); set(gca,'YDir','reverse');for j=1:size(C1,1),    text(C1(j,2),C1(j,1),['  ' num2str(j)]);    fprintf('%d:(%d,%d)\\n',j,C1(j,2),C1(j,1));endfigure, imshow(I2);figure, plot(C2(:,2),C2(:,1),'*');set(gca,'XAxisLocation','top'); set(gca,'YDir','reverse');for j=1:size(C2,1),    text(C2(j,2),C2(j,1),['  ' num2str(j)]);    fprintf('%d:(%d,%d)\\n',j,C2(j,2),C2(j,1));end\n\n第23题  图像腐蚀一、实验要求设有一幅二值图像，采用 3×3的结构元（每个元素均为1）对其进行腐蚀操作，试写出得到结果图像的方法。【自我练习】\n二、算法描述\n创建和二值图像I大小相同目标矩阵J，并将其元素初始化为0，用于存放腐蚀后的图像。\n创建3×3的结构元矩阵B，并将其元素均设为1。\n遍历原图I中每个像素，将其 3×3领域内的元素组成的块与结构元B进行点乘，得到C，若C中1的数量和结构元B中1的数量一样多，则将该像素保留，对应目标矩阵J中该像素的值设为1。\n重复步骤3，直至原图I中所有元素访问完毕，得到的J即为腐蚀后的图像。\n\n第24题  孔洞填充一、实验要求试写出孔洞填充的算法。对二值图像中所有被白色区域包围（封闭）的黑色像素即为孔洞。【自我练习】\n二、算法描述\n利用区域生长找出二值图像中的背景区域。\n1.1 创建和二值图像大小相同的标记矩阵Q，元素置为0（0表示未标记，1表示已标记），初始化label=1。\n1.2 遍历二值图像矩阵，若当前像素值为0，且对应标记矩阵元素未标记（即为0），将该点入队，并标上区域编号label。\n1.3 若队列不空，对于队首像素的8邻域像素点进行考察，如果该点未越界、灰度值为0、且未被标记过，则入队，并且标上当前编号label，8领域像素点判断完毕则将该队首元素出队；当队列为空时，一个连通区域标记完成，label+1\n1.4 重复步骤1.2~1.3，直到二值图像遍历完成。\n1.5 通常情况下，只会找到一个连通区域，即标记矩阵中为1的区域是背景区域。\n\n创建和二值图像I大小相同目标矩阵J，并初始化元素为0。\n\n遍历标记矩阵Q，若当前元素值为0（即未被标记），则将目标矩阵J中对应元素置为1，否则跳过。\n\n重复步骤3，直至标记矩阵遍历完成，此时目标矩阵J中的结果即为孔洞填充后的图像。\n\n\n第25题  粘连区域断开一、实验要求设有两个白色区域，被一条细小的白线所连接，试设计一种算法，消除两个区域之间的细线，使两个区域分开。【自我练习】\n（形态学开运算：先腐蚀、再膨胀）\n二、算法描述\n利用图像腐蚀消除白色区域之间的细线。\n1.1 创建和二值图像I大小相同的矩阵J，并将其元素初始化为0。\n1.2 创建3×3的结构元矩阵B，并将其元素均设为1。\n1.3 遍历原图I中每个像素，将其 3×3领域内的元素组成的块与结构元B进行点乘，得到C，若C中1的数量和结构元B中1的数量一样多，则将该像素保留，对应矩阵J中该像素的值设为1。\n1.4 重复步骤1.3，直至原图I中所有元素访问完毕，得到的J即为腐蚀后的图像。\n\n利用图像膨胀还原白色区域。\n2.1 创建和二值图像I大小相同的矩阵Q，并将其元素初始化为0。\n2.3 遍历腐蚀后的图像J中每个像素，将其 3×3领域内的元素组成的块与结构元B进行点乘，得到C，若C中存在一个1，则将该像素保留，对应矩阵Q中该像素的值设为1。\n2.4 重复步骤2.3，直至矩阵J中所有元素访问完毕，得到的Q即为膨胀后的图像。\n\n先腐蚀、再膨胀后的结果Q，即为粘连区域断开的效果。\n\n\n形态学开运算：先腐蚀、后膨胀，能够除去孤立的小点，毛刺和小桥\n形态学闭运算：先膨胀、后腐蚀，能够填平小湖（即小孔），弥合小裂缝\n第26题  计算凸壳一、实验要求计算包围给定点集的最小凸多变形。【自我练习】\n二、算法描述\n找出点集中纵坐标最小的点P1。\n将P1和点集中其他各点用线段连接,并根据如下公式，计算这些线段与水平线的夹角。\n\n​                                                         cosθ=a×b/(|a|*|b|)，角θ=arccosθ\n\n按夹角大小对数据点进行排序，如果夹角相同，则按距离排序，得到的序列为P1，P2…Pn。\n\n将排序后的顶点顺次连接成一个多边形，其中P1、P2和Pn-1一定为最小凸多边形的顶点。\n\n删去p3,p4,…,pn-1中不是凸壳上的点，方法如下：\nbegin\n5.1  k = 4\n5.2  j = 2\n5.3 if  P1和 Pk 分别在线段Pk-j+1 Pk-j两侧    （即P1Pk-j+1×P1Pk-j和PkPk-j+1×PkPk-j 异号 ）\n​               then 删去 Pk-1,后继顶点编号减1，k = k-1,j = j-1\n​       else \n​               Pk-1暂为凸壳顶点，并记录\n5.4 j = j+1 ,go to 5.3,直到 j = k-1\n5.5 k = k+1,go to 5.2,直到 k = n+1\nend\n\n顺序输出凸壳顶点。\n\n\n第27题  判断一个点是否在一个区域内部一、算法描述假设给定区域为边界点矩阵areaPoints[]，需判断的点为p。\n\n定义交点个数nCross，并初始化为0。\n\n过点p作一条水平向右的射线，即y=点p的纵坐标。\n\n遍历区域边界点矩阵，设当前节点areaPointsp[i]为p1,下一节点areaPoints[i+1]为p2。\n3.1 若p1和p2处于同一水平面，或射线y不穿过线段p1p2(即p.y &lt; min(p1.y, p2.y) 或   p.y &gt;=max(p1.y, p2.y))，则i=i+1,跳过当前节点，重复步骤3。\n3.2 过点p1和p2作直线，求其与射线y的交点，记为x。\n3.3 若x大于点p的横坐标，nCross=nCross+1（即只统计p1p2与p向右射线的交点）。\n\n重复步骤3，直至所有边界点都遍历完成。\n\n判断nCross的奇偶性：若nCross为奇数，则点在区域内部；若nCross为偶数，则点在区域外部。\n\n\n第28题  给定一个区域的边界点序列，生成该边界包围的区域（或称区域填充）一、算法描述假设在多边形区域内部有一像素已知，由此出发找到区域内的所有像素，用一定的颜色或灰度来填充。\n\n定义堆栈s，并置为空，创建和原图同样大小的目标矩阵J。\n\n将给定的种子点（x, y）压入堆栈，当栈非空时重复执行如下三步操作：\n（1）栈顶像素出栈。\n（2）将矩阵J中对应出栈像素坐标的像素置成要填充色。\n（3）按左、上、右、下顺序检查与栈像素相邻的四个像素，若其中某个像素不在边界上且未置成填充色，则把该像素入栈。\n\n当栈为空时，算法结束，矩阵J即为区域填充后的结果。\n\n\n","tags":["test"]},{"title":"Hello World","url":"/2022/02/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]