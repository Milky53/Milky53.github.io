[{"title":"Ajax（一）：概述","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/","content":"Ajax概述AJAX 简介AJAX 全称为Asynchronous JavaScript And XML，就是异步的JS 和XML\n通过AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据\nAJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式\nXML 简介\nXML 可扩展标记语言。\nXML 被设计用来传输和存储数据。\nXML 和HTML 类似，不同的是HTML 中都是预定义标签，而XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。\n\n比如说我有一个学生数据：name &#x3D; “孙悟空” ; age &#x3D; 18 ; gender &#x3D; “男” ;用XML 表示：\n&lt;student&gt;\t&lt;name&gt;孙悟空&lt;/name&gt;\t&lt;age&gt;18&lt;/age&gt;\t&lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;\n\n现在已经被JSON 取代了。\n&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;\n\nAJAX 的特点1.3.1 AJAX 的优点\n可以无需刷新页面而与服务器端进行通信\n允许你根据用户事件来更新部分页面内容\n\n1.3.2 AJAX 的缺点\n没有浏览历史，不能回退\n存在跨域问题(同源)\nSEO （Search Engine Optimization，搜索引擎优化）不友好（爬虫看不到）\n\n","categories":["Ajax"],"tags":["Ajax"]},{"title":"Ajax（三）：原生Ajax","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8E%9F%E7%94%9FAjax/","content":"理解\n使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送ajax 请求\n\n前端可以获取到数据，而无需让整个的页面刷新。\n\n这使得Web 页面可以只更新页面的局部，而不影响用户的操作。\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestXMLHttpRequest，AJAX 的所有操作都是通过该对象进行的\n核心对象使用步骤创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();var xhr = new XMLHttpRequest();\n\n\n\n设置请求信息（请求方法和url）// 请求方式xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);\n\n\n\n发送请求xhr.send(body) //get请求不传 body 参数，只有post请求使用\n\n\n\n接收响应（事件绑定，处理服务端返回的结果）//xhr.responseXML 接收 xml格式 的响应数据//xhr.responseText 接收 文本格式 的响应数据xhr.onreadystatechange = function ()&#123;\t// readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4\tif(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;\t\tvar text = xhr.responseText;\t\tconsole.log(text);\t&#125;&#125;\n\n案例GET请求服务器端 server.js\n// 1. 引入expressconst express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax&quot;);&#125;);// 4. 监听服务app.listen(8000, () =&gt; &#123;  console.log(&quot;服务已经启动, 8000 端口监听中...&quot;); &#125;)\n\n浏览器端页面 get.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Ajax GET 请求&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #90b;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;button&gt;点击发送请求&lt;/button&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    //获取button元素    const btn = document.getElementsByTagName(&#x27;button&#x27;)[0];    const result = document.getElementById(&#x27;result&#x27;);    //绑定事件    btn.onclick = function()&#123;      // 1. 创建对象       const xhr = new XMLHttpRequest();      // 2. 初始化 设置请求方法和url      xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;)      // 3. 发送      xhr.send();      // 4. 事件绑定 处理服务端返回的结果      xhr.onreadystatechange = function()&#123;        // readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4        //判断 (服务端返回了所有的结果)        if(xhr.readyState === 4)&#123;          //判断响应状态码 200  404  403 401 500          if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;            // 处理结果 行 头 空行 体            // 响应            console.log(&#x27;状态码&#x27;, xhr.status); // 状态码            console.log(&#x27;状态字符串&#x27;, xhr.statusText); // 状态字符串            console.log(&#x27;所有响应头&#x27;, xhr.getAllResponseHeaders()); // 所有响应头            console.log(&#x27;响应体&#x27;, xhr.response); // 响应体                        //设置 result 的文本            result.innerHTML=xhr.response;          &#125;else&#123;          &#125;        &#125;      &#125;     &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nGET设置请求参数xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;);\n\nPOST请求\n鼠标放到div中，发post请求，将响应体放在div中呈现\n\nserver.js添加post\napp.post(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax POST&quot;);&#125;);\n\npost.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Ajax POST 请求&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #903;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 获取元素对象    const result = document.getElementById(&#x27;result&#x27;);    // 绑定事件    result.addEventListener(&quot;mouseover&quot;, function()&#123;      // 1. 创建对象      const xhr = new XMLHttpRequest();      // 2. 初始化 设置类型（请求方式）与url      xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;);      // 3. 发送   设置请求参数（请求体）      xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;);      // 4. 事件绑定      xhr.onreadystatechange = function()&#123;        // 判断        if(xhr.readyState === 4)&#123;          if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123;            // 处理服务端返回的结果            result.innerHTML = xhr.response;          &#125;        &#125;      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nPOST设置请求头信息// 设置请求体内容的类型xhr.setRequesHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-from-urlencoded&#x27;);// 自定义头信息xhr.setRequesHeader(&#x27;name&#x27;, &#x27;atguigu&#x27;);\n\n\n请求头中可放身份校验信息，发送给后端进行身份校验\n\nserver.js中设置响应头允许自定义请求头 并把post改成all\n//可以接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  //设置响应头 可接受所有类型的头信息（包括自定义）  response.setHeader(&#x27;Access-Control-Allow-Header&#x27;,&#x27;*&#x27;);  // 设置响应体  response.send(&quot;Hello Ajax POST&quot;);&#125;);\n\njson数据请求server.js\napp.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123;  // 设置响应头, 设置允许跨域  response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  // 设置响应头, 设置允许自定义头信息  response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);  // 响应一个数据  const data = &#123;    name: &#x27;atguigu&#x27;  &#125;;  // 对 对象 进行 字符串 转换  let str = JSON.stringify(data)  // 设置响应体   response.send(str);&#125;);\n\nhtml\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;JSON&lt;/title&gt;  &lt;style&gt;    #result &#123;      width: 200px;      height: 100px;      border: solid 1px #89b;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    const result = document.getElementById(&#x27;result&#x27;);    // 绑定键盘按下事件    window.onkeydown = function()&#123;      // 发送请求      const xhr = new XMLHttpRequest();      // *2*.(自动转换) 设置响应体数据的类型(自动转换)      xhr.responseType = &#x27;json&#x27;;      // 初始化      xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/json-server&#x27;);      // 发送      xhr.send();      // 事件绑定      xhr.onreadystatechange = function()&#123;        if(xhr.readyState === 4)&#123;          if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;            console.log(xhr.response);            // 1. 手动对数据转化 (字符串再转换成json)            // let data = JSON.parse(xhr.response); //转换成json            // result.innerHTML = data.name;            // *2*. (自动转换)自动转换(自动转换)            result.innerHTML = xhr.response.name; //已经自动变成json          &#125;        &#125;      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n请求超时与网络异常超时或网络异常时，自动取消请求\n// 超时设置 （2秒）xhr.timeout = 2000;// 超时回调xhr.ontimeout = function()&#123;\talert(&#x27;网络超时，请稍后重试&#x27;)&#125;// 网络异常回调xhr.onerror = function()&#123;\talert(&#x27;网络异常，请稍后重试&#x27;)&#125;\n\n取消请求人工取消请求\n// 手动取消xhr.abort()\n\n重复请求问题let x = null;//标识变量let isSending = false; // 是否正在发送AJAX请求btns[0].onclick = function()&#123;    //判断标识变量    if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求    x = new XMLHttpRequest();    //修改 标识变量的值    isSending = true;    x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;);    x.send();    x.onreadystatechange = function()&#123;        if(x.readyState === 4)&#123;            //修改标识变量            isSending = false;        &#125;    &#125;&#125;// abortbtns[1].onclick = function()&#123;    x.abort();&#125;\n\n解决 IE 缓存问题\n问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。\n\n解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题\nxhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());\n\nAJAX 请求状态xhr.readyState 可以用来查看请求当前的状态https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n\n\n0: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用\n1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息\n2: 表示send()方法已经执行，并且头信息和状态码已经收到\n3: 表示正在接收服务器传来的body 部分的数据\n4: 表示服务器数据已经完全接收，或者本次接收已经失败了\n\nAPI总结\nXMLHttpRequest()：创建 XHR 对象的构造函数\nstatus：响应状态码值，如 200、404\nstatusText：响应状态文本，如 ’ok‘、‘not found’\nreadyState：标识请求状态的只读属性 0-1-2-3-4\nonreadystatechange：绑定 readyState 改变的监听\nresponseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应\nresponse：响应体数据，类型取决于 responseType 的指定\ntimeout：指定请求超时时间，默认为 0 代表没有限制\nontimeout：绑定超时的监听\nonerror：绑定请求网络错误的监听\nopen()：初始化一个请求，参数为：(method, url[, async])\nsend(data)：发送请求\nabort()：中断请求 （发出到返回之间）\ngetResponseHeader(name)：获取指定名称的响应头值\ngetAllResponseHeaders()：获取所有响应头组成的字符串\nsetRequestHeader(name, value)：设置请求头\n\n","categories":["Ajax"],"tags":["原生Ajax"]},{"title":"Ajax（七）：跨域","url":"/2022/04/20/Ajax%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F/","content":"同源策略\n同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略\n\n同源： 当前网页的url和Ajax请求的目标资源的url，两者的协议、域名、端口号必须完全相同\n\n跨域： 违背同源策略就是跨域，\n项目中常出现，因为单台服务器性能是有上限的，需要增加不同的服务器对服务进行划分\n\nAjax默认遵循同源策略\n\n\nserver.js\nconst express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/home&#x27;, (request, response)=&gt;&#123;    //响应一个页面   __dirname获取绝对路径    response.sendFile(__dirname + &#x27;/index.html&#x27;);&#125;);app.get(&#x27;/data&#x27;, (request, response)=&gt;&#123;    response.send(&#x27;用户数据&#x27;);&#125;);app.listen(9000, ()=&gt;&#123;    console.log(&quot;服务已经启动...&quot;);&#125;);\n\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;尚硅谷&lt;/h1&gt;    &lt;button&gt;点击获取用户数据&lt;/button&gt;    &lt;script&gt;        const btn = document.querySelector(&#x27;button&#x27;);        btn.onclick = function()&#123;            const x = new XMLHttpRequest();            //这里因为是满足同源策略的, 所以 url 可以简写            x.open(&quot;GET&quot;,&#x27;/data&#x27;);            //发送            x.send();            //            x.onreadystatechange = function()&#123;                if(x.readyState === 4)&#123;                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;                        console.log(x.response);                    &#125;                &#125;            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如何解决跨域JSONPJSONP 是什么JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get 请求。\nJSONP 怎么工作的？在网页有一些标签天生具有跨域能力，比如：img link iframe script。JSONP 就是利用script 标签的跨域能力来发送请求的。\nJSONP 的使用\n动态的创建一个script 标签\nvar script = document.createElement(&quot;script&quot;);\n\n设置script 的src，设置回调函数\nscript.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;;function abc(data) &#123;\talert(data.name);&#125;;\n\n将script 添加到body 中\ndocument.body.appendChild(script);\n\n服务器中路由的处理\nrouter.get(&quot;/testAJAX&quot; , function (req , res) &#123;\tconsole.log(&quot;收到请求&quot;);\tvar callback = req.query.callback;\tvar obj = &#123;\t\tname:&quot;孙悟空&quot;,\t\tage:18\t&#125;\tres.send(callback+&quot;(&quot;+JSON.stringify(obj)+&quot;)&quot;);&#125;);\n\n原生jsonp实践\n前端html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;    &lt;p&gt;&lt;/p&gt;    &lt;script&gt;        //获取 input 元素        const input = document.querySelector(&#x27;input&#x27;);        const p = document.querySelector(&#x27;p&#x27;);                //声明 handle 函数        function handle(data)&#123;            input.style.border = &quot;solid 1px #f00&quot;;            //修改 p 标签的提示文本            p.innerHTML = data.msg;        &#125;        //绑定事件        input.onblur = function()&#123;            //获取用户的输入值            let username = this.value;            //向服务器端发送请求 检测用户名是否存在            //1. 创建 script 标签            const script = document.createElement(&#x27;script&#x27;);            //2. 设置标签的 src 属性            script.src = &#x27;http://127.0.0.1:8000/check-username&#x27;;            //3. 将 script 插入到文档中            document.body.appendChild(script);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nserver.js\n//用户名检测是否存在app.all(&#x27;/check-username&#x27;,(request, response) =&gt; &#123;    // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);    const data = &#123;        exist: 1,        msg: &#x27;用户名已经存在&#x27;    &#125;;    //将数据转化为字符串    let str = JSON.stringify(data);    //返回结果    response.end(`handle($&#123;str&#125;)`);&#125;);\n\n使用jQuery发送jsonp请求&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t\t&lt;title&gt;Title&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\t\t&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-1.12.3.js&quot;&gt;&lt;/script&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\twindow.onload = function () &#123;\t\t\t\tvar btn = document.getElementById(&#x27;btn&#x27;)\t\t\t\tbtn.onclick = function () &#123;\t\t\t\t\t$.getJSON(&quot;http://api.douban.com/v2/movie/in_theaters?callback=?&quot;,function(data) &#123;\t\t\t\t\t\tconsole.log(data);\t\t\t\t\t\t//获取所有的电影的条目\t\t\t\t\t\tvar subjects = data.subjects;\t\t\t\t\t\t//遍历电影条目\t\t\t\t\t\tfor(var i=0 ; i&lt;subjects.length ; i++)&#123;\t\t\t\t\t\t\t$(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot;+\t\t\t\t\t\t\tsubjects[i].title+&quot;&lt;br /&gt;&quot;+\t\t\t\t\t\t\t&quot;&lt;img src=\\&quot;&quot;+subjects[i].images.large+&quot;\\&quot; &gt;&quot;+\t\t\t\t\t\t\t&quot;&lt;/li&gt;&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nCORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\nCORS 是什么？CORS（Cross-Origin Resource Sharing），跨域资源共享。\nCORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源\nCORS 怎么工作的？CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。\nCORS 的使用主要是服务器端的设置：\nrouter.get(&quot;/testAJAX&quot; , function (req , res) &#123;\t//通过set 来设置响应头，来允许跨域请求\t//res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;);\tres.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);\tres.send(&quot;testAJAX 返回的响应&quot;);&#125;);\n\n\n代码示例\n前端html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;CORS&lt;/title&gt;    &lt;style&gt;        #result&#123;            width:200px;            height:100px;            border:solid 1px #90b;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;button&gt;发送请求&lt;/button&gt;    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;    &lt;script&gt;        const btn = document.querySelector(&#x27;button&#x27;);        btn.onclick = function()&#123;            //1. 创建对象            const x = new XMLHttpRequest();            //2. 初始化设置            x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/cors-server&quot;);            //3. 发送            x.send();            //4. 绑定事件            x.onreadystatechange = function()&#123;                if(x.readyState === 4)&#123;                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;                        //输出响应体                        console.log(x.response);                    &#125;                &#125;            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nserver.js\napp.all(&#x27;/cors-server&#x27;, (request, response)=&gt;&#123;    //设置响应头    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;);    response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;);    // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);    response.send(&#x27;hello CORS&#x27;);&#125;);\n\n","categories":["Ajax"],"tags":["跨域","同源策略","JSONP","CORS"]},{"title":"Ajax（二）：HTTP","url":"/2022/04/20/Ajax%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHTTP/","content":"http\nHTTP（hypertext transport protocol）超文本传输协议，协议详细规定了浏览器和万维网服务器之间相互通信的规则\n约定、规则\n\nMDN 文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\nHTTP 请求交互的基本过程\n-  前后应用从浏览器端向服务器发送HTTP 请求(请求报文)\n\n后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)\n浏览器端接收到响应, 解析显示响应体&#x2F;调用监视回调\n\nHTTP 请求报文\n请求行\n\n  格式：method &#x2F; url 协议版本  GET / product_detail?id=2 HTTP/1.1  POST /login\n\n多个请求头\n\n  格式：名字: 值\n  Host: www.baidu.com  Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;  Content-Type: application/x-www-form-urlencoded 或者application/json\n  User-Agent: chrome 83\n\n空行\n请求体\n\n\n如果是GET请求，请求体为空\n如果是POST请求，请求体可以不为空\n\n  username=tom&amp;pwd=123  {“username”: “tom”, “pwd”: 123}\nHTTP 响应报文\n响应状态行格式：协议版本 响应状态码 响应状态字符串\nHTTP&#x2F;1.1 200 OK\n\n多个响应头格式：名字: 值\nContent-Type: text/html;charset=utf-8\nContent-length: 2048\nContent-encoding: gzip\nSet-Cookie: BD_CK_SAM=1;path=/\n\n空行\n响应体html 文本 &#x2F; json 文本 &#x2F; js&#x2F;css&#x2F;图片…\n\n\npost 请求体参数格式\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n用于键值对参数，参数的键值用&#x3D;连接, 参数之间用&amp;连接\n例如: name=%E5%B0%8F%E6%98%8E&amp;age=12\n\nContent-Type: application/json;charset=utf-8\n用于 json 字符串参数\n例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125;\n\nContent-Type: multipart/form-data\n用于文件上传请求\n\n\n常见的响应状态码\n200 OK 请求成功。一般用于GET 与POST 请求\n201 Created 已创建。成功请求并创建了新的资源\n401 Unauthorized 未授权&#x2F;请求要求用户的身份认证\n404 Not Found 服务器无法根据客户端的请求找到资源\n500 Internal Server Error 服务器内部错误，无法完成请求\n\n不同类型的请求及其作用\nGET: 从服务器端读取数据（查）\nPOST: 向服务器端添加新数据 （增）\nPUT: 更新服务器端已经数据 （改）\nDELETE: 删除服务器端数据 （删）\n\nAPI 的分类\nREST API: restful （Representational State Transfer (资源)表现层状态转化）\n(1) 发送请求进行CRUD 哪个操作由请求方式来决定\n(2) 同一个请求路径可以进行多个操作\n(3) 请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE\n\n非REST API: restless\n(1) 请求方式不决定请求的CRUD 操作\n(2) 一个请求路径只对应一个操作\n(3) 一般只有GET&#x2F;POST\n\n\n区别 一般http请求 与 ajax请求\najax请求 是一种特别的 http请求\n对服务器端来说, 没有任何区别, 区别在浏览器端\n浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求\n浏览器端接收到响应\n一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新&#x2F;跳转页面\najax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据\n\n\n\n","categories":["Ajax"],"tags":["HTTP"]},{"title":"Ajax（五）：Axios发送Ajax请求","url":"/2022/04/20/Ajax%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AAxios%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82/","content":"axios介绍axios不是一种新的技术。\naxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，有以下特点：\n\n从浏览器中创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\nget请求axios#get(url[,config])\n\n//GET 请求axios.get(&#x27;/axios-server&#x27;, &#123;    //url 参数    params: &#123;        id: 100,        vip: 7    &#125;,    //请求头信息    headers: &#123;        name: &#x27;atguigu&#x27;,        age: 20    &#125;&#125;).then(value =&gt; &#123;    console.log(value);&#125;);\n\npost请求axios#post(url[,data[,config]])\n\naxios.post(&#x27;/axios-server&#x27;, &#123;    username: &#x27;admin&#x27;,    password: &#x27;admin&#x27;&#125;, &#123;    //url     params: &#123;        id: 200,        vip: 9    &#125;,    //请求头参数    headers: &#123;        height: 180,        weight: 180,    &#125;&#125;);\n\n通用方法axios(&#123;    //请求方法    method : &#x27;POST&#x27;,    //url    url: &#x27;/axios-server&#x27;,    //url参数    params: &#123;        vip:10,        level:30    &#125;,    //头信息    headers: &#123;        a:100,        b:200    &#125;,    //请求体参数    data: &#123;        username: &#x27;admin&#x27;,        password: &#x27;admin&#x27;    &#125;&#125;).then(response=&gt;&#123;    //响应状态码    console.log(response.status);    //响应状态字符串    console.log(response.statusText);    //响应头信息    console.log(response.headers);    //响应体    console.log(response.data);&#125;)\n\n更多配置查看jQuery文档\n","categories":["Ajax"],"tags":["Ajax","Axios"]},{"title":"CSS基础（一）：选择器的分类及作用","url":"/2022/02/26/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8/","content":"常用选择器\n元素选择器\n作用：根据标签名来选中指定元素\n\n语法：标签名{}\n\n示例：\np&#123;\tcolor: red;&#125;h1&#123;    color: green;&#125;div&#123;    color: blue;&#125;\n\n\nid选择器\n作用：根据元素的id属性值选中一个元素（不能重复）\n\n语法：#id属性值{}\n\n示例：\n&lt;p id=&quot;red&quot;&gt;test&lt;/p&gt;\n\n#red&#123;\tcolor: red;&#125;#box&#123;\tcolor: red;&#125;\n\n\n类选择器\n作用：根据元素的class属性值选中一组元素（可重复）\n\n语法：.class属性值{}\n\n示例：\n&lt;p class=&quot;blue&quot;&gt;test1&lt;/p&gt;&lt;p class=&quot;blue red&quot;&gt;test2&lt;/p&gt;\n\n.blue&#123;\tcolor: blue;&#125;.red&#123;\tcolor: red;&#125;\n\n\n通配选择器\n作用：选中页面中的所有元素\n\n语法：*\n\n示例：\n*&#123;\tcolor: blue;&#125;\n\n\n\n复合选择器\n交集选择器\n作用：选中同时符合多个条件的元素\n\n语法：选择器1选择器2……选择器n{}\n\n示例：\ndiv.red&#123;    font-size:30px;&#125;.a.b.c&#123;    font-size:30px;&#125;/*语法上没问题，但没必要这么写，因为box1已经可以指定唯一元素*/div#box1&#123;    &#125;\n\n注意：交集选择器中如果有元素选择器，必须使用元素选择器开头\n\n\n\n并集选择器（分组选择器）\n作用：同时选择多个选择器对应的元素\n\n语法：选择器1，选择器2，……，选择器n{}\n\n示例：\nh1, span&#123;    &#125;/*交集并集组合，最后div.red表示class值为red的div*/#b1,.p1,h1,span,div.red&#123;    &#125;\n\n\n\n关系选择器\n元素关系\n\n父元素：直接包含子元素的元素\n子元素：直接呗父元素包含的元素\n祖先元素：直接或间接包含后代元素的元素（一个元素的父元素也是它的祖先元素）\n后代元素：直接或间接被祖先元素包含的元素（子元素也是后代元素）\n兄弟元素：拥有相同父元素的元素\n\n\n示例：\n&lt;div&gt;    我是一个div    &lt;p&gt;        我是div中的p元素        &lt;span&gt;我是p元素中的span元素&lt;/span&gt;    &lt;/p&gt;    &lt;span&gt;我是div中的span元素&lt;/span&gt;&lt;/div&gt;\n\n\n子元素选择器\n作用：选中指定父元素中的指定子元素\n\n语法：父元素 &gt; 子元素{}\n\n示例：\ndiv &gt; span&#123;    color: blue;&#125;div &gt; p &gt; span&#123;    &#125;\n\n\n后代元素选择器\n作用：选中指定元素中的指定后代元素\n\n语法：祖先  后代{}\n\n示例：\ndiv span &#123;    color: blue;&#125;\n\n\n兄弟元素选择器\n选中下一个兄弟元素\n\n语法：前一个 +  后一个{}\n\n示例：\np + span &#123;    color: blue;&#125;\n\n\n选中下边所有的兄弟\n\n语法：兄 ~  弟{}\n\n示例：\np ~ span &#123;    color: blue;&#125;\n\n\n\n\n\n属性选择器示例：\n&lt;p title=&quot;abc&quot;&gt;&lt;/p&gt;&lt;p title=&quot;abcdef&quot;&gt;&lt;/p&gt;&lt;p title=&quot;helloabc&quot;&gt;&lt;/p&gt;&lt;p title=&quot;heabcllo&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n\n\n选中含有指定属性的元素\n语法：[属性名]{}\n\n示例：\np[title]&#123;    color: blue;&#125;\n\n\n选中含有指定属性和属性值的元素\n语法：[属性名&#x3D;属性值]{}\n\n示例：\np[title=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值以指定值开头的元素\n语法：[属性名^&#x3D;abc]{}\n\n示例：\np[title^=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值以指定值结尾的元素\n语法：[属性名$&#x3D;abc]{}\n\n示例：\np[title$=“abc”]&#123;    color: blue;&#125;\n\n\n选中属性值含有某值的元素\n语法：[属性名*&#x3D;abc]{}\n\n示例：\np[title*=‘abc’]&#123;    color: blue;&#125;\n\n\n\n伪类选择器\n伪类（不存在的类，特殊的类）\n\n伪类用来描述一个元素的特殊状态\n比如：第一个子元素、被点击的元素、鼠标移入的元素……\n\n\n伪类一般情况下都是使用：开头\n\n\n示例：\n&lt;ul&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n:first-child\n作用：选中第一个子元素\n\n示例：\nul&gt;li:first-child&#123;    color: blue;&#125;\n\n\n:last-child\n作用：选中最后一个子元素\n\n示例：\nul&gt;li:last-child&#123;    color: blue;&#125;\n\n\n:nth-child()\n作用：选中第n个子元素\n\n特殊值：\n\nn：全选中\n2n或even：选中偶数位的元素\n2n+1或odd：选中奇数位的元素\n\n\n示例：\nul&gt;li:nth-child(3)&#123;    color: blue;&#125;ul&gt;li:nth-child(n)&#123;    color: blue;&#125;\n\n\n\n\n以上这些伪类都是根据所有的子元素进行排序\n\n示例：\n&lt;ul&gt;    &lt;span&gt;第〇个&lt;/span&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n:first-of-type\n示例：\nul&gt;li:first-of-type&#123;    color: blue;&#125;\n\n\n:last-of-type\n:nth-of-type\n\n\n以上这些伪类和上述的类似，不同点是它们是在同类型元素中进行排序\n\n\n:not() 否定伪类\n作用：将符合条件的元素从选择器中去除\n\n示例：\nul&gt;li:not(:nth-child(3))&#123;    color: blue;&#125;\n\n\n超链接的伪类（a元素的伪类）\n作用：将符合条件的元素从选择器中去除\n\n语法：\n\na:link{}\n用来表示没访问过的链接（正常的链接）\n\na:visited{}\n用来表示访问过的链接（点击过）\n由于隐私原因，visited这个伪类只能修改链接的颜色\n\n\n\n示例：\na:link&#123;    color:red;    font-size:20px;&#125;a:visited&#123;    color:orange;    /*font-size在visited中不起作用*/    font-size:20px;&#125;\n\n\n:hover 鼠标移入伪类\n作用：用来表示鼠标移入的状态\n\n示例：\na:hover&#123;    color:aqua;    font-size:50px;&#125;\n\n\n:active 鼠标点击伪类\n作用：用来表示鼠标点击\n\n示例：\na:active&#123;    color:aqua;    font-size:50px;&#125;\n\n\n\n\n注：有先后顺序之分，link、vidited、focus、hover、active（其中link和visited顺序可交换\n\n伪元素选择器\n伪元素（不存在的元素，特殊的位置）\n\n伪类一般情况下都是使用 :: 开头\n\n\n示例：\n&lt;ul&gt;    &lt;li&gt;第一个&lt;/li&gt;    &lt;li&gt;第二个&lt;/li&gt;    &lt;li&gt;第三个&lt;/li&gt;    &lt;li&gt;第四个&lt;/li&gt;    &lt;li&gt;第五个&lt;/li&gt;&lt;/ul&gt;\n\n\n::first-letter{}\n作用：表示第一个字母\n\n示例：\np::first-letter&#123;    font-size:50px;&#125;\n\n\n::first-line{}\n作用：表示第一行\n\n示例：\np::first-line&#123;    background-color:yellow;&#125;\n\n\n::selection{}\n作用：表示选中的内容\n\n示例：\np::selection&#123;    background-color:greenyellow;&#125;\n\n\n::before{}\n作用：表示元素的开始，必须结合content属性一起用\n\n示例：\ndiv::before&#123;    /*在div中最开头出现红色abc字样，因为它是通过css加的，所以它无法被选中*/    content:&#x27;abc&#x27;;    color:red;&#125;\n\n\n::after{}\n作用：表示元素的最后，必须结合content属性一起用\n\n示例：\ndiv::before&#123;    /*在div中最开头出现红色abc字样，因为它是通过css加的，所以它无法被选中*/    content:&#x27;abc&#x27;;    color:red;&#125;\n\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"Ajax（四）：jQuery中的Ajax","url":"/2022/04/20/Ajax%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AjQuery%E4%B8%AD%E7%9A%84Ajax/","content":"get请求$.get(url, [data], [callback], [type])\n\n\nurl:请求的URL 地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text, _default\n\n$(&#x27;button&#x27;).eq(0).click(function()&#123;            $.get(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123;                console.log(data);            &#125;,&#x27;json&#x27;);        &#125;);\n\npost请求$.post(url, [data], [callback], [type])\n\n\nurl:请求的URL 地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text, _default\n\n$(&#x27;button&#x27;).eq(1).click(function()&#123;            $.post(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123;                console.log(data);            &#125;);        &#125;);\n\n通用方法$.ajax(&#123;\t// url\turl: &#x27;http://127.0.0.1:8000/jquery-server&#x27;,\t// 参数\tdata: &#123;a:100, b:200&#125;,\t// 请求类型\ttype: &#x27;GET&#x27;,\t// 响应体结果\tdataType: &#x27;json&#x27;,\t// 成功的回调\tsuccess: function(data)&#123;console.log(data);&#125;,\t// 超时时间\ttimeout: 2000,\t// 失败的回调\terror: function()&#123;console.log(&#x27;出错拉~&#x27;);&#125;,\t// 头信息\theaders: &#123;\t\tc: 300,\t\td: 400\t&#125;\t&#125;)\n\n更多配置查看jQuery文档\n","categories":["Ajax"],"tags":["Ajax","jQuery"]},{"title":"Ajax（六）：使用fetch函数发送Ajax请求","url":"/2022/04/20/Ajax%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8fetch%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81Ajax%E8%AF%B7%E6%B1%82/","content":"语法Promise&lt;Response&gt; fetch(input[,init]);\n\n\ninput：url\ninit：配置项\n\nfetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123;    //请求方法    method: &#x27;POST&#x27;,    //请求头    headers: &#123;        name:&#x27;atguigu&#x27;    &#125;,    //请求体    body: &#x27;username=admin&amp;password=admin&#x27;&#125;).then(response =&gt; &#123;    // return response.text();    return response.json();&#125;).then(response=&gt;&#123;    console.log(response);&#125;);\n\n","categories":["Ajax"],"tags":["Ajax","fetch"]},{"title":"CSS基础（七）：字体","url":"/2022/03/02/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AD%97%E4%BD%93/","content":"字体相关样式\ncolor  字体颜色（严格：前景色，一般用来设置字体颜色）\n\nfont-size：字体大小\n\n1 em &#x3D; 当前元素的一个font-size\n1 rem &#x3D; 根元素的一个font-size\n\n\nfont-family：字体族（格式）\n\n可同时指定多个字体，字体间使用逗号隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推\n\n可选值：具体的字体名（eg.’微软雅黑’ ）或者 字体分类\n​    字体分类：浏览器自动使用该类别下的字体\n\nserif 衬线字体\nsans-serif 非衬线字体\nmonospace 等宽字体（每个字母宽度一样）\n\n\n若用户本地没有相关字体\n@font-face&#123;    /*指定字体的名字*/    font-family:&#x27;myfont&#x27;;    /*服务器中字体的路径，并确保兼容性*/    src:url(&#x27;./font/xxxx.ttf&#x27;)format(&#x27;truetye&#x27;);&#125;p&#123;    font-family:myfont;&#125;\n\n问题：加载速度、版权、字体格式\n\n\n\nfont-weight：字重\n\n可选值：\nnormal 默认值 不加粗\nbold 加粗\n100-900 九个级别（没什么用）\n\n\n\n\nfont-style：字体风格\n\n可选值：\nnormal 默认值 不斜体\nitalic 斜体\n\n\n\n\n\n字体的简写属性\nfont：字体大小 字体族；\n\ndiv&#123;    font:50px &#x27;Times New Roman&#x27;,Times,serif;&#125;\n\n\nfont：字体大小&#x2F;行高 字体族；\n\ndiv&#123;    font:50px/2 &#x27;Times New Roman&#x27;,Times,serif;&#125;/*行高可以省略不写 如果不写使用默认值*/\n\n\nfont：字重  字体风格 字体大小&#x2F;行高 字体族；\n\ndiv&#123;    font:bold italic 50px/2 &#x27;Times New Roman&#x27;,Times,serif;&#125;\n\n\n\n图标字体（iconfont）图标网站\nfontawesome：下载，将css和webfonts移动到项目中，将all.css引入网页中\niconfont（阿里）：加入购物车，项目下载，将内容移动到项目中，将iconfont.css引入网页中\n\n使用\n通过类名\n&lt;!--标签名随意，第一个类名：fas或fab，第二个类名：图标名（见文档）--&gt;&lt;i class=&quot;fas fa-bell&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-bell-slash&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fab fa-accessible-icon&quot;&gt;&lt;/i&gt;\n\n通过伪类\nli:before&#123;    /*图标编码（见文档）*/    content:&#x27;\\f1b0&#x27;;    /*图标字体族，根据fas或fab去下载的css文件里查*/    font-family:&#x27;Font Awesome 5 Free&#x27;;    /*根据fas或fab去下载的css文件里查*/    font-weight:900;&#125;\n\n通过实体\n&lt;!--实体开头&amp;结尾；中间#x加图标编码--&gt;&lt;i class=&quot;fas&quot;&gt;&amp;#f0f3x;&lt;/i&gt;\n\n\n以上以fontawesome为例\niconfont使用方法区别在于class&#x3D;”iconfont”\n\n行高（line-height）\n行高：文字占有的实际高度\n\n\n可选值：\n带单位：px、em\n不带单位：字体的倍数(默认行高为1.3左右)\n\n\n\ndiv&#123;    font-size:50px;    line-height:100px;&#125;div&#123;    font-size:50px;    line-height:2;&#125;\n\n\n字体框：字体存在的格子，设置font-size实际上就是在设置字体框的高度\n\n\n行高会在字体框的上下平均分配\n可以将行高设置为和元素高度一样的值，使单行文字居中\n\n行高还可用来设置行间距\n行间距 &#x3D; 行高 - 字体大小\n\n\n文本相关样式\ntext-align：文本的水平对齐\n\n可选值：\nleft 左对齐\nright 右对齐\ncenter 居中对齐\njustify 两端对齐\n\n\n\n\nvertical-align：文本的垂直对齐（适用于父子元素字体大小不一样）\n\n可选值：\n\nbaseline 默认值，基线对齐\ntop 顶部对齐\nbottom 底部对齐\nmiddle 居中对齐\n具体数值 px\n\n\n图片方面的应用：\n\n问题：图片默认情况下也按基线对齐（与下边框有一缝隙）\n\n\n解决：通过vertical-align取消基线对齐\n\n示例：\nimg&#123;    /*top或bottom都行，只要不是基线对齐*/    vertical-aglin:top;&#125;\n\n\n\n\ntext-decoration：文本修饰\n\n可选值：\nnone 什么都没有\nunderline 下划线\nline-through 删除下\noverline 上划线\n\n\ntext-decoration：修饰 颜色 样式\neg. text-decoration：underline red dotted；(IE浏览器不支持)\n\n\n\n\nwhite-space：处理空白\n\n可选值：\n\nnormal 正常\nnowrap 不换行\npre 保留空白（不会把换行变成空格）\n\n\n示例：\n.box2&#123;    width:200px;    /*设置不换行*/    white-space:nowrap;    /*将多余内容裁剪*/    overflow:hidden;    /*文本溢出时，溢出内容显示省略号*/    text-overflow:ellipsis;&#125;\n\n\ntext-indent：首行缩进\n\n\n","categories":["CSS"],"tags":["CSS","字体","图标","文本"]},{"title":"CSS基础（二）：继承","url":"/2022/02/27/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF/","content":"定义为一个元素设置的样式同时也会应用到它的后代元素上，发生在祖先和后代之间\n作用继承的设计是为了方便开发，利用继承可以将一些通用的样式统一设置到共同的祖先元素上，这样就只需设置一次即可让所有的元素都具有该样式\n注意并不是所有的样式都会被继承，比如：背景相关、布局相关的这些样式有不会被继承。可通过查阅文档（inherited）看是否被能够被继承\n示例&lt;p&gt;    我是一个p元素    &lt;span&gt;我是p元素中的span&lt;/span&gt;&lt;/p&gt;\n\np&#123;    /*则p和span中文字都变红*/    color:red;    /*则p背景变橙色，span背景为默认值透明，但看起来也是橙色*/    background-color:orange;&#125;\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS基础（三）：选择器的权重","url":"/2022/02/27/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D/","content":"\n样式的冲突：通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值。\n发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定\n\n选择器的权重（css specificity）排序\n内联样式\n优先级：1,0,0,0（最高）\n\n示例：\n&lt;div id=&quot;box1&quot; class=&quot;red&quot; style=&quot;background-color:skyblue&quot;&gt;    我是一个div&lt;/div&gt;\n\n\nid选择器\n优先级：0,1,0,0\n\n示例：\n#box1&#123;    background-color:orange;&#125;\n\n\n类、伪类选择器、属性选择器\n优先级：0,0,1,0\n\n示例：\n.red&#123;    background-color:red;&#125;\n\n\n元素选择器\n优先级：0,0,0,1\n\n示例：\ndiv&#123;    background-color:yellow;&#125;\n\n\n通配选择器\n优先级：0,0,0,0\n\n示例：\ndiv&#123;    font-size:20px;&#125;*&#123;    font-size:50px;&#125;/*则字体显示为20px大小*/\n\n\n继承的样式\n优先级：没有优先级\n\n示例：\n&lt;div&gt;    我是一个div    &lt;span&gt;我是div中的span&lt;/span&gt;&lt;/div&gt;\n\ndiv&#123;    font-size:20px;&#125;*&#123;    font-size:50px;&#125;/*则“我是一个div”字体显示为20px大小，“我是div中的span”字体显示为50px*/\n\n\n\n\n比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的，不会相加）\n\n\n示例：\n/*优先级为0，0，0，1*/div&#123;    background-color:yellow;&#125;/*优先级为0，1，0，1*/div#box&#123;    background-color:orange;&#125;/*单独计算优先级，在选择器内不参与累加*/div,p,span&#123;    background-color:orange;&#125;\n\n\n选择器的累加不会超过器最大的数量级，比如：类选择器再高也不会超过id选择器\n\n\n示例：\n/*优先级为0，1，0，0*/#box&#123;    background-color:yellow;&#125;/*优先级不超过0，1，0，0*/.d1.d2.d3.d4.d5.d6.d7.d8.d9.d10.d11&#123;    background-color:yellow;&#125;\n\n\nTips：选择器写得越具体、越长，优先级越高。\n\n\n若优先级计算后相同，则优先使用靠下的样式\n\n\n示例：\n&lt;div class=&quot;d1 d2&quot;&gt;    &lt;/div&gt;\n\n.d1&#123;    background-color:yellow;&#125;.d2&#123;    background-color:red;&#125;/*则背景显示为红色*/\n\n\n可以在某一个样式后边添加 ！important，则此时该样式会获取到最高的优先级，甚至超过内联样式\n\n\n示例：\n&lt;div id=&quot;box1&quot; class=&quot;d1&quot; style=&quot;background-color:skyblue&quot;&gt;    我是一个div&lt;/div&gt;\n\n.d1&#123;    background-color:yellow !important;&#125;/*则背景显示为黄色*/\n\n\n注意：在开发中要慎用 ！important。\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS基础（六）：背景","url":"/2022/03/03/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%83%8C%E6%99%AF/","content":"背景相关样式\nbackground-color：背景颜色\n\nbackground-image ：背景图片\n\nurl(.&#x2F;img&#x2F;1.png) 或 url(‘.&#x2F;img&#x2F;1.png’)\n\n可同时设置背景颜色和背景图片\n\n若背景图片小于元素，则自动平铺\n\n若背景图片大于元素，则裁剪\n\n渐变：\n\n线性渐变：linear-gradient（方向，开头颜色，结束颜色）\n方向：to left,to right,to bottom, to top, xxxdeg(度数)，.xxturn(圈数)\n可指定多种颜色，默认情况下平均分，也可手动指定渐变情况\n\n平铺线性渐变：repeating-linear-gradient()\n\n径向渐变：radial-gradient（形状 at 位置，颜色 位置，颜色 位置，颜色 位置）\n可手动指定渐变的大小、渐变的位置\n\n\n\n\n\nbackground-repeat：背景图片重复方式\n\n可选值：\nrepeat 默认值，沿x轴、y轴双方向重复\nrepeat-x 沿x轴重复\nrepeat-y 沿y轴重复\nno-repeat 不重复\n\n\n\n\nbackground-positon：背景图片位置\n\n方位词：top left right bottom center 组合（九宫格）\nbackground-positon: top lleft\n同时指定两个值，若只写一个则第二个默认center\n\n偏移量：水平方向偏移量 垂直方向偏移量\nbackground-positon:100px 100px \n实际开发中，用负值较多\n\n应用：CCS-Sprite技术（雪碧图or精灵图）\n解决浏览器第一次加载时图片闪烁的问题\n将多个小图片统一保存到一个大图片中，通过调整background-position来切换显示的图片\n\n\n\n\nbackground-clip：背景的范围\n\n可选值：\nborder-box 默认值，背景会出现在边框的下面\npadding-box 背景不会出现在边框下面，只出现在内容区和内边距\ncontent-box 背景只会出现在内容区\n\n\n\n\nbackground-origin：背景图片的偏移量计算的原点\n\n可选值：\npadding-box 默认值，原点从内边距处开始计算\ncontent-box 原点从内容区处开始计算\nborder-box 原点从边框处开始计算\n\n\n\n\nbackground-size：背景图片的大小\n\n可选值：\n\n宽度 高度 （100% auto）\n如果只写一个，则第二个值默认auto，等比例缩放\n\ncover 图片的比例不变，将元素铺满\n\ncotain 图片的比例不变，将图片在元素中完整显示\n\n\n\n\n\nbackground-attachment：背景图片是否跟随元素移动（父元素设置overflow：auto出现滚动条时）\n\n可选值：\nscroll 默认值，背景图片会跟随元素移动\nfixed 背景图片会固定在页面中，不会随元素移动\n\n\n\n\nbackground 背景相关简写属性\n.box&#123;    background：#bfa url(&#x27;./img/1.png&#x27;)  center center/contain border-box content-box no-repeat;&#125;\n\n没有顺序要求，可省略\n注：\n\nbackground-size必须卸载background-position的后面，并且用&#x2F;隔开：background-size&#x2F;background-position\nbackground-origin要在background-clip前面\n\n\n\n","categories":["CSS"],"tags":["CSS","背景"]},{"title":"CSS基础（五）：布局相关知识","url":"/2022/03/01/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"文档流（normal flow）\n网页是一个多层结构，用户只能看到最顶层\n最底下的一层称为文档流，文档流是网页的基础\n创建的元素默认都在文档流中进行排列\n元素主要有两个状态：\n\n​    在文档流中\n\n​    不在文档流中（脱离文档流）\n\n\n\n元素在文档流中的特点\n块元素\n总是独占一行（无论多宽，自上向下垂直排列）\n默认宽度：父元素的全部（即把父元素撑满）\n默认高度：被子元素（子元素）撑开\n比如：div\n\n\n行内元素\n不会独占一行，只占自身大小（从左到右水平排列）\n若一行中不能容纳下所有行内元素，则换行（与书写习惯一致）\n默认宽度：被子元素（子元素）撑开\n默认高度：被子元素（子元素）撑开\n设置宽高不能生效\n\n\n\n\n一旦块元素和行内元素脱离文档流，则不具备以上特点\n\n盒子模型（box model）\n所有元素都是一个矩形的盒子\n每个盒子都由几个部分组成：\n\n内容区（content）：内容区大小由width和height决定\n内边距（padding）：会影响盒子大小\n边框（border）：会影响盒子大小\n外边距（margin）\n\n盒子的可见框的大小，默认情况下由内容区、内边距、边框共同决定\n盒子的实际大小，还受外边距影响\n\n边框（border）\n边框宽度：border-width\n可只指定四个方向的边框宽度（顺时针）\n\n如果省略，一般为3px\n\n四个值：上 右 下 左\n\n三个值：上 左右 下\n\n两个值： 上下 左右\n\n一个值：上下左右\n\n示例：\n/*上 右 下 左*/border-width:10px 20px 30px 40px;/*上 左右 下*/border-width:10px 20px 30px;/*上下 左右*/border-width:10px 20px;/*上下左右*/border-width:10px;\n\nborder-xxx-width：\nxxx可以是 top right bottom left\n\n\n\n边框颜色：border-color\n可只指定四个方向的边框颜色：规则同上\n如果省略，默认使用color的值（color默认为black）\n\n\n边框样式：border-style\n可只指定四个方向的边框样式：规则同上\nsolid 实线、dotted 点状虚线、dashed 虚线、double 双线\n不可省略，默认值为none\n\n\nborder简写属性（最常用）\nborder：width color style; (可改变顺序)\n\n示例：\n.box1&#123;    border:10px orange solid;&#125;\n\nborder-xxx 同理\nxxx可以是 top right bottom left\n\n\n\n边框圆角：border-radius\nborder-radius\n\n四个值：左上 右上 右下 左下\n三个值：左上 右上&#x2F;左下 右下\n两个值：左上&#x2F;右下 右上&#x2F;左下 \n一个值：四个角\n\n .box1&#123;    /*半径为10px*/    border-radius:10px;&#125;.box1&#123;    /*分别指定四个角的圆角*/    border-radius:10px 20px 30px 40px;&#125;/*椭圆角*/.box1&#123;    /*水平半径为10px 垂直半径为20px*/    border-radius:10px / 20px;&#125;/*将元素设置为圆形*/.box1&#123;    border-radius:50%;&#125;\n\nborder-top-left-radius\n /*椭圆*/.box1&#123;    /*水平半径为10px 垂直半径为20px*/    border-top-left-radius:10px 20px;&#125;\n\nborder-top-right-radius\n\nborder-bottom-left-radius\n\nborder-bottom-right-radius\n\n\n\n\n内边距（padding）\n内边距：内容区和边框之间的距离\n内边距的设置会影响到盒子的大小\n背景颜色会延伸到内边距上\n\n\npadding-top\npadding-right\npadding-bottom\npadding-left\n简写padding:\n规则同border-width\n\n\n\n外边距（margin）\n外边距不会影响盒子可见框大小\n但是会影响盒子的位置（即影响盒子实际大小）\n\n\nmargin-top\n上外边距，设置一个正值，元素（自身）会向下移动\n\n\nmargin-right\n默认情况下，不会产生任何效果；总是被自动调整\n\n\nmargin-bottom\n下外边距，设置一个正值，其下边的元素会向下移动\n\n\nmargin-left\n左外边距，设置一个正值，元素（自身）会向右移动\n\n\n\n\n负值则方向相反\n\n\n简写margin:\n规则同border-width\nmargin: 0px auto (水平居中)\n\n\n\n外边距重叠问题（垂直外边距的重叠）\n相邻的垂直方向的外边距会发生重叠现象\n\n兄弟元素间的垂直外边距\n两者都是正值：取两者之间的较大值\n特殊情况：\n一正一负：取两者之和\n都负：取绝对值较大值\n\n\n兄都元素之间的外边距重叠对开发有利，不需要处理\n\n父子元素间的垂直外边距\n父子元素间的相邻外边距，子元素会传递给父元素（上外边距）\n示例：\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;&#125;.box2&#123;    width:100px;    height:100px;    background-color:orange;    margin-top:100px&#125;\n\n效果：\n\n\n​    \n\n处理方式：\n\n开启父元素的BFC：见CSS提升（二）：高度塌陷问题\n\n消除”相邻”条件：利用display:table(before伪类)\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;&#125;/*利用**display:table**(before伪类)*/.box1::before&#123;    content:&#x27;&#x27;;    display:table&#125;.box2&#123;    width:100px;    height:100px;    background-color:orange;    margin-top:100px&#125;\n\n效果：\n\n\n\n\n\n盒子的大小盒子的可见框大小\n默认情况：由内容区、内边距、边框共同决定\nbox-sizing：用来设置盒子尺寸的计算方式，即设置width和height的作用\n可选值：\ncontent-box：默认值，宽度和高度用来设置内容区的大小\nborder-box：宽度和高度用来设置整个盒子的可见框大小（width和height指的是内容区和边框的总大小，不包括外边距）\n\n\n\n\n\n盒子的实际大小\n还受外边距影响\n\n盒子的水平布局 （等式）\n元素在其父元素中水平方向的位置由一下几个属性共同决定：\n\nmargin-left\nborder-left\npadding-left\nwidth\npadding-right\nborder-right\nmargin-right\n\n\n一个元素在其父元素中水平布局必须要满足以下式：\n\nmargin-left + border-left + padding-left + width + padding-right + border-right + margin-right &#x3D; 其父元素内容区的宽度\n\n若相加结果使等式不成立，称为过度约束，则等式会自动调整：\n\n如果这七个值中没有为auto的情况：\n则浏览器会自动调整margin-right值以使等式满足\n\n这七个值中有三个可以设置为auto：\n\nwidth\n\nmargin-left\n\nmargin-right\n(padding不可以自动调整)\n\n\n\n若某个值为auto，则自动调整设有auto的那个属性使等式成立\n（width的值默认是auto）\n若将width和一个外边距设置为auto，则width调整为最大，设置为auto的外边距会自动为0\n若将两个外边距设置为auto，width固定，则外边距设置为相同值（居中）\n若将三个值都设置为auto，则width调整为最大，外边距都为0\n\n\n\n盒子的垂直布局 （溢出问题）\n默认情况下父元素的高度被内容撑开\n\noverflow （用于解决溢出）\n溢出：子元素的大小超过了父元素，则子元素从父元素中溢出\n解决溢出：使用overflow属性设置父元素\n可选值：\nvisible（默认值）：溢出\nhidden：溢出的内容被裁剪不会显示\nscroll：生成两个（垂直+水平）滚动条，通过滚动条查看完整内容\nauto：根据需要生成滚动条\n\n\noverflow-x：单独处理水平\noverflow-y：单独处理垂直\n\n\n以上所有内容以块元素为例(div)\n\n行内元素的盒模型\n行内元素不支持设置宽度和高度，内容区大小由内容直接决定\n行内元素可以设置padding，但是垂直方向padding不会影响页面的布局\n行内元素可以设置border，但是垂直方向border不会影响页面的布局\n行内元素可以设置margin，但是垂直方向margin不会影响页面的布局\n\ndisplay（块元素和行内元素相互转换）\n设置元素显示的类型（块元素和行内元素相互转换）\n可选值：\ninline：设置为行内元素\nblock：设置为块元素\ninline-block：设置为行内块元素（开发时不常用）\n既可以设置宽度和高度，又不会独占一行\n\n\ntable：设置为一个表格\nnone：不显示（隐藏），不占据页面位置\n\n\n应用：下拉框none—&gt;block\n\nvisibility\n设置元素显示的状态\n可选值：\nvisible：默认值，元素正常显示\nhidden：不显示（隐形），但是依然占据页面的位置\n\n\n\n轮廓（outline）\n与border区分\n\n不同点：轮廓不会影响到可见框的大小，不影响页面布局\n\n\noutline多应用于鼠标悬停时：\n.box1:hover&#123;    outline:10px red solid;&#125;\n\n阴影（box-shadow)\n不影响页面布局\n\n语法：box-shadow：水平偏移量 垂直偏移量 模糊半径颜色\n\n水平偏移量：设置阴影水平位置，正值向右移动，负值相反\n垂直偏移量：设置阴影垂直位置，正值向下移动，负值相反\n模糊半径：越大越模糊\n颜色：rgba(0，0，0，.3)\n\n\n示例：\n.box1&#123;    box-shadow:10px 10px 50px rgba(0,0,0,.3)&#125;\n\n浏览器的默认样式\n浏览器会为元素设置默认样式，开发时需要去除默认样式（pc端）\n\n去除默认样式bady&#123;    magin:0;&#125;p&#123;    magin:0;&#125;ul&#123;    magin:0;    padding:0;    list-style:none;/*去除项目符号*/&#125;/*通常情况下简单写法*/*&#123;    margin:0;    padding:0;&#125;ul&#123;    list-style:none;/*去除项目符号*/&#125;\n\n最完美的写法，通过引入重置样式表\n\nreset.css：直接去除浏览器的默认样式\nnormalize.css：对默认样式进行了统一\n\n","categories":["CSS"],"tags":["CSS","盒子模型","块元素","行内元素"]},{"title":"CSS提升（一）：浮动","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B5%AE%E5%8A%A8/","content":"浮动的简介\n通过浮动可以使一个元素向其父元素的左侧或右侧移动，使用float属性设置元素的浮动\n五三理解：相当于ps中新建一个图层\n\n\n可选值：\nnone：默认值，元素不动\nleft：元素向左浮动\nright：元素向右浮动\n\n\n注意：\n设置浮动以后，水平布局的等式不需要强制成立（例如：设置float:left，右外边距为0）\n元素会完全从文档流中脱离，不占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动\n\n\n特点：\n浮动元素会完全脱离文档流，不再占据文档流中的位置\n设置浮动后元素会向父元素的左侧或右侧移动\n浮动元素默认不会从父元素中移除\n浮动元素不会超过它前面的其它浮动元素\n如果浮动元素的上面时一个没有浮动的块元素，则浮动元素无法上移\n\n\n作用：让页面中的元素可以水平排列，制作水平布局\n\n浮动的特点\n浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，可利用浮动来设置文字环绕图片的效果\n\n浮动后，从文档流中脱离，元素的特点也会发生变化\n\n\n脱离文档流后的特点块元素\n不再独占页面的一行\n宽度和高度被内容撑开（默认情况）\n\n行内元素\n变成块元素，特点和块元素一样\n\n\n脱离文档流以后，不需要再区分块元素和行内元素\n\n","categories":["CSS"],"tags":["CSS","float"]},{"title":"CSS基础（四）：单位","url":"/2022/03/01/CSS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BD%8D/","content":"长度单位\n像素 （px）\n不同屏幕的像素大小不同，像素越小的屏幕显示效果越清晰\n同样的200px在不同的设备下显示效果不一样\n\n\n百分比 （%）\n将其属性值设置为相对于其父元素属性的百分比\n设置百分比可以使子元素跟随父元素的改变而改变\n\n\nem\nem是相对于元素（自身）的字体大小来计算\n\n1em &#x3D; 1 font-size\n1 font-size &#x3D; 16px（默认）\n\nem会根据字体大小的改变而改变\n\n示例：\n/*盒子大小为160px*/.box1&#123;    font-size:16px;    width:10em;    height:10em;   \tbackground-color:greenyellow;&#125;/*盒子大小为200px*/.box2&#123;    font-size:20px;    width:10em;    height:10em;   \tbackground-color:greenyellow;&#125;\n\n\nrem\nrem是相对于根元素（html）的字体大小来计算\n\n在移动端用得挺多\n\n示例：\nhtml&#123;    font-size:30px;&#125;/*盒子大小为300px*/.box1&#123;    width:10rem;    height:10rem;   \tbackground-color:greenyellow;&#125;\n\n\nvw\n表示视口宽度（viewport width)\n\n100vw &#x3D; 一个视口的宽度、1vw &#x3D; 1%视口宽度\n\n与百分比不同：vw总是参考于视口宽度\n\n设计图的宽度：\n二倍图：750px，三倍图：1125px\n\n\n结合vm和rem来表示长度\n@total-width:750;html&#123;    //设置rem的比值，*40是因为浏览器不支持比12px小的字体    font-size:100vw/@total-width * 40;&#125;.box1&#123;    width:(175/40)rem;&#125;\n\n\n\n颜色单位\n颜色名\n比如：red、orange、yellow、blue、green……\n\n\nRGB\n语法：rgb(红，绿，蓝) \n\n取值范围：0~255\n\n特殊值：rgb（0，0，0）黑色\n​                rgb（255，255，255）白色\n\n\n\nRGBA\n语法：rgb(红，绿，蓝，透明度)\n\n特殊值：rgb（176,199,167，1）完全不透明\n​                rgb（176,199,167，0）完全透明\n​                rgb（176,199,167，.5）半透明\n\n\n\n十六进制的RGB\n语法：#红绿蓝 \n\n取值范围：00~ff  \n\n特殊值：#ff0000 红色\n​                #00000 白色\n\n如果颜色两位两位重复可以简写：\n#aabbcc –&gt; #abc\n#aabbcd 不能简写\n\n\n\nHSL、HSLA\nH 色相：0~360\nS 饱和度：0%~100% （0%灰）\nL 亮度：0%~100%（0%黑，50%正，100%白）\nA 透明度\n\n\n\n","categories":["CSS"],"tags":["CSS","单位","移动端"]},{"title":"CSS提升（七）：响应式布局","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","content":"\n响应式布局：网页可根据不同的设备或窗口大小呈现出不同的效果\n关键：媒体查询\n​    通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式\n\n媒体查询语法：@media 查询规则{}\n媒体类型\nall 所有设备\n\nprint 打印设备\n\nscreen 带屏幕的设备\n\nspeech 屏幕阅读器\n可以使用，连接多个媒体类型，或的关系\n可以再媒体类型前添加一个only，表示只有（为了兼容一些老版本的浏览器）\n@media all&#123;    body&#123;        background-color:#bfa;    &#125;&#125;@media print,screen&#123;    body&#123;        background-color:#bfa;    &#125;&#125;@media only screen&#123;    body&#123;        background-color:#bfa;    &#125;&#125;\n\n媒体特性\nwidth 视口的宽度\nheight 视口的高度 (一般不考虑)\nmin-width 视口最小宽度 (视口大于指定宽度时生效)\nmax-width 视口最大宽度 (视口小于指定宽度时生效)\n\n/*视口等于500px时生效*/@media (width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px时生效*/@media (min-width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口小于500px时生效*/@media (max-width:500px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px或小于700px时生效*/@media (min-width:500px),(max-width:700px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;/*视口大于500px且小于700px时生效*/@media only screen (min-width:500px)and(max-width:700px)&#123;    body&#123;        background-color:#bfa;    &#125;&#125;\n\n样式切换的分界点，称为断点（布局大变化）\n\n常用断点：\n\n小于768 超小屏幕 max-width&#x3D;768px\n大于768 小屏幕 min-width&#x3D;768px\n大于992 中型屏幕 min-width&#x3D;992px\n大于1200 大屏幕 min-width&#x3D;1200px\n\n@media only screen&#123;    @media (min-width:768px)&#123;        .box1&#123;                    &#125;    &#125;&#125; \n\n","categories":["CSS"],"tags":["CSS","响应式布局","布局"]},{"title":"CSS提升（三）：定位相关知识","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AE%9A%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"\n定位：一种更加高级的布局手段\n通过定位可以将元素摆放到页面的任意位置\nposition属性\n\n\n可选值：\nstatic 默认值，元素是静止的没有开启定位\nralative 相对定位\nabsolute 绝对定位\nfixed 固定定位\nsticky 粘滞定位\n\n\n\n\n注：实际开发中，定位并不会大面积使用，整体上不用定位，定位通常用在细节上的微调\n\nrelative、absolute、fixed这三个属性值有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。\n这三种定位都不会对其他元素的位置产生影响，因此元素之间可能产生重叠。\n相对定位\nposition：relative\nrelative表示，相对于默认位置（即static时的位置）进行偏移，即定位基点是元素的默认位置。\n\n特点\n相对定位 若不设置偏移量，元素不发生任何变化\n\n\n偏移量：开启定位后，偏移量可以用来设置元素位置（与margin不同：不会影响别的元素）\n​    top、bottom：垂直方向定位（使用其一）\n​    left、right：水平方向定位（使用其一）\n*注：以上值要生效必须开启定位，若没开启定位，设置偏移量无效。\n\n\n相对定位 元素是参照于元素在文档流中的位置进行定位\n相对定位 会提高元素的层级\n相对定位 不会使元素脱离文档流\n相对定位 不会改变元素的性质（块还是块，行内还是行内）\n\n\n形象理解：灵魂出窍，元素肉体（偏移前）还占据页面位置，元素灵魂（偏移后）挪动了\n\n\n它必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。\n\n\ndiv &#123;  position: relative;  top: 20px;&#125;\n\n上面代码中，div元素从默认位置向下偏移20px（即距离顶部20px）。\n绝对定位\nposition：absolute\nabsolute表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。\n它有一个重要的限制条件：定位基点（一般是父元素）不能是static定位，否则定位基点就会变成整个网页的根元素html。另外，absolute定位也必须搭配top、bottom、left、right这四个属性一起使用。\n\n特点\n绝对定位 若不设置偏移量，元素的位置不发生任何变化\n\n绝对定位 元素是相对于其包含块进行定位\n\n\n\n包含块（containing block）：\n​    正常情况下：包含块是离当前元素最近的祖先块元素\n​    绝对定位下：包含块是离当前元素最近的开启了定位的祖先元素；若所有祖先均未开启定位，则包含块是根元素。\n\n\n绝对定位 会提高元素的层级\n绝对定位 会使元素脱离文档流（不占据页面位置）\n绝对定位 会改变元素的性质（行内变成块，块的宽高被内容撑开）\n\n\n\n*  HTML 代码如下  &lt;div id=&quot;father&quot;&gt;    &lt;div id=&quot;son&quot;&gt;&lt;/div&gt;  &lt;/div&gt;*/#father &#123;  positon: relative;&#125;#son &#123;  position: absolute;  top: 20px;&#125;\n\n上面代码中，父元素是relative定位，子元素是absolute定位，所以子元素的定位基点是父元素，相对于父元素的顶部向下偏移20px。如果父元素是static定位，上例的子元素就是距离网页的顶部向下偏移20px。\n注意，absolute定位的元素会被”正常页面流”忽略，即在”正常页面流”中，该元素所占空间为零，周边元素不受影响。\n绝对定位元素布局水平方向布局当开启绝对定位后，水平方向的布局等式需要添加left和right\n\nleft + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right&#x3D; 其包含块内容区的宽度\n\n\n如果9个值中没有auto则自动调整right值使等式两端满足\n\n如果有auto则自动调整auto的值\n可以调整auto的值：margin width left right\n\nleft、right默认值为auto，默认自动调整这两个值\n所以绝对定位下，需要设置居中时：\nmargin-left:auto;margin-right:auto;left：0；right：0；\n\n垂直方向布局当开启绝对定位后，垂直方向的布局等式也需要满足\n\ntop + margin-top+ border-top+ padding-top+ width + padding-bottom+ border-bottom+ margin-bottom+ bottom&#x3D; 其包含块内容区的高度\n\n【面试】实现绝对定位元素在包含块中水平、垂直都居中：\nmargin：auto;left：0；right：0；top:0;bottom:0;/*注意包含块要开启定位*/\n\n\n子元素在父元素中的定位：父元素相对，子元素绝对\n\n父元素相对：是为了在不脱离文档流的情况下开启定位（保证父元素周围的元素布局不混乱）\n子元素绝对：和其它子元素一起脱离文档流，避免互相影响\n\neg. 轮播图（父元素）中的原点（子元素）\n固定定位\nposition：fixed\nfixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。\n\n特点\n固定定位 是特殊的绝对定位，大部分特点和绝对定位相同\n\n唯一与绝对定位不同的地方：\n\n固定定位 元素是参考于浏览器的视口进行定位（不会随网页的滚动条移动，eg广告）\n\n\n它如果搭配top、bottom、left、right这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。\n\ndiv &#123;  position: fixed;  top: 0;&#125;\n\n上面代码中，div元素始终在视口顶部，不随网页滚动而变化。\n\n\n粘滞定位\nposition：sticky \nsticky跟前面四个属性值都不一样，它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）。\n\n因此，它能够形成”动态固定”的效果。比如，网页的搜索工具栏，初始加载时在自己的默认位置（relative定位）。\n\n页面向下滚动时，工具栏变成固定位置，始终停留在页面头部（fixed定位）。\n\n等到页面重新向上滚动回到原位，工具栏也会回到默认位置。\nsticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位，不产生”动态固定”的效果。原因是这四个属性用来定义”偏移距离”，浏览器把它当作sticky的生效门槛。\n它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。\n请看下面的示例代码。（注意，除了已被淘汰的 IE 以外，其他浏览器目前都支持sticky。但是，Safari 浏览器需要加上浏览器前缀-webkit-。）\n\n#toolbar &#123;  position: -webkit-sticky; /* safari 浏览器 */  position: sticky; /* 其他浏览器 */  top: 20px;&#125;\n\n上面代码中，页面向下滚动时，#toolbar的父元素开始脱离视口，一旦视口的顶部与#toolbar的距离小于20px（门槛值），#toolbar就自动变为fixed定位，保持与视口顶部20px的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），#toolbar恢复成relative定位。\n特点\n粘滞定位 兼容性不太好（一般不采用，通常使用js来实现）\n粘滞定位 和相对定位特点基本一致\n与相对定位不同的地方：\n粘滞定位 可以在元素到达某个位置时将其固定（eg，导航栏）\n\n\n\n元素的层级\n对于开启了定位的元素，可以通过z-index属性来指定元素的层级\n\n\n语法：z-index：整数\n值越大元素的层级越高，越优先显示\n\n若元素层级一样，则优先显示html中结构靠下的元素\n\n祖先元素的层级再高也不会盖住后代元素\n\n\n","categories":["CSS"],"tags":["CSS","定位","元素层级"]},{"title":"CSS提升（五）:less","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Aless/","content":"less简介\nless是一门css的预处理语言\nless是css的增强版，可通过它编写更少的代码实现更强大的样式\nless语法大体上和css语法一致，但增添了许多对css的扩展\n浏览器无法直接执行，需通过编译把less转化成css\n\ncss原生变量、函数html&#123;    --color：#bfa;    --length:200px;&#125;.box1&#123;    width:var(--length);    height:var(--length);    backgound-color:var(--color);&#125;.box2&#123;    width:calc(200px*2);    height:var(--length);    backgound-color:var(--color);&#125;\n\n缺点：\n浏览器兼容性不好\n\nless的语法//less的注释不会解析到css中/*css的注释会解析到css中*/.box1&#123;    background-color:#bfa;    .box2&#123;        background-color:#ff0;        .box4&#123;            background-color:red;        &#125;    &#125;    .box2&#123;        background-color:#orange;    &#125;&#125;\n\n编译成css：\n/*css的注释会解析到css中*/.box1&#123;    background-color:#bfa;&#125;.box1 .box2&#123;    background-color:#ff0;&#125;.box1 .box3&#123;    background-color:#orange;&#125;.box1 .box2 .box3&#123;    background-color:red;&#125;\n\nless的变量\n变量的语法：@变量名\n\n示例：\n@a:100px;@b:#bfa;@c:box6.box5&#123;    //直接使用则以 @变量名 形式使用    width:@a;    color:@b;&#125;    //作为类名，或者一部分值使用时以 @&#123;变量名&#125; 形式使用.@&#123;c&#125;&#123;    backgound-imag：url(&quot;@&#123;c&#125;/1.png&quot;)&#125;.box2&#123;    color: red;    background-color:$color;&#125;\n\nless中父元素和扩展父元素.box1&#123;    .box2&#123;        color:red;    &#125;    //子元素选择器    &gt;.box3&#123;       color:red;    &#125;    //为box1设置hover    //&amp; 表示外围父元素    &amp;:hover&#123;        color:orange;    &#125;&#125;\n\n编译成css：\n.box1 .box2&#123;    color:red;&#125;.box1&gt;.box3&#123;    color:red;&#125;.box1:hover&#123;    color:orange;&#125;\n\n扩展extend、mixin.p1&#123;    width:10px;    height:20px;&#125;.p2:extend(.p1)&#123;    color:red;&#125;\n\n编译成css：\n.p1&#123;    width:10px;    height:20px;&#125;.p2&#123;    width:10px;    height:20px;    color:red;&#125;.p3&#123;    width:10px;    height:20px;&#125;\n\nless中的混合函数.p1&#123;    width:10px;    height:20px;&#125;//mixin 混合.p3&#123;    .p1();&#125; //css中不会显示p4，相当于建立一个模板.p4()&#123;    width:100px;    height:100px;   \tbackground-color:#bfa;&#125;.p5&#123;    .p4(); //括号也可不写 &#125;\n\n编译成css：\n.p1&#123;    width:10px;    height:20px;&#125;.p3&#123;    width:10px;    height:20px;&#125;.p5&#123;    width:100px;    height:100px;   \tbackground-color:#bfa;&#125;\n\n实际用法：在混合函数中可以设置变量\n.test(@w,@h,@bg-color)&#123;    width:@w;    height:@h;    border:1px solid @bg-color;&#125;div&#123;    //调用混合函数，按顺序传递参数    .test(200px,300px,#bfa);    //不按顺序，但需指明关键字    .test(@bg-color:#bfa,@h:300px,@w:200px);&#125;\n\n编译成css：\ndiv&#123;    width:200px;    height:300px;    border:1px solid #bfa;&#125;\n\nless中的引入//将其它的less引入当前的less@import &quot;syntax2.less&quot;\n\n","categories":["CSS"],"tags":["CSS","less","变量"]},{"title":"CSS提升（二）：高度塌陷问题","url":"/2022/03/02/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98/","content":"\n现象：在浮动布局中，父元素的高度默认被子元素撑开，当子元素浮动后，其从文档流中脱离，将无法撑起父元素的高度，导致父元素的高度丢失，父元素下的元素会自动上移，导致页面布局混乱。\n\n\n解决方法将父元素高度写死\n缺点：容易导致内容溢出，或内容空洞\n\nBFC ( Block Formatting Context ) 块级格式化环境\nBFC是CSS中一个隐含的属性\n为元素开启BFC：元素变成独立的布局区域\n带你用最简单的方式理解最全面的BFC_哔哩哔哩_bilibili\n\n\n开启BFC的元素特点（解决的问题）：\n\n当前元素不会被浮动元素所覆盖（清除浮动问题）\n父元素开启BFC外边距不会和子元素重叠（解决外边距重叠问题：包括兄弟之间、父子之间）\n父元素开启BFC可以包含浮动的子元素（解决高度塌陷问题）\n\n\n开启BFC方式：（均为间接开启，都有些副作用）\n\n设置浮动\nfloat:left （宽度丢失）\n\n将元素设置为行内块元素\ndisplay:inline-block (宽度丢失)\n\n将overflow设置为非visible的值 (最常用)\n\noverflow：scroll\noverflow: auto\noverflow: hidden（最常用）\n\n\n\n\n\nclear (完美方式)\n不希望某个元素因为其它元素浮动的影响而改变位置，可以通过clear属性来清楚浮动元素对当前元素所产生的影响\n\n\n作用：清除浮动元素对当前元素所产生的影响\n\n可选值：\n\nleft：清除左侧浮动元素对当前元素的影响\nright：清除右侧浮动元素对当前元素的影响\nboth：清楚两侧中最大影响的那一侧\n\n\n原理：设置clear以后，浏览器会自动为元素添加一个上外边距，使其位置不受其他元素影响\n\n示例：\n&lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;\n\n.box1&#123;    width:200px;    height:200px;    background-color:#bfa;    /*左浮动*/    float:left;&#125;.box2&#123;    width:200px;    height:200px;    background-color: yellow;    /*右浮动*/    float:right;&#125;.box3&#123;    width:200px;    height:200px;    background-color: orange;    /*消除浮动影响*/    clear：both;&#125;\n\n效果：\n\n\n\n使用after伪类解决高度塌陷问题（clear解决）\n参考教程：【尚硅谷】Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通_哔哩哔哩_bilibili\n\n示例：\n\n\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    border 10px red solid;&#125;.box2&#123;    width:100px;    height:200px;    background-color: #bfa;    /*开启了浮动，导致父元素高度塌陷*/    float:left;&#125;.box1::after&#123;    content:&#x27;&#x27;;    /*将伪元素（行内元素）转换为块元素*/    diaplay:block;   /*或者用display:table*/    /*消除浮动影响*/    clear：both;&#125;\n\n\n效果：\n消除前：\n\n\n\n\n\n消除后：\n\n\n.clearfix(同时解决高度塌陷和外边距重叠问题).clearfix::before,.clearfix::after&#123;    /*前两行解决外边距重叠*/    content:&#x27;&#x27;;    /*将伪元素（行内元素）转换为块元素*/    display:table;    /*消除浮动影响*/    clear：both;    /*后两行解决高度塌陷*/&#125;\n\n","categories":["CSS"],"tags":["CSS","高度塌陷","BFC","clear"]},{"title":"CSS提升（四）：动画","url":"/2022/03/06/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8A%A8%E7%94%BB/","content":"过渡\ntransition-property：指定要执行过渡的属性\n\n例：transition-property：width\n\n多个属性间使用，隔开\n\n如果所有属性都需要过渡，则使用all关键字\n\n大部分属性都支持过渡效果（只要是数值可以计算，px，角度，颜色）\n\n必须从一个有效数值向另一个有效数值进行过渡，auto无效\n\n\n\ntransition-duration：指定过渡效果持续时间\n\n例：transition-duration：2s，1000ms\n时间单位：s 和 ms，1s&#x3D;1000ms\n不同属性的过渡时间之间用，隔开\n\n\ntransition-timing-fuction：过渡的时序函数\n\n可选值：\n\nease 默认值，慢速开始，先加速，再减速\n\nlinear 匀速运动\n\nease-in 加速运动\n\nease-out 减速运动\n\nease-in-out 先加速 后减速\n\ncubic-bezier（）时序函数（贝塞尔曲线）\nhttps://cubic-bezier.com\n\nsteps（）分步执行过渡效果\n可以设置第二个值：\nend，在时间结束时执行过渡（默认值）\nstart，在时间开始时执行过渡\n\n\n\n\n\ntransition-delay：过渡效果的延迟（等待一段时间后在执行过渡）\n例：transition-delay：2s\n\ntransition 简写属性\n如果要写延迟，则两个时间中第一个是持续时间。\n.box1&#123;    height:0;    /*当高度属性值发生变化时，会花0.3s完成效果*/    transtition:height 0.3s;&#125;.box2&#123;    height:0;    /*当所有样式发生变化时，会花0.3s完成效果*/    transtition:all 0.3s;&#125;\n\n动画\n动画和过渡类似，都可实现动态效果\n​    不同的是过渡需要在某个属性发生变化时才会触发（需要交互）\n​    动画可以自动触发动态效果\n设置动画效果，必须要先设置一个关键帧，关键帧设置了动画执行的每个步骤\n\n\n示例：\n@keyframes test&#123;    /*from表示动画开始位置 也可以使用0%*/    from&#123;        margin-left:0;    &#125;    /*to表示动画结束位置 也可以使用100%*/    to&#123;        margin-left:700px;    &#125;&#125;.box2&#123;    /*对当前元素生效的关键帧的名字*/    animation-name:test;    animation-duration:2s;    animation-delay：2s;        /*动画执行次数      可选值：        次数，        infinite 无限执行  */    animation-iteration-count:20;    /*动画运行方向      可选值：        normal 默认值 从from到to    \treverse 从to到from    \talternate 从from到to 重复执行动画时反向执行    \talternate-reverse 从to到from 重复执行动画时反向执行*/    animation-direction：alternate-reverse;     /*动画执行状态      可选值：        running 默认值 执行    \tpaused 暂停 */    animation-play-state：paused;    /*动画填充模式      可选值：        none 默认值 执行完毕元素回到原来的位置    \tforwards 执行完毕元素停在结束位置     \tbackwards 动画延时等待时，元素就会处于开始位置    \tboth 结构了forwards和backwards*/    animation-fill-mode：alternate-reverse;&#125;\n\nanimation简写属性\n如果要写延迟，则两个时间中第一个是持续时间。\n\n\n变形\n改变元素的形状或位置\n​    不会影响到页面的布局（类似相对定位）\n\n\ntransform 设置元素的变形效果\n\n可选值（函数）：\n\n平移：\ntranslateX() 沿着x轴方向平移 translateX(100px) \ntranslateY() 沿着y轴方向平移 translateX(50%)\ntranslateZ() 沿着z轴方向平移\n​    默认情况下，网页不支持透视\n​    若要看见z轴平移效果，需设置网页的视距html{perspective：800px；}\n百分比是相对于元素自身计算的\n\n旋转：旋转会改变xyz轴的方向\nrotateX() 沿x轴旋转\n​    若要看见x、y轴旋转效果，需设置网页的视距html{perspective：800px；}\nrotateY() 沿y轴旋转\nrotateZ() 沿z轴旋转 rotateZ(45deg)\n\n平移+旋转：\n.box1&#123;    transform:rotateY(180deg) translate(400px);&#125;\n\n缩放：\nscaleX() 水平方向缩放\nscaleY() 垂直方向缩放\nscale() 两个方向都缩放\nscaleZ() 沿z轴缩放（立体的才有效果）\n\n\n\n\n\ntransform-style：preserve-3d；设置3D变形效果\n\ntransform-orgin 设置变形的原点\n\ncenter 默认值\n数值px 数值px\n\n\n\n","categories":["CSS"],"tags":["CSS","动画","过渡","变形"]},{"title":"CSS提升（六）：弹性盒flex","url":"/2022/03/07/CSS%E6%8F%90%E5%8D%87%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%BC%B9%E6%80%A7%E7%9B%92flex/","content":"\nflex(弹性盒、伸缩盒)\n是css中又一种布局手段，它主要用来代替浮动过来完成页面的布局\nflex可以使元素具有弹性，让元素可以跟随页面大小的改变而改变\n\n弹性容器\n要使用弹性盒，必须将一个元素设置为弹性容器\n\n\ndisplay：flex 设置为块级弹性容器（大多情况用这个）\ndisplay：inline-flex 设置为行内弹性容器\n\nflex-direction 指定容器中弹性元素的配列方式\n\n主轴：弹性元素的排列方向\n侧（辅）轴：与主轴垂直方向的轴\n\n可选值：\n\nrow 默认值 水平排列（左向右）\n主轴：自左向右\n\nrow-reverse 水平排列（右向左）\n主轴：自右向左\n\ncolumn 纵向排列（上向下）\n\ncolumn-reverse 纵向排列（下向上）\n\n\n\n\n\nflex-wrap 设置弹性元素是否在弹性容器中自动换行\n\n可选值\nnawrap 默认值，不会自动换行\nwrap 元素沿着辅轴方向自动换行\nwrap-reverse 元素沿着辅轴反方向换行\n\n\n\n\nflex-flow   wrap和direction的简写属性\nflex-flow：row wrap\n\njustify-content 分配主轴上的空白空间\n\n可选值：\nflex-start 元素沿着主轴起边排列\nflex-end 元素沿着主轴终边排列\ncenter 元素居中排列\nspace-around 空白分布到元素两侧\nspace-between空白分布到元素之间\nspace-evenly 空白分布到元素的单侧（兼容性不高）\n\n\n\n\nalgin-items 元素在辅轴上如何对齐\n\n可选值：\nstretch 默认值 将元素的长度设置为相同的值（同一行的高度相同）\nflex-start 元素不会拉伸，沿着辅轴起边对齐\nflex-end 元素不会拉伸，沿着辅轴终边对齐\ncenter 元素不会拉伸，居中对齐\nbaseline 基线对齐（文本基线）\n\n\n用于弹性元素：align-self 用来覆盖当前弹性元素上的align-items\n\n\nalign-content 分配辅轴上的空白空间\n\n可选值同justify-content\n\n弹性元素\n\n\n弹性容器的子元素是弹性元素（弹性项），必须是直接子元素，后代不算\n一个元素可以同时是弹性容器和弹性元素\n\n\nflex-grow 指定弹性元素的伸展系数（当父元素有多余空间时，子元素如何伸展）\n\n父元素的剩余空间，会按照弹性元素的伸展比例进行分配\n默认值为0（不伸展）\n\n\nflex-shrink 指定弹性元素的收缩系数（当父元素空间不足时，子元素如何收缩）\n\n默认值为1 (等比例收缩)\n值为0 （不收缩，溢出）\n缩减多少是根据 缩减系数 和 元素大小来计算\n\n\n\nflex-basis 元素基础长度（相当于弹簧静止时的长度）\n\n如果主轴是横向，则该值指定元素的宽度\n如果主轴是纵向，则该值指定元素的高度\n\n可选值：\n\nauto，参考元素自身的高度或宽度\n具体数值\n\n\n\n\nflex 简写属性\n\n顺序：增长系数 缩减系数 基础长度；\n可选值：\ninitial：相当于flex：0 1 auto （默认值，不可伸展可收缩）\nauto：相当于flex：1 1 auto （可伸展可收缩）\nnone：相当于flex：0 0 auto （弹性元素没有弹性）\n取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%\n取值为 0 时，对应的三个值分别为 0 1 0%\n取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1\n取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%\n取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1\n\n\n\n\norder 弹性元素排列顺序\n\n数值越大排越后面\n\n\n\n","categories":["CSS"],"tags":["CSS","布局","弹性盒"]},{"title":"ES6（一）：概述","url":"/2022/04/27/ES6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E8%BF%B0/","content":"一、概述1、什么是 ECMAECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个 组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际；\n2、什么是 ECMAScriptECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言； 百度百科：https://baike.baidu.com/history/ECMAScript/1889420/144946978\n3、什么是 ECMA-262 Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看： http://www.ecma-international.org/publications/standards/Standard.htm \n4、ECMA-262 历史 ECMA-262（ECMAScript）历史版本查看网址： http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm\n\n5、谁在维护 ECMA-262\n TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏 览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家 出席； \n6、为什么要学习 ES6\n\nES6 的版本变动内容最多，具有里程碑意义；\nES6 加入许多新的语法特性，编程实现更简单、高效； \nES6 是前端发展趋势，就业必备技能；\n\n7、ES6 兼容性\n 查看网址：http://kangax.github.io/compat-table/es6\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6（七）：ES11新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AES11%E6%96%B0%E7%89%B9%E6%80%A7/","content":"私有属性&lt;script&gt;    class Person &#123;        //公有属性        name;        //私有属性        #age;        #weight;        //构造方法        constructor(name, age, weight) &#123;            this.name = name;            this.#age = age;            this.#weight = weight;        &#125;        intro()&#123;            console.log(this.name);            console.log(this.#age);            console.log(this.#weight);        &#125;    &#125;    //实例化    const girl = new Person(&#x27;陈&#x27;, 18, &#x27;45kg&#x27;);    console.log(girl.#age) //error    console.log(girl); //Person&#123;name: &quot;陈&quot;, #age: 18, #weight: &quot;45kg&quot;&#125;    girl.intro(); // 陈 18  45kg&lt;/script&gt;\n\nPromise.allSettled&lt;script&gt;    //声明两个promise对象    const p1 = new Promise((resolve, reject) =&gt; &#123;        setTimeout(()=&gt;&#123;            resolve(&#x27;商品数据-1&#x27;)        &#125;,1000)    &#125;)    const p2 = new Promise((resolve, reject) =&gt; &#123;        setTimeout(()=&gt;&#123;            reject(&#x27;出错了！&#x27;)        &#125;,1000)    &#125;)    //调用allsettled方法:返回的结果始终是一个成功的，并且异步任务的结果和状态都存在    const res = Promise.allSettled([p1,p2]);    console.log(res)    // Promise &#123;&lt;pending&gt;&#125;    //     __proto__: Promise    //     [[PromiseState]]: &quot;fulfilled&quot;    //     [[PromiseResult]]: Array(2)    //调用all方法：返回的结果是按照p1、p2的状态来的，如果都成功，则成功，如果一个失败，则失败，失败的结果是失败的Promise的结果    const result = Promise.all([p1,p2])    console.log(result)&lt;/script&gt;\n\n\n应用场景：批量异步任务\n\nString.prototype.matchAlllet str = `&lt;ul&gt;            &lt;li&gt;                &lt;a&gt;肖生克的救赎&lt;/a&gt;                &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a&gt;阿甘正传&lt;/a&gt;                &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;            &lt;/li&gt;        &lt;/ul&gt;`;//声明正则const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/sg//调用方法const result = str.matchAll(reg);// for(let v of result)&#123;//     console.log(v);// &#125;const arr = [...result];console.log(arr);\n\n可选链操作符//相当于一个判断符，如果前面的有，就进入下一层级function main(config)&#123;    //传统方法(如果config没传就会报错)    //const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host    const dbHost = config?.db?.host    console.log(dbHost) //192.168.1.100&#125;main(&#123;    db:&#123;        host:&#x27;192.168.1.100&#x27;,        username:&#x27;root&#x27;    &#125;,    cache：&#123;    \thost:&#x27;192.168.1.200&#x27;,    \tusername:&#x27;admin&#x27;\t&#125;&#125;)\n\n动态import\n按需加载，提高效率\n\n\n静态import\nimport * as m1 from &quot;./hello.js&quot;;//获取元素const btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = function()&#123;    m1.hello()&#125;\n\n动态import\nbtn.onclick = function()&#123;    //使用之前并未引入，动态引入，返回的其实是一个Promise对象    import(&#x27;./hello.js&#x27;).then(module=&gt;&#123;        module.hello();    &#125;)&#125;\n\nBigInt//大整型let n = 521n;console.log(n,typeof(n))  // 521n  n //函数let n = 123;console.log(BigInt(n)) // 123n  //不要使用浮点型，只能用int//大数值运算let max = Number.MAX_SAFE_INTEGER; // 9007199254740991console.log(max +1) // 9007199254740992console.log(max +2) // 9007199254740992 出问题了console.log(BigInt(max)+BigInt(1)) //9007199254740992nconsole.log(BigInt(max)+BigInt(2)) //9007199254740993n\n\n绝对全局对象globalThis\n无论执行环境是什么，浏览器、nodejs或其它，globalThis始终指向全局对象\n\nconsole.log(globalThis) //浏览器：window   //适用于复杂环境下直接操作window//nodejs：Object[global] \n\n","categories":["ES6"],"tags":["ES11"]},{"title":"ES6（三）：ES7新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AES7%E6%96%B0%E7%89%B9%E6%80%A7/","content":"Array.prototype.includes\n用来检测数组中是否包含某个元素，返回布尔类型值\n\n&lt;script&gt;    //include  与 indexOf区别   const mingzhu = [&#x27;西游记&#x27;,&#x27;红楼梦&#x27;,&#x27;水浒传&#x27;,&#x27;三国演义&#x27;]   console.log(mingzhu.includes(&#x27;西游记&#x27;))  //true   console.log(mingzhu.includes(&#x27;金瓶梅&#x27;))  //false&lt;/script&gt;\n\n\n\n指数操作符\n在ES7中引入指数操作符**，用来实现幂运算，功能与Math.pow结果相同\n\n//**console.log(2**10) // 1024\n\n","categories":["ES6"],"tags":["ES7"]},{"title":"ES6（二）：ES6新特性","url":"/2022/04/27/ES6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AES6%E6%96%B0%E7%89%B9%E6%80%A7/","content":"功能概述1、let 关键字 \n声明局部变量；\n2、const 关键字 \n声明常量； \n3、变量和对象的解构赋值\n 简化变量声明：从； \n4、模板字符串 \n声明自带格式的字符串； \n5、简化对象和函数写法 \n简化对象和函数写法；\n 6、箭头函数 \n简化函数写法； \n7、ES6中函数参数的默认值 \n给函数的参数设置默认值； \n8、rest参数 \n拿到实参； \n9、扩展运算符 \n将一个数组转为用逗号分隔的参数序列； \n10、Symbol \n表示独一无二的值； \n11、迭代器 \n用来遍历集合、数组等； \n12、生成器 \n是一种异步编程解决方案； \n13、Promise \n非常强大的异步编程的新解决方案； \n14、Set集合 \n类似数组，但元素不重复的集合； \n15、Map集合 \n键值对集合； \n16、class类 \n像java实体类一样声明js类； \n17、数值扩展 \n增加一些数值相关的方法等； \n18、对象扩展 \n增加一些对象相关的方法等； \n19、模块化 \n模块化、组件化； \n20、Babel对ES6模块化代码转换 \n为了适配浏览器，将更新的ES规范转换成ES5规范； \n21、ES6模块化引入NPM包 \n像导入模块一样导入npm包；\nlet和const命令let特性\n变量不能重复声明\nlet star=&#x27;罗志祥&#x27;;let star=&#x27;小猪&#x27;  //error\n\nlet有块级作用域\n&#123;    let girl=&#x27;周扬青&#x27;&#125;console.log(girl) //error\n\n不仅仅针对花括号，例如if（）、for（）里面\n\n不存在变量提前\nconsole.log(song)   //errorlet song=&#x27;恋爱达人&#x27;\n\n不影响作用域链\nlet school=&#x27;abc&#x27;function fn()&#123;    console.log(school) //abc&#125;\n\n案例&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot; style=&quot;width: 50px;height: 50px;background-color: red&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        let items=document.getElementsByClassName(&quot;item&quot;);        for (var i=0;i&lt;items.length;i++)&#123;            items[i].onclick=function ()&#123;                // 修改当前元素的背景颜色                // this.style.background = &#x27;pink&#x27;; // 写法一：常规写法一般无异常                items[i].style.background = &#x27;pink&#x27;; // 写法二                // 写法二：需要注意的是for循环内的i必须使用let声明                // 如果使用var就会报错，因为var是全局变量，                // 点击事件触发时调用函数，此时经过循环之后i的值会变成3，items[i]就会下标越界                // let是局部变量                // 我们要明白的是当我们点击的时候，这个i是哪个值                // 使用var相当于是：                // &#123; var i = 0; &#125;                // &#123; var i = 1; &#125;                // &#123; var i = 2; &#125;                // &#123; var i = 3; &#125;                // 下面的声明会将上面的覆盖掉，所以点击事件每次找到的都是3                // 而使用let相当于是：                // &#123; let i = 0; &#125;                // &#123; let i = 1; &#125;                // &#123; let i = 2; &#125;                // &#123; let i = 3; &#125;                // 由于let声明的是局部变量，每一个保持着原来的值                // 点击事件调用的时候拿到的是对应的i            &#125;        &#125;        console.log(windows.i)  //3         // 当var=3的时候，点击事件开始向外层作用域找，找不到，就是windows.i，此时是3，如果是let i，具有块级作用域，所以每一次触碰事件的i都是不同的。    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nconst特性\n声明常量\n\nconst A = &#x27;abc&#x27;\n\n\n一定要赋初始值\n\n一般常量使用大写（潜规则）\n\n常量的值不能修改\n\n也具有块级作用域\n&#123;    const pyaler = &#x27;uzi&#x27;&#125;console.log(player) //error\n\n对于数组和对象的元素修改，不算作对常量的修改\nconst team = [&#x27;uzi&#x27;,&#x27;MXLG&#x27;,&#x27;Ming&#x27;,&#x27;Letme&#x27;];team.push(&#x27;Meiko&#x27;); //不报错，常量地址没有发生变化\n\n变量的解构赋值\nES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。\n\n\n数组的解构：\nconst F4 = [&#x27;小沈阳&#x27;，&#x27;刘能&#x27;,&#x27;赵四&#x27;,&#x27;宋小宝&#x27;]let [xiao,liu,zhao,song] = F4; console.log(xiao)console.log(liu)console.log(zhao)console.log(song)\n\n对象的解构\nconst zhao = &#123;    name : &#x27;赵本山&#x27;，    age: &#x27;不详&#x27;,    xiaopin: function()&#123;        console.log(&quot;我可以演小品&quot;)    &#125;&#125;let &#123;name,age,xiaopin&#125; = zhao;console.log(name);console.log(age);console.log(xiaopin);\n\n应用场景：频繁使用对象方法、数组元素，就可以使用解构赋值形式；\n模板字符串\nES6 引入新的声明字符串的方式 &#96;&#96; 反引号\n\n特性1.声明let str = `我也是一个字符串`console.log(str,typeof str);\n\n2.内容中可以直接出现换行符let str = `&lt;ul&gt;\t\t\t&lt;li&gt;RHF&lt;/li&gt;\t\t\t&lt;li&gt;RHF&lt;/li&gt;\t\t   &lt;/ul&gt;`；\n\n3.变量拼接let lovest = &#x27;RHF&#x27;;let out = `$&#123;lovest&#125;是最帅的`;console.log(out)  //RHF是最帅的\n\n应用场景：当遇到字符串与变量拼接的情况使用模板字符串；\n对象的简化写法\nES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法,这样的书写更加简洁\n\nlet name = &#x27;aaa&#x27;;let change = function()&#123;    console.log(&#x27;aaa&#x27;);&#125;const school = &#123;    name,    change,    improve()&#123;        consolg.log(&#x27;bbb&#x27;);    &#125;&#125;\n\n箭头函数\nES6允许使用箭头（&#x3D;&gt;）定义函数，箭头函数提供了一种更加简洁的函数书写方式，箭头函数多用于匿 名函数的定义；\n\n箭头函数的注意点：\n如果形参只有一个，则小括号可以省略；\n函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果； \n箭头函数 this 指向声明时所在作用域下 this 的值； \n箭头函数不能作为构造函数实例化； \n不能使用 arguments；\n\n特性\nthis是静态的，this始终指向函数声明时所在作用域下的this的值\nfunction A()&#123;              //全局作用域下声明的    console.log(this.name)&#125;let B = () =&gt; &#123;            //全局作用域下声明的    console.log(this.name);&#125;window.name = &#x27;尚硅谷&#x27;;const school = &#123;    name: &#x27;ATGUIGU&#x27;&#125;//直接调用A()   //尚硅谷B()  //尚硅谷//callA.call(school); //ATGUIGUB.cal(school);  //尚硅谷\n\n不能作为构造实例化对象\nlet A(name,age) =&gt; &#123;    this.name=name;    this.age=age;&#125;let me = new A(&#x27;xiao&#x27;,123);console.me //error\n\n不能使用arguments变量\nlet fn = () =&gt; &#123;    console.log(arguments)；&#125;fn(1,2,3)  //error\n\n箭头函数的简写\n\n省略小括号，当形参有且只有一个的时候\n\nlet add = n =&gt; &#123;    return n + 1;&#125;\n\n\n省略花括号，当代码体只有一条语句的时候，此时return也必须省略\n\nlet add = n =&gt; n+1;\n\n箭头函数的实践与应用场景需求1：点击div2s后颜色变成粉色传统方法：\n//需求-1  点击 div 2s 后颜色变成『粉色』//获取元素let ad = document.getElementById(&#x27;ad&#x27;);//绑定事件ad.addEventListener(&quot;click&quot;, function()&#123;    //保存 this 的值    let _this = this;    //定时器    setTimeout(funciton()&#123;        //修改背景颜色 this        _this.style.background = &#x27;pink&#x27;;    &#125;, 2000);&#125;);\n\n使用箭头函数解决：\n//需求-1  点击 div 2s 后颜色变成『粉色』//获取元素let ad = document.getElementById(&#x27;ad&#x27;);//绑定事件ad.addEventListener(&quot;click&quot;, function()&#123;    //保存 this 的值    // let _this = this;    //定时器    setTimeout(() =&gt; &#123;               //箭头函数指向函数声明时所在作用域下的this的值（ad）        //修改背景颜色 this        // console.log(this);        // _this.style.background = &#x27;pink&#x27;;        this.style.background = &#x27;pink&#x27;;    &#125;, 2000);&#125;);\n\n需求2：从数组中返回偶数的元素传统方法：\nconst arr = [1,6,9,10,100,25];const result = arr.filter(function(item)&#123;    if(item % 2 === 0)&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;);\n\n使用箭头函数解决：\nconst result = arr.filter(item =&gt; item % 2 === 0);\n\n应用场景：\n箭头函数适合与this无关的回调：定时器，数组的方法回调\n箭头函数不适合与this有关的回调：事件回调，对象的方法\n\n函数参数的默认值\nES6允许给函数参数赋值初始值\n\n\n可以给形参赋初始值，一般位置要靠后（潜规则）\nfunction add(a,b,c=12)&#123;    return a+b+c; &#125;let result = add (1,2);console.log(result) // 15\n\n与解构赋值结合\nfunction A(&#123;host=&#x27;127.0.0.1&#x27;,username,password,port&#125;)&#123;    console.log(host+username+password+port)&#125;A(&#123;    username:&#x27;ran&#x27;,    password:&#x27;123456&#x27;,    port:3306&#125;)\n\nrest参数\nES6引入rest参数【…args】，用于获取函数的实参，用来代替arguments\n\n特性function date(...args)&#123;    console.log(args);&#125;date(&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;)；\n\n\nrest 参数比较要放到参数最后\nfunction fn(a,b,...args)&#123;    console.log(a);    console.log(b);    console.log(args);&#125;fn(1,2,3,4,5,6)\n\n扩展运算符\n【…】扩展运算符是能将数组转换为逗号分隔的参数序列\n\n特性const tfboys=[&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;]function chunwan()&#123;    console.log(arguments);&#125;chunwan(...tfboys);  //0:&#x27;AA&#x27; 1:&#x27;BB&#x27; 2:&#x27;CC&#x27;\n\n应用\n数组的合并\nconst A = [&#x27;aa&#x27;,&#x27;bb&#x27;];const B = [&#x27;cc&#x27;,&#x27;dd&#x27;];//const C = A.concat(B);const C = [...A,...B];console.log(C)   //[aa,bb,cc,dd]\n\n数组的克隆\nconst A = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];const B = [...A];console.log(B)   //[a,b,c]\n\n将伪数组转换为真正的数组\nconst A = documents.querySelectorAll(&#x27;div&#x27;);const B = [...A];console.log(B) // [div,div,div]//1.数组去重let arr = [1,2,3,4,5,4,3,2,1]let result = [...new Set(arr)]console.log(result);\n\nSymbol概述\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。\nES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。\nSymbol 值通过Symbol()函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\nlet s = Symbol();typeof s// &quot;symbol&quot;\n\n上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。\n注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\nSymbol的特点\nSymbol的值是唯一的，用来解决命名冲突的问题\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nlet s1 = Symbol(&#x27;foo&#x27;);let s2 = Symbol(&#x27;bar&#x27;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot;\n\n上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。\nconst obj = &#123;  toString() &#123;    return &#x27;abc&#x27;;  &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc)\n\n注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\n// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol(&#x27;foo&#x27;);let s2 = Symbol(&#x27;foo&#x27;);s1 === s2 // false\n\nSymbol 值不能与其他类型的值进行运算，会报错。\nlet sym = Symbol(&#x27;My symbol&#x27;);&quot;your symbol is &quot; + sym// TypeError: can&#x27;t convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can&#x27;t convert symbol to string\n\n但是，Symbol 值可以显式转为字符串。\nlet sym = Symbol(&#x27;My symbol&#x27;);String(sym) // &#x27;Symbol(My symbol)&#x27;sym.toString() // &#x27;Symbol(My symbol)&#x27;\n\n另外，Symbol 值也可以转为布尔值，但是不能转为数值。\nlet sym = Symbol();Boolean(sym) // true!sym  // falseif (sym) &#123;  // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError\n\n应用场景Symbol适用于给对象添加属性和方法\nSymbol.prototype.description创建 Symbol 的时候，可以添加一个描述。\nconst sym = Symbol(&#x27;foo&#x27;);\n\n上面代码中，sym的描述就是字符串foo。\n但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。\nconst sym = Symbol(&#x27;foo&#x27;);String(sym) // &quot;Symbol(foo)&quot;sym.toString() // &quot;Symbol(foo)&quot;\n\n上面的用法不是很方便。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。\nconst sym = Symbol(&#x27;foo&#x27;);sym.description // &quot;foo&quot;\n\n作为属性名的Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\nlet mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &#x27;Hello!&#x27;;// 第二种写法let a = &#123;  [mySymbol]: &#x27;Hello!&#x27;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &#x27;Hello!&#x27; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot;\n\n上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\nconst mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = &#x27;Hello!&#x27;;a[mySymbol] // undefineda[&#x27;mySymbol&#x27;] // &quot;Hello!&quot;\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\nlet s = Symbol();let obj = &#123;  [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123);\n\n上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。\n采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。\nlet obj = &#123;  [s](arg) &#123; ... &#125;&#125;;\n\n\n\nSymbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\nconst log = &#123;&#125;;log.levels = &#123;  DEBUG: Symbol(&#x27;debug&#x27;),  INFO: Symbol(&#x27;info&#x27;),  WARN: Symbol(&#x27;warn&#x27;)&#125;;console.log(log.levels.DEBUG, &#x27;debug message&#x27;);console.log(log.levels.INFO, &#x27;info message&#x27;);\n\n下面是另外一个例子。\nconst COLOR_RED    = Symbol();const COLOR_GREEN  = Symbol();function getComplement(color) &#123;  switch (color) &#123;    case COLOR_RED:      return COLOR_GREEN;    case COLOR_GREEN:      return COLOR_RED;    default:      throw new Error(&#x27;Undefined color&#x27;);    &#125;&#125;\n\n常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。\n还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\nfunction getArea(shape, options) &#123;  let area = 0;  switch (shape) &#123;    case &#x27;Triangle&#x27;: // 魔术字符串      area = .5 * options.width * options.height;      break;    /* ... more code ... */  &#125;  return area;&#125;getArea(&#x27;Triangle&#x27;, &#123; width: 100, height: 100 &#125;); // 魔术字符串\n\n上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。\n常用的消除魔术字符串的方法，就是把它写成一个变量。\nconst shapeType = &#123;  triangle: &#x27;Triangle&#x27;&#125;;function getArea(shape, options) &#123;  let area = 0;  switch (shape) &#123;    case shapeType.triangle:      area = .5 * options.width * options.height;      break;  &#125;  return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);\n\n上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。\n如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。\nconst shapeType = &#123;  triangle: Symbol()&#125;;\n\n上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。\n属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nconst obj = &#123;&#125;;let a = Symbol(&#x27;a&#x27;);let b = Symbol(&#x27;b&#x27;);obj[a] = &#x27;Hello&#x27;;obj[b] = &#x27;World&#x27;;const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)]\n\n上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。\n下面是另一个例子，Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。\nconst obj = &#123;&#125;;const foo = Symbol(&#x27;foo&#x27;);obj[foo] = &#x27;bar&#x27;;for (let i in obj) &#123;  console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj) // []Object.getOwnPropertySymbols(obj) // [Symbol(foo)]\n\n上面代码中，使用for...in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。\n另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\nlet obj = &#123;  [Symbol(&#x27;my_key&#x27;)]: 1,  enum: 2,  nonEnum: 3&#125;;Reflect.ownKeys(obj)//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]\n\n由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\nlet size = Symbol(&#x27;size&#x27;);class Collection &#123;  constructor() &#123;    this[size] = 0;  &#125;  add(item) &#123;    this[this[size]] = item;    this[size]++;  &#125;  static sizeOf(instance) &#123;    return instance[size];  &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add(&#x27;foo&#x27;);Collection.sizeOf(x) // 1Object.keys(x) // [&#x27;0&#x27;]Object.getOwnPropertyNames(x) // [&#x27;0&#x27;]Object.getOwnPropertySymbols(x) // [Symbol(size)]\n\n上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\nSymbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\nlet s1 = Symbol.for(&#x27;foo&#x27;);let s2 = Symbol.for(&#x27;foo&#x27;);s1 === s2 // true\n\n上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。\nSymbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)// trueSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)// false\n\n上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。\nSymbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。\nlet s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined\n\n上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\nfunction foo() &#123;  return Symbol.for(&#x27;bar&#x27;);&#125;const x = foo();const y = Symbol.for(&#x27;bar&#x27;);console.log(x === y); // true\n\n上面代码中，Symbol.for(&#39;bar&#39;)是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行Symbol.for(&#39;bar&#39;)可以取到这个 Symbol 值。\nSymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\niframe = document.createElement(&#x27;iframe&#x27;);iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for(&#x27;foo&#x27;) === Symbol.for(&#x27;foo&#x27;)// true\n\n上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。\n实例：模块的 Singleton 模式Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。\n对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？\n很容易想到，可以把实例放到顶层对象global。\n// mod.jsfunction A() &#123;  this.foo = &#x27;hello&#x27;;&#125;if (!global._foo) &#123;  global._foo = new A();&#125;module.exports = global._foo;\n\n然后，加载上面的mod.js。\nconst a = require(&#x27;./mod.js&#x27;);console.log(a.foo);\n\n上面代码中，变量a任何时候加载的都是A的同一个实例。\n但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。\nglobal._foo = &#123; foo: &#x27;world&#x27; &#125;;const a = require(&#x27;./mod.js&#x27;);console.log(a.foo);\n\n上面的代码，会使得加载mod.js的脚本都失真。\n为了防止这种情况出现，我们就可以使用 Symbol。\n// mod.jsconst FOO_KEY = Symbol.for(&#x27;foo&#x27;);function A() &#123;  this.foo = &#x27;hello&#x27;;&#125;if (!global[FOO_KEY]) &#123;  global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY];\n\n上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。\nglobal[Symbol.for(&#x27;foo&#x27;)] = &#123; foo: &#x27;world&#x27; &#125;;const a = require(&#x27;./mod.js&#x27;);\n\n如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n// mod.jsconst FOO_KEY = Symbol(&#x27;foo&#x27;);// 后面代码相同 ……\n\n上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。\n内置的 Symbol 值除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。\nclass MyClass &#123;  [Symbol.hasInstance](foo) &#123;    return foo instanceof Array;  &#125;&#125;[1, 2, 3] instanceof new MyClass() // true\n\n上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。\n下面是另一个例子。\nclass Even &#123;  static [Symbol.hasInstance](obj) &#123;    return Number(obj) % 2 === 0;  &#125;&#125;// 等同于const Even = &#123;  [Symbol.hasInstance](obj) &#123;    return Number(obj) % 2 === 0;  &#125;&#125;;1 instanceof Even // false2 instanceof Even // true12345 instanceof Even // false\n\nSymbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。\nlet arr1 = [&#x27;c&#x27;, &#x27;d&#x27;];[&#x27;a&#x27;, &#x27;b&#x27;].concat(arr1, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]arr1[Symbol.isConcatSpreadable] // undefinedlet arr2 = [&#x27;c&#x27;, &#x27;d&#x27;];arr2[Symbol.isConcatSpreadable] = false;[&#x27;a&#x27;, &#x27;b&#x27;].concat(arr2, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]\n\n上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。\n类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。\nlet obj = &#123;length: 2, 0: &#x27;c&#x27;, 1: &#x27;d&#x27;&#125;;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]obj[Symbol.isConcatSpreadable] = true;[&#x27;a&#x27;, &#x27;b&#x27;].concat(obj, &#x27;e&#x27;) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]\n\nSymbol.isConcatSpreadable属性也可以定义在类里面。\nclass A1 extends Array &#123;  constructor(args) &#123;    super(args);    this[Symbol.isConcatSpreadable] = true;  &#125;&#125;class A2 extends Array &#123;  constructor(args) &#123;    super(args);  &#125;  get [Symbol.isConcatSpreadable] () &#123;    return false;  &#125;&#125;let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2)// [1, 2, 3, 4, [5, 6]]\n\n上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。\n注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。\nSymbol.species对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。\nclass MyArray extends Array &#123;&#125;const a = new MyArray(1, 2, 3);const b = a.map(x =&gt; x);const c = a.filter(x =&gt; x &gt; 1);b instanceof MyArray // truec instanceof MyArray // true\n\n上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。\nSymbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。\nclass MyArray extends Array &#123;  static get [Symbol.species]() &#123; return Array; &#125;&#125;\n\n上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。\nstatic get [Symbol.species]() &#123;  return this;&#125;\n\n现在，再来看前面的例子。\nclass MyArray extends Array &#123;  static get [Symbol.species]() &#123; return Array; &#125;&#125;const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true\n\n上面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。\n再看一个例子。\nclass T1 extends Promise &#123;&#125;class T2 extends Promise &#123;  static get [Symbol.species]() &#123;    return Promise;  &#125;&#125;new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // truenew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false\n\n上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。\n总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。\nSymbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。\nString.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher &#123;  [Symbol.match](string) &#123;    return &#x27;hello world&#x27;.indexOf(string);  &#125;&#125;&#x27;e&#x27;.match(new MyMatcher()) // 1\n\nSymbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\nString.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue)\n\n下面是一个例子。\nconst x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&#x27;Hello&#x27;.replace(x, &#x27;World&#x27;) // [&quot;Hello&quot;, &quot;World&quot;]\n\nSymbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。\nSymbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\nString.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch &#123;  constructor(value) &#123;    this.value = value;  &#125;  [Symbol.search](string) &#123;    return string.indexOf(this.value);  &#125;&#125;&#x27;foobar&#x27;.search(new MySearch(&#x27;foo&#x27;)) // 0\n\nSymbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\nString.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit)\n\n下面是一个例子。\nclass MySplitter &#123;  constructor(value) &#123;    this.value = value;  &#125;  [Symbol.split](string) &#123;    let index = string.indexOf(this.value);    if (index === -1) &#123;      return string;    &#125;    return [      string.substr(0, index),      string.substr(index + this.value.length)    ];  &#125;&#125;&#x27;foobar&#x27;.split(new MySplitter(&#x27;foo&#x27;))// [&#x27;&#x27;, &#x27;bar&#x27;]&#x27;foobar&#x27;.split(new MySplitter(&#x27;bar&#x27;))// [&#x27;foo&#x27;, &#x27;&#x27;]&#x27;foobar&#x27;.split(new MySplitter(&#x27;baz&#x27;))// &#x27;foobar&#x27;\n\n上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为，\nSymbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\nconst myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;  yield 1;  yield 2;  yield 3;&#125;;[...myIterable] // [1, 2, 3]\n\n对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。\nclass Collection &#123;  *[Symbol.iterator]() &#123;    let i = 0;    while(this[i] !== undefined) &#123;      yield this[i];      ++i;    &#125;  &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for(let value of myCollection) &#123;  console.log(value);&#125;// 1// 2\n\nSymbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\nSymbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\nNumber：该场合需要转成数值\nString：该场合需要转成字符串\nDefault：该场合可以转成数值，也可以转成字符串\n\nlet obj = &#123;  [Symbol.toPrimitive](hint) &#123;    switch (hint) &#123;      case &#x27;number&#x27;:        return 123;      case &#x27;string&#x27;:        return &#x27;str&#x27;;      case &#x27;default&#x27;:        return &#x27;default&#x27;;      default:        throw new Error();     &#125;   &#125;&#125;;2 * obj // 2463 + obj // &#x27;3default&#x27;obj == &#x27;default&#x27; // trueString(obj) // &#x27;str&#x27;\n\nSymbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。\n// 例一(&#123;[Symbol.toStringTag]: &#x27;Foo&#x27;&#125;.toString())// &quot;[object Foo]&quot;// 例二class Collection &#123;  get [Symbol.toStringTag]() &#123;    return &#x27;xxx&#x27;;  &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot;\n\nES6 新增内置对象的Symbol.toStringTag属性值如下。\n\nJSON[Symbol.toStringTag]：’JSON’\nMath[Symbol.toStringTag]：’Math’\nModule 对象M[Symbol.toStringTag]：’Module’\nArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’\nDataView.prototype[Symbol.toStringTag]：’DataView’\nMap.prototype[Symbol.toStringTag]：’Map’\nPromise.prototype[Symbol.toStringTag]：’Promise’\nSet.prototype[Symbol.toStringTag]：’Set’\n%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等\nWeakMap.prototype[Symbol.toStringTag]：’WeakMap’\nWeakSet.prototype[Symbol.toStringTag]：’WeakSet’\n%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’\n%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’\n%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’\nSymbol.prototype[Symbol.toStringTag]：’Symbol’\nGenerator.prototype[Symbol.toStringTag]：’Generator’\nGeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’\n\nSymbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\nArray.prototype[Symbol.unscopables]// &#123;//   copyWithin: true,//   entries: true,//   fill: true,//   find: true,//   findIndex: true,//   includes: true,//   keys: true// &#125;Object.keys(Array.prototype[Symbol.unscopables])// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]\n\n上面代码说明，数组有 7 个属性，会被with命令排除。\n// 没有 unscopables 时class MyClass &#123;  foo() &#123; return 1; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123;  foo(); // 1&#125;// 有 unscopables 时class MyClass &#123;  foo() &#123; return 1; &#125;  get [Symbol.unscopables]() &#123;    return &#123; foo: true &#125;;  &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123;  foo(); // 2&#125;\n\n上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。\n迭代器\n迭代器(lterator)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署lterator接口，就可以完成遍历操作。\n\n原理\n创建一个指针对象，指向当前数据结构的起始位置；\n第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员； \n接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员；\n每调用 next 方法返回一个包含 value 和 done 属性的对象；\n\n\n 注：需要自定义遍历数据的时候，要想到迭代器\n\nconst xiyou=[&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;,&#x27;DD&#x27;];// for(let v of xiyou)&#123;//     console.log(v)  // &#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;,&#x27;DD&#x27;  //for in保存的是键名，for of保存的是键值// &#125;let iterator = xiyou[Symbol.iterator]();console.log(iterator.next()); //&#123;&#123;value:&#x27;唐僧&#x27;，done:false&#125;&#125;console.log(iterator.next()); //&#123;&#123;value:&#x27;孙悟空&#x27;，done:false&#125;&#125;\n\n特性ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费； \n原生具备 iterator 接口的数据(可用 for of 遍历)： \nArray； Arguments； Set； Map； String； TypedArray； NodeList。Object对象没有\n应用（自定义遍历数据）const banji = &#123;    name : &quot;终极一班&quot;,    stus: [        &#x27;aa&#x27;,        &#x27;bb&#x27;,        &#x27;cc&#x27;,        &#x27;dd&#x27;    ],    [Symbol.iterator]()&#123;        let index = 0;        let _this = this;        return &#123;            next: () =&gt; &#123;                if(index &lt; this.stus.length)&#123;                    const result = &#123;value: _this.stus[index],done: false&#125;;                    //下标自增                    index++;                    //返回结果                    return result;                &#125;else &#123;                    return &#123;value: underfined,done:true&#125;;                &#125;            &#125;        &#125;    &#125;&#125;for(let v of banji)&#123;    console.log(v);  // aa bb cc dd&#125;\n\n生成器（generator）\n生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同，是一种特殊的函数\njs传统异步编程：纯回调函数 fs ajax mangodb（文件操作、网络操作、数据库操作）\n\nfunction * gen ()&#123;    //函数名和function中间有一个 *     yield &#x27;耳朵&#x27;；     //yield是函数代码的分隔符    yield &#x27;尾巴&#x27;；    yield &#x27;真奇怪&#x27;；&#125;let iterator = gen();console.log(iteretor.next()); //&#123;value:&#x27;耳朵&#x27;,done:false&#125; next（）执行第一段，并且返回yield后面的值console.log(iteretor.next()); //&#123;value:&#x27;尾巴&#x27;,done:false&#125;console.log(iteretor.next()); //&#123;value:&#x27;真奇怪&#x27;,done:false&#125;\n\n应用\n生成器函数的参数传递\nfunction * gen(args)&#123;    console.log(args);    let one = yield 111;    console.log(one);    let two = yield 222;    console.log(two);    let three = yield 333;    console.log(three);&#125;let iterator = gen(&#x27;AAA&#x27;);console.log(iterator.next());console.log(iterator.next(&#x27;BBB&#x27;));  //next中传入的BBB将作为yield 111的返回结果console.log(iterator.next(&#x27;CCC&#x27;));  //next中传入的CCC将作为yield 222的返回结果console.log(iterator.next(&#x27;DDD&#x27;));  //next中传入的DDD将作为yield 333的返回结果\n\n\n\n第二次next()的实参将作为第一次yield的返回结果\n第三次next()的实参将作为第二次yield的返回结果\n第四次next()的实参将作为第三次yield的返回结果\n\n\n实例1：用生成器函数的方式解决回调地狱问题\n传统方法：（回调地狱：层层嵌套缩进、参数容易重名、阅读不便、调试不便）\nsetTimeout(()=&gt;&#123;     console.log(&#x27;111&#x27;)     setTimeout(()=&gt;&#123;         console.log(&#x27;222&#x27;)         setTimeout(()=&gt;&#123;             console.log(&#x27;333&#x27;)                     &#125;,3000)    &#125;,2000)&#125;,1000)\n\n生成器函数方法：\n//1s后后输出111 2s后输出222 3s后输出333function one()&#123;           //第一个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;111&#x27;)        iterator.next()    &#125;,1000)&#125;function two()&#123;           //第二个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;222&#x27;)        iterator.next();    &#125;,2000)&#125;function three()&#123;          //第三个异步任务    setTimeout(()=&gt;&#123;        console.log(&#x27;333&#x27;)        iterator.next();    &#125;,3000)&#125;function * gen()&#123;         //生成器函数    yield one();    yield two();    yield three();&#125;let iterator = gen();iterator.next();\n\n实例2：模拟异步获取数据（先获取用户数据、再订单数据、最后商品数据）\nfunction getUsers()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;用户数据&#x27;;        iterator.next(data)   //第二次next()的实参将作为第一次yield的返回结果    &#125;,1000)&#125;function getOrders()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;订单数据&#x27;;        iterator.next(data)  //第三次next()的实参将作为第二次yield的返回结果    &#125;,1000)&#125;function getGoods()&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;商品数据&#x27;;           iterator.next(data)   //第四次next()的实参将作为第三次yield的返回结果    &#125;,1000)&#125;function * gen()&#123;    let users=yield one();    console.log(users)    let orders=yield two();    console.log(orders)    let goods=yield three();    console.log(goods)&#125;let iterator = gen();iterator.next();\n\nPromise\nPromise是ES6引入的异步编程的新解决方案。语法上 Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。\n\nconst p =new Promise((resolve, reject)=&gt;&#123;    setTimeout(()=&gt;&#123;        let data=&#x27;数据库数据&#x27;        // resolve(data);        reject(data);    &#125;)&#125;)p.then(function (value)&#123;         //成功则执行第一个回调函数，失败则执行第二个    console.log(value)&#125;,function (reason)&#123;    console.error(reason)&#125;)\n\nSet\nES6提供了新的数据结构set(集合）。它类似于数组，但成员的值都是唯一的，集合实现了iterator接口，所以可以使用「扩展运算符』和「 for…of…』进行遍历，集合的属性和方法:\n\n\nsize返回集合的元素个数\nadd增加一个新元素，返回当前集合\ndelete删除元素，返回boolean值has检测集合中是否包含某个元素，返回boolean值\n\n&lt;script&gt;    let s = new Set();    let s2 = new Set([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;A&#x27;])    //元素个数    console.log(s2.size);    //4    //添加新的元素    s2.add(&#x27;E&#x27;);    //删除元素    s2.delete(&#x27;A&#x27;)    //检测    console.log(s2.has(&#x27;C&#x27;));  //true    //清空    s2.clear()    console.log(s2);        for (let v of s2)&#123;        console.log(v);    &#125;&lt;/script&gt;\n\n应用&lt;script&gt;    let arr = [1,2,3,4,5,4,3,2,1]    //1.数组去重    let result = [...new Set(arr)]    //使用扩展运算符将集合变成数组    console.log(result);    //2.交集    let arr2=[4,5,6,5,6]    let result2 = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item))    console.log(result2);    //3.并集    let result3=[new Set([...arr,...arr2])]    console.log(result3);    //4.差集    let result4= [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)))    console.log(result4);&lt;/script&gt;\n\nMap\nES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和「for…of…』进行遍历。Map的属性和方法。\n\n&lt;script&gt;    let m = new Map();    m.set(&#x27;name&#x27;,&#x27;ran&#x27;);    m.set(&#x27;change&#x27;,()=&gt;&#123;        console.log(&#x27;改变！&#x27;)    &#125;)    let key=&#123;        school:&#x27;atguigu&#x27;    &#125;    m.set(key,[&#x27;成都&#x27;,&#x27;西安&#x27;]);    //size    console.log(m.size);    //删除    m.delete(&#x27;name&#x27;);    //获取    console.log(m.get(&#x27;change&#x27;));    // //清空    // m.clear()    //遍历    for(let v of m)&#123;        console.log(v);    &#125;&lt;/script&gt;\n\nClass\nES6提供了更接近传统语言(java,c++)的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n\nES5使用构造函数实例化方法：\n//手机function Phone(brand, price)&#123;    this.brand = brand;    this.price = price;&#125;//添加方法Phone.prototype.call = function()&#123;    console.log(&quot;我可以打电话!!&quot;);&#125;//实例化对象let Huawei = new Phone(&#x27;华为&#x27;, 5999);Huawei.call();console.log(Huawei);\n\nES6使用class实例化方法：\n&lt;script&gt;    class shouji &#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price        &#125;        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    let A = new shouji(&#x27;1+&#x27;,1999);    console.log(A)&lt;/script&gt;\n\n静态成员\n属于类而不属于示例对象的属性\n\n//传统写法function Phone()&#123;&#125;Phone.name = &#x27;手机&#x27;;Phone.change = function()&#123;    console.log(&quot;我可以改变世界&quot;);&#125;Phone.prototype.size = &#x27;5.5inch&#x27;;let nokia = new Phone();  console.log(nokia.name);    //undefined// nokia.change();console.log(nokia.size);    //&#x27;5.5inch&#x27;//class写法class Person&#123;\tstatic name=&#x27;手机&#x27;&#125;let nokia = new Person();console.log(nokia.name);    //undefined\n\n继承\nES5中使用构造函数实现继承（原型链）\n&lt;script&gt;  //父函数  function Phone(brand,price)&#123;      this.brand=brand;      this.price=price;  &#125;  Phone.prototype.call=function ()&#123;      console.log(&quot;我可以打电话&quot;);  &#125;  //子函数  function SmartPhone(brand,price,color,size)&#123;      Phone.call(this,brand,price);      this.color=color;      this.size=size;  &#125;  //设置子级构造函数原型  SmartPhone.prototype=new Phone;  SmartPhone.prototype.constructor=SmartPhone;  //声明子类方法  SmartPhone.prototype.photo = function ()&#123;      console.log(&#x27;我可以拍照&#x27;);  &#125;  const chuizi = new SmartPhone(&#x27;锤子&#x27;,2499,&#x27;黑色&#x27;,&#x27;5.5inch&#x27;)  console.log(chuizi);&lt;/script&gt;\n\nES6中Class的类继承\n&lt;script&gt;    class Phone&#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price;        &#125;        //父类的成员属性        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    class SmartPhone extends Phone&#123;        constructor(brand,price,color,size) &#123;            super(brand,price);      //super即为父类的constructor方法            this.color=color;            this.size=size;        &#125;        photo()&#123;            console.log(&#x27;拍照&#x27;);        &#125;        playGame()&#123;            console.log(&#x27;打游戏&#x27;);        &#125;    &#125;    const xiaomi=new SmartPhone(&#x27;小米&#x27;,1999,&#x27;黑色&#x27;,&#x27;4.7inch&#x27;)    xiaomi.call();    xiaomi.photo();    xiaomi.playGame();&lt;/script&gt;\n\n子类对父类方法的重写&lt;script&gt;    class Phone&#123;        constructor(brand,price) &#123;            this.brand=brand;            this.price=price;        &#125;        //父类的成员属性        call()&#123;            console.log(&#x27;我可以打电话&#x27;)        &#125;    &#125;    class SmartPhone extends Phone&#123;        constructor(brand,price,color,size) &#123;            super(brand,price);            this.color=color;            this.size=size;        &#125;        photo()&#123;            console.log(&#x27;拍照&#x27;);        &#125;        playGame()&#123;            console.log(&#x27;打游戏&#x27;);        &#125;        //重写！        call()&#123;            console.log(&#x27;我可以进行视频通话&#x27;)        &#125;    &#125;    const xiaomi=new SmartPhone(&#x27;小米&#x27;,1999,&#x27;黑色&#x27;,&#x27;4.7inch&#x27;)    xiaomi.call();    xiaomi.photo();    xiaomi.playGame();&lt;/script&gt;\n\nget和set设置&lt;script&gt;  class Phone&#123;      get price()&#123;          console.log(&quot;价格被读取了&quot;)          return &#x27;I LOVE YOU&#x27;      &#125;      set price(val)&#123;          console.log(&#x27;价格被修改了&#x27;)          return val;      &#125;  &#125;    //实例化对象    let s = new Phone();     s.price=12                //输出 价格被修改了    // console.log(s.price)   //输出 价格被读取了 I LOVE YOU&lt;/script&gt;\n\n数值扩展&lt;script&gt;   // Number.EPSILON是 JavaScript的最小精度，属性的值接近于 2.22044...E-16   function equal(a,b)&#123;       if(Math.abs(a-b) &lt; Number.EPSILON)&#123;           return true;       &#125;else &#123;           return false;       &#125;   &#125;   console.log(equal(0.1 + 0.2 === 0.3))  //false   console.log(equal(0.1+0.2,0.3))  //true   //二进制和八进制   let b = 0b1010; //2进制0b   let o = 0o777;  //8进制0o   let d = 100;    //10进制   let x = 0xff;   //16进制0x   console.log(x)   //255   //检测一个数是否为有限数   console.log(Number.isFinite(100));  //true   console.log(Number.isFinite(100/0));  //false   console.log(Number.isFinite(Infinity));  //false   //检测一个数值是否为NaN   console.log(Number.isNaN(123))  //false   //字符串转整数   console.log(Number.parseInt(&#x27;5213123love&#x27;)); //5213123   console.log(Number.parseFloat(&#x27;5.123123神器&#x27;)); //5.123123   //判断是否为整数   console.log(Number.isInteger(5));  //true   console.log(Number.isInteger(2.5)); //false      //将小数部分抹除   console.log(Math.trunc(3.45345345345)) //3   //检测一个数到底是正数、负数、还是0   console.log(Math.sign(100)) //1   console.log(Math.sign(0))  //0   console.log(Math.sign(-123)) //-1&lt;/script&gt;\n\n对象方法扩展&lt;script&gt;    //1.Object.is 判断两个值是否完全相等    console.log(Object.is(120,120))  //true\tconsole.log(Object.is(NaN,NaN))  //false    //2.Object.assign 对象的合并    const a = &#123;        name:&#x27;ran&#x27;,        age:12    &#125;    const b = &#123;        pass:&#x27;i love you&#x27;    &#125;    console.log(Object.assign(a,b))   //&#123;name:&#x27;ran&#x27;,age:&#x27;12&#x27;,pass:&#x27;i love you&#x27;&#125;前者为模板，后者会被前者属性覆盖，前者独有的属性不会被覆盖    //3.Object.setPrototypeOf 设置原型对象 Object.getPrototypeof    const school = &#123;        name:&#x27;尚硅谷&#x27;    &#125;    const cities = &#123;        xiaoqu:[&#x27;北京&#x27;,&#x27;上海&#x27;]    &#125;    Object.setPrototypeOf(school,cities)    console.log(Object.getPrototypeOf(school))  //&#123;xiaoqu: Array(2)&#125;    console.log(school)  //&#123;name: &quot;尚硅谷&quot;&#125;&lt;/script&gt;\n\n模块化\n模块化是指将一个大的程序文件,拆分成许多小的文件，然后将小文件组合起来。\n\n\n模块化的好处：\n\n防止命名冲突\n\n代码复用\n\n高维护性\n\n模块化规范产品\n\n\n\nES6之前的模块化规范有：\n\nCommonJS &#x3D;&#x3D;&#x3D;&#x3D;&gt; NodeJS、Browserify\n\nAMD &#x3D;&#x3D;&#x3D;&#x3D;&gt; requireJS\n\nCMD &#x3D;&#x3D;&#x3D;&#x3D;&gt; seaJS\n\n\n\n\nES6模块化语法模块功能主要有两个命令构成：export和import\n\nexport命令用于规定模块的对外接口\nimport命令用于输入其他模块提供的功能、\n\nm1.js\nexport let school = &#x27;尚硅谷&#x27;export function teach()&#123;    console.log(&#x27;教技能&#x27;)&#125;\n\nindex.html\n&lt;script type=&quot;module&quot;&gt;    import * as m1 from &quot;./src/js/m1.js&quot;;\tconsole.log(m1);&lt;/script&gt;\n\n暴露语法汇总\n分别暴露\nexport let school = &#x27;尚硅谷&#x27;export function teach()&#123;    console.log(&#x27;教技能&#x27;)&#125;\n\n统一暴露\n//统一暴露let school = &#x27;尚硅谷&#x27;;function findjob()&#123;    console.log(&#x27;找工作吧&#x27;);&#125;export &#123;school,findjob&#125;;\n\n默认暴露\n//默认暴露export default &#123;    school:&#x27;ATGUIGU&#x27;,    change:function()&#123;        console.log(&#x27;我们可以改变你&#x27;)    &#125;&#125;\n\n引入语法汇总\n通用导入方式\nimport * as m1 from &quot;./src/js/m1.js&quot;import * as m2 from &quot;./src/js/m2.js&quot;import * as m3 from &quot;./src/js/m3.js&quot;\n\n解构赋值形式\nimport &#123;school,teach&#125; from &quot;./src/js/m1.js&quot;         //对应分别暴露import &#123;school as guigu,findJob&#125; from &quot;./src/js/m2.js&quot;  //对应统一暴露import &#123;default as m3 &#125; from &quot;./src/js/m3.js&quot;     //对应默认暴露\n\n简便形式（只针对默认暴露）\nimport m3 from &quot;./src/js/m3.js&quot;\n\n模块化方式2不在html写js语句\napp.js 入口文件（模块引入）\nimport * as m1 from &quot;./src/js/m1.js&quot;import * as m2 from &quot;./src/js/m2.js&quot;import * as m3 from &quot;./src/js/m3.js&quot;\n\nindex.html\n&lt;script src=&quot;./src//js/app.js&quot; type=modeule&gt;&lt;/script&gt;\n\nES6模块化代码在项目中的使用babel对ES6模块化代码转换\n\nbabel：一个js编译器，将较新的语法转化为ES5语法，以适配所有浏览器的兼容\n\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6（六）：ES10新特性","url":"/2022/04/30/ES6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AES10%E6%96%B0%E7%89%B9%E6%80%A7/","content":"对象扩展方法\nObject.fromEntries 用来创建对象，接收参数为一个二维数组或map\n相当于Object.entries的逆运算\n&lt;script&gt;   //二维数组   const res = Object.fromEntries([       [&#x27;name&#x27;,&#x27;RHF&#x27;],       [&#x27;cities&#x27;,&#x27;成都&#x27;,&#x27;武汉&#x27;]   ])   console.log(res) //&#123;name: &quot;RHF&quot;, cities: &quot;成都&quot;&#125;   //Map   const m = new Map();   m.set(&#x27;name&#x27;,&#x27;ranhaifeng&#x27;)   const result = Object.fromEntries(m)   console.log(result); //&#123;name: &quot;ranhaifeng&quot;&#125;&lt;/script&gt;\n\n字符串扩展方法trimStart与trimEnd&lt;script&gt;   //trim   let str= &#x27; asd  &#x27;   console.log(str) //asd   console.log(str.trimStart()) //asd  清空左侧空格   console.log(str.trimEnd()) //  asd  清空右侧空格&lt;/script&gt;\n\n数组方法扩展flat与flatMap\nflat 将多维数组转换为低维数组\n\n&lt;script&gt;    const arr = [1,2,3,[4,5,6,[7,8,9]]]    //参数为深度，是一个数字    console.log(arr.flat(2)) //[1,2,3,4,5,6,7,8,9]\tconst arr2=[1,2,3,4]    const result = arr2.flatmap(item =&gt; [item * 10]); //如果map的结果是一个多维数组可以进行flat 是两个操作的结合\t&lt;/script&gt;\n\nSymbol扩展Symbol.prototype.description\n用来获取Symbol的字符串描述\n\nlet s = Symbol(&#x27;尚硅谷&#x27;);console.log(s.description) //尚硅谷\n\n","categories":["ES6"],"tags":["ES10"]},{"title":"ES6（四）：ES8新特性","url":"/2022/04/30/ES6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AES8%E6%96%B0%E7%89%B9%E6%80%A7/","content":"async和await\nasync和await两种语法结合可以让异步代码像同步代码一样，也是异步编程的一种新的解决方案。（1.生成器函数 2.promise 3.async和await）\n\nasync函数：\nasync函数的返回值为promise对象\nasync返回的promise对象的结果值由async函数执行的返回值决定\n\nasync function fn()&#123;   //1.如果返回的是一个非Promise的对象，则fn（）返回的结果就是成功状态的Promise对象，值为返回值   //2.如果返回的是一个Promise对象，则fn（）返回的结果与内部Promise对象的结果一致   //3.如果返回的是抛出错误，则fn（）返回的就是失败状态的Promise对象   return new Promise((resolve,reject)=&gt;&#123;       resolve(&#x27;成功的数据&#x27;);   &#125;);&#125;const result = fn();result.then(value=&gt;&#123;   console.log(value)  //成功的数据&#125;,reason=&gt;&#123;   console.log(reason)&#125;)\n\nawait表达式\nawait必须放在async函数中\nawait右侧的表达式一般为promise对象\nawait可以返回的是右侧promise成功的值\nawait右侧的promise如果失败了，就会抛出异常，需要通过try…catch捕获处理\n\n //创建Promise对象const p = new Promise((resolve, reject) =&gt; &#123;    // resolve(&quot;成功的值&quot;)    reject(&quot;失败了&quot;)&#125;)//await 必须放在async函数中async function main() &#123;    try &#123;        let res = await p;        console.log(res);    &#125; catch (e) &#123;        console.log(e);    &#125;&#125;//调用函数main()  //失败了\n\n应用\nasync和await结合读取文件\n//1. 引入 fs 模块const fs = require(&quot;fs&quot;);//读取『为学』function readWeiXue() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/为学.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;function readChaYangShi() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/插秧诗.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;function readGuanShu() &#123;    return new Promise((resolve, reject) =&gt; &#123;        fs.readFile(&quot;./resources/观书有感.md&quot;, (err, data) =&gt; &#123;            //如果失败            if (err) reject(err);            //如果成功            resolve(data);        &#125;)    &#125;)&#125;//声明一个 async 函数async function main()&#123;    //获取为学内容    let weixue = await readWeiXue();    //获取插秧诗内容    let chayang = await readChaYangShi();    // 获取观书有感    let guanshu = await readGuanShu();    console.log(weixue.toString());    console.log(chayang.toString());    console.log(guanshu.toString());&#125;main();\n\n如何体现异步：只要有一个await语句后的promise对象是reject，那么整个async函数都会中断执行。\n\nasync和await结合发送AJAX请求\n// 发送 AJAX 请求, 返回的结果是 Promise 对象function sendAJAX(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        //1. 创建对象        const x = new XMLHttpRequest();        //2. 初始化        x.open(&#x27;GET&#x27;, url);        //3. 发送        x.send();        //4. 事件绑定        x.onreadystatechange = function () &#123;            if (x.readyState === 4) &#123;                if (x.status &gt;= 200 &amp;&amp; x.status &lt; 300) &#123;                    //成功啦                    resolve(x.response);                &#125;else&#123;                    //如果失败                    reject(x.status);                &#125;            &#125;        &#125;    &#125;)&#125;//promise then 方法测试// sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;).then(value=&gt;&#123;//     console.log(value);// &#125;, reason=&gt;&#123;&#125;)// async 与 await 测试 async function main()&#123;    //发送 AJAX 请求    let result = await sendAJAX(&quot;https://api.apiopen.top/getJoke&quot;);    //再次测试    let tianqi = await sendAJAX(&#x27;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#x27;)    console.log(tianqi);&#125;main();\n\n对象方法扩展\nObject.values\nObject.entries\nObject.getOwnPropertyDescriptor 返回对象属性的描述对象\n\n&lt;script&gt;    const school = &#123;        name:&#x27;尚硅谷&#x27;,        cities:[&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;深圳&#x27;],        xueke:[&#x27;前端&#x27;,&#x27;Java&#x27;,&#x27;大数据&#x27;,&#x27;运维&#x27;]    &#125;;    //获取对象所有的键    console.log(Object.keys(school));    //获取对象所有的值    console.log(Object.values(school));    //entries,用来创建map    console.log(Object.entries(school));    console.log(new Map(Object.entries(school)))    //对象属性的描述对象（用于深层次的对象克隆）    console.log(Object.getOwnPropertyDescriptor(school))        const obj = Object.create(null,&#123;        name:&#123;            value:&#x27;尚硅谷&#x27;,            //属性特性            writable:true,            configurable:true,            enumerable:true,        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["ES6"],"tags":["ES8"]},{"title":"HTML基础（一）：meta标签","url":"/2022/02/26/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Ameta%E6%A0%87%E7%AD%BE/","content":"格式&lt;head&gt;    &lt;meta&gt;&lt;/head&gt;\n\n作用设置网页中的元数据，用于浏览器渲染网页，元数据对用户是不可见的。\n\ncharset：指定网页的字符集编码\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n\nname：指定的数据的名称\n\nkeywords：网页的关键字，搜索引擎的搜索关键词\n&lt;meta name=&quot;keywords&quot; content=&quot;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东&quot;&gt;\n\ndescription：网页的描述，搜索结果简介\n&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。&quot;/&gt;\n\n\n\nviewport：设置视口大小（为适配移动端）\n&lt;!--设置的是css像素，与物理像素区分--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width:100px&quot;&gt;\n\n\n完美视口：\n每一款移动设备设计时，都会有一个最佳像素比（ css像素&#x2F;物理像素）。设置视口width，使之与物理像素的像素比为该值，即可得到最佳效果\n\n不同移动设备的完美视口不同：\n\n\n&lt;!--将网页的视口设置为完美视口--&gt;&lt;!--利用device-width设置视口大小--&gt;&lt;!--initial-scale=1.0，防止横竖屏切换混乱--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width，initial-scale=1.0&quot;&gt;\n\n\ncontent：指定的数据的内容\n\nhttp-equiv：将页面重定向到另一个网站\n&lt;!--三秒后跳转到百度--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt;\n\n","categories":["HTML"],"tags":["移动端","HTML","meta"]},{"title":"HTML基础（三）：表格","url":"/2022/03/05/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC/","content":"\n基本格式：\n&lt;!--创建表格--&gt;&lt;table&gt;     &lt;!--行--&gt;    &lt;tr&gt;        &lt;!--列（单元格）--&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;!--行--&gt;    &lt;tr&gt;        &lt;!--列（单元格）--&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n属性：\n\ncolspan 横向合并单元格\nrowspan 纵向合并单元格\n\n\n注：\n\ntr不是table的子元素：如果表格中没有使用tbody，而是直接使用tr，那么刘阿龙年起会自动创建一个tbody，并且将tr全部放到tbody。\n\n\n\n长表格\n格式：\n&lt;!--创建长表格\t头部 thead\t主题 tbody\t底部 tfoot\t三者顺序调换时不改变结构--&gt;&lt;table&gt;     &lt;thead&gt;        &lt;tr&gt;            &lt;!--头部加粗--&gt;            &lt;th&gt;&lt;/th&gt;            &lt;th&gt;&lt;/th&gt;            &lt;th&gt;&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;\n\n表格的样式\nborder-spacing 指定边框之间的距离\n\nborder-collapse：collapse 设置边框的合并\n\n不同行不同颜色：\ntr:nth-child(odd)&#123;    background-color:#bfa;&#125;\n\nvertical-align 指定元素垂直方向位置\n\nmiddle 默认情况下元素在td中是垂直居中的\n\n可利用以上特性，将div转换为单元格进行垂直居中\n示例：\n&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;    &lt;/div&gt;&lt;/div&gt;\n\n.box1&#123;    width:300px;    height:300px;    background-color:orange;    /*将元素设置为单元格*/    display:tatle-cell;    vertical-align:middle;/*子元素垂直居中*/&#125;.box2&#123;    width:100px;    height:100px;    background-color:yellow;    /*水平居中*/    margin:0 auto;&#125;\n\n\n\n","categories":["HTML"],"tags":["HTML","表格"]},{"title":"HTML基础（二）：相对路径","url":"/2022/02/26/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","content":"含义​    .&#x2F; 表示当前文件所在的目录，可省略不写\n&lt;!--两者都指的是当前目录下的target文件--&gt;&lt;a href=&quot;./target.html&quot;&gt;&lt;/a&gt;&lt;a href=&quot;target.html&quot;&gt;&lt;/a&gt;\n\n​    ..&#x2F; 表示当前文件所在的目录的上一级目录，可多次使用\n&lt;!--指的是当前目录的上一级目录下的target文件--&gt;&lt;a href=&quot;../target.html&quot;&gt;&lt;/a&gt;&lt;!--指的是当前目录的上两级目录下的target文件--&gt;&lt;a href=&quot;../../target.html&quot;&gt;&lt;/a&gt;\n","categories":["HTML"],"tags":["HTML","路径"]},{"title":"ES6（五）：ES9新特性","url":"/2022/04/30/ES6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AES9%E6%96%B0%E7%89%B9%E6%80%A7/","content":"运算扩展符与rest参数\nRest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符\n\nrest参数&lt;script&gt;    function connect(&#123;host,port,...user&#125;)&#123;        console.log(host);        console.log(port);        console.log(user)    &#125;    connect(&#123;        host:&#x27;127.0.0.1&#x27;,        port:3306,        username:&#x27;root&#x27;,        password:&#x27;root&#x27;,        type:&#x27;master&#x27;    &#125;)  //127.0.0.1  3306  &#123;username: &quot;root&quot;, password: &quot;root&quot;, type: &quot;master&quot;&#125;&lt;/script&gt;\n\n扩展运算符//对象合并const skillOne = &#123;    q: &#x27;天音波&#x27;&#125;const skillTwo = &#123;    w: &#x27;金钟罩&#x27;&#125;const skillThree = &#123;    e: &#x27;天雷破&#x27;&#125;const skillFour = &#123;    r: &#x27;猛龙摆尾&#x27;&#125;const mangseng = &#123;...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;console.log(mangseng)// ...skillOne   =&gt;  q: &#x27;天音波&#x27;, w: &#x27;金钟罩&#x27;\n\n正则扩展命名捕获分组\n传统方法\n//声明一个字符串let str = &#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;;//提取 url 与 『标签文本』const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\\/a&gt;/;//执行const result = reg.exec(str);console.log(result);console.log(result[0]);console.log(result[1]);\n\n\n\n命名捕获分组\nlet str = &#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;;//分组命名const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\/a&gt;/;const result = reg.exec(str);console.log(result.groups.url);console.log(result.groups.text);\n\n\n\n\n反向断言（判断）//声明字符串let str = &#x27;JS5211314你知道么555啦啦啦&#x27;;//正向断言const reg = /\\d+(?=啦)/;      //根据后边内容判断前面内容是否合法const result = reg.exec(str);//反向断言const reg = /(?&lt;=么)\\d+/;     //根据前边内容判断后面内容是否合法const result = reg.exec(str);console.log(result);\n\ndotAll模式//dot  .  元字符  除换行符以外的任意单个字符let str = `    &lt;ul&gt;        &lt;li&gt;            &lt;a&gt;肖生克的救赎&lt;/a&gt;            &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a&gt;阿甘正传&lt;/a&gt;            &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;        &lt;/li&gt;    &lt;/ul&gt;`;//声明正则//const reg = /&lt;li&gt;\\s+&lt;a&gt;(.*?)&lt;\\/a&gt;\\s+&lt;p&gt;(.*?)&lt;\\/p&gt;/;const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/gs;//执行匹配// const result = reg.exec(str);let result;let data = [];while(result = reg.exec(str))&#123;data.push(&#123;title: result[1], time: result[2]&#125;);&#125;//输出结果console.log(data);\n\n","categories":["ES6"],"tags":["ES9"]},{"title":"JS基础（一）：基本语法","url":"/2022/03/08/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"编写位置\nonclick属性中\n&lt;button onclick=&quot;alert(&#x27;xxxxxxxxx&#x27;);&quot;&gt;&lt;/button&gt;\n\nhref属性中\n&lt;a href=&quot;javascript:alert(&#x27;xxxxxxxxx&#x27;);&quot;&gt;&lt;/a&gt;\n\nscript标签中\n&lt;script type=&quot;text/javascript&quot;&gt;    alert(&#x27;警告窗口&#x27;);    document.write(&quot;在页面输出一个内容&quot;);    console.log(&quot;向控制台输出一个内容&quot;);&lt;/script&gt;\n\n外部js文件中\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt;&lt;!--script标签一旦用于引入外部文件，其内部就不能再写代码了--&gt;\n\n基本语法\n声明变量：var a;\n声明+赋值：var a &#x3D; 0;\n\n标识符：自主命名的（如变量名、函数名、属性名）\n\n命名规则：\n标识符中可含有字母、数字、_、$\n标识符不能以数字开头\n标识符不能是ES中的关键字或保留字\n标识符一般次啊用驼峰命名法\n首字母小写，每个单词开头字母大写，其余字母小写\n\n\n\n\n\n\n字符串：双引号或单引号都可以，但不要混用\n\ntypeof检查变量类型\nconsole.log(typeof a);\n\nNumber类型\n\nNumber.MAX_VALUE 最大值\nNumber.MIN_VALUE 最小正值\nInfinity 正无穷\n-Infinity 负无穷\nNaN 特殊数字，表示Not A Number\n\n\n\nNull类型\n\n表示空对象\ntypeof检查null时，返回object\n\n\nUndefined类型\n\n当声明一个变量，但没有给它负值时，它的值为undefined\n\n\n强制类型转换\n\n将其它数据类型转换为String\n\ntoString()    注：null和undefined没有此方法\n调用String()函数   注：null和undefined可用此方法\n\n\n将其它数据类型转换为Number\n\n调用Number()函数\n\n字符串 –&gt; 数字\n纯数字字符串 - 数字\n存在非数字 - NaN\n空串或全空格 - 0\n\n布尔 –&gt; 数字\ntrue - 1\nflase -0\n\nnull –&gt; 数字 0\n\nundefined –&gt; 数字 0\n\n\n\n调用parseInt()函数  将字符串转换为一个整数：\n​    可将字符串中有效的整数取出（即存在非数字也可以）\n​    在parseInt()中传递第二个参数，来指定数字的进制\n调用parseFloat()函数  将字符串转换为一个浮点数：\n​    可将字符串中有效的小数取出（即存在非数字也可以）\n若对非String使用以上函数，则先将其转换为String再操作\n\n\n\n将其它数据类型转换为Boolean\n\n调用Boolean()函数\n\n数字 –&gt; 布尔\n除了0和NaN，其余都是true\n\n字符串 –&gt; 布尔\n除了空串，其余都是true\n\nnull和undefined都会转为false\n\n对象也会转换为true\n\n\n\n对任意数据类型做两次非运算\n\n\n\n\n\n逻辑运算符\n\n！非   &amp;&amp;与  ||或\n\n\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"HTML基础（四）：表单","url":"/2022/03/05/HTML%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95/","content":"\n表单用于将本地的数据提交给服务器\n\n\nform 创建表单\n\n属性：\n\naction 提交的服务器地址\n\n\n表单项：\n\ninput （自结束标签）\n\ntype&#x3D;”text” 文本框\n数据要提交服务器，必须为元素指定name值（相当于变量）\nname&#x3D;”username”\nvalue&#x3D;”xxx” 默认值\nautocomplete&#x3D;”off” 自动补全（可直接放在form属性中）\nrendonly 将表单项设置为只读，数据会提交\ndisable 将表单项设置为禁用，数据不会提交\nautofucus 自动获取焦点，刷新时光标出现\n\ntype&#x3D;”password” 密码框\nname&#x3D;”userpsword”\n\ntype&#x3D;”radio” 单选按钮（选择框）\nname&#x3D;”hello”\n&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;b&quot; checked&gt;&lt;!--有相同属性name才能单选--&gt;\n\nvalue&#x3D;”a” 指定选择的值（相当于变量值，选择哪个提交时hello就等于哪个值）\nchecked 默认选中\n\ntype&#x3D;”checkbox” 多选按钮（选择框）\n同上\n\ntype&#x3D;”color” 调色板\n\ntype&#x3D;”email” 邮箱、type&#x3D;”tel”手机号 （在移动端比较好用）\n提供提示，一般用js代替此效果\n\ntype&#x3D;”submit”  提交按钮\nvalue&#x3D;”按钮显示名字”\n\ntype&#x3D;”reset” 重置按钮\n将内容改成默认值\n\ntype&#x3D;”button”  普通按钮\n结合js完成提交\n\n\n\nbutton 按钮 （成对标签，可在中间放图片，把图片当作按钮）\n\ntype&#x3D;”submit” 提交按钮\ntype&#x3D;”reset” 重置按钮\ntype&#x3D;”button” 普通按钮\n\n\nselect 下拉列表 \n&lt;select name=&quot;haha&quot;&gt;    &lt;option value=&quot;i&quot;&gt;&lt;/option&gt;    &lt;option selected value=&quot;ii&quot;&gt;&lt;/option&gt;    &lt;option value=&quot;iii&quot;&gt;&lt;/option&gt;&lt;/select&gt;&lt;!--选择哪个提交时hello就等于哪个值--&gt;\n\nselected 默认选中\n\n\n\n\n\n\n","categories":["HTML"],"tags":["HTML","表单"]},{"title":"JS基础（七）：DOM","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9ADOM/","content":"DOM简介\nDOM，全称Document Object Model 文档对象模型\nJS中通过DOM来对HTML文档进行操作\n\n&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;    //获取网页中的button对象：    var btn = document.getElementById(&quot;btn&quot;);    //修改按钮中的文字：    btn.innerHTML = &quot;I&#x27;m Button&quot;;&lt;/script&gt;\n\n事件\n可以为按钮的对应事件绑定处理函数的形式来响应事件\n当事件被触发时，对应函数将会被调用\n\n&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var btn = document.getElementById(&quot;btn&quot;);    //绑定一个单击事件（单击响应函数）    btn.onclick = function()&#123;        alert(&quot;xxxxxxx&quot;);    &#125;;&lt;/script&gt;\n\n\nonload事件\n为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，确保代码执行时所有的DOM对象已经加载完毕\nwindow.onload = function()&#123;    var btn = document.getElementById(&quot;btn&quot;);    //绑定一个单击事件（单击响应函数）    btn.onclick = function()&#123;        alert(&quot;xxxxxxx&quot;);    &#125;;&#125;;\n\nDOM查询\n获取元素节点\n\n通过document对象调用\n\ngetElementById()：通过id属性获取一个元素节点对象\n\ngetElementsByTagName()：通过标签名获取一组元素节点对象，返回类数组对象\n\ngetElementsByName()：通过name属性获取一组元素节点对象\n\ngetElementsByClassName()：通过class属性获取一组元素节点对象\nIE8不兼容\n\nbody：属性，获取body标签对象\n\ndocumentElement：属性，获取html标签对象\n\nall：属性，获取所有元素\n\nquerySelector()：根据CSS选择器（作为参数）来查询一个元素节点对象\n//获取box1类下的divvar div = document.querySelector(&quot;.box1 div&quot;);\n\n局限：使用该方法总会返回唯一一个元素，如果满足条件的有多个元素，只会返回第一个\n\nquerySelectorAll()：根据CSS选择器（作为参数）来查询一组元素节点对象，会将结果封装进数组（即使一个结果也会）\n\n\n\n通过具体元的元素节点调用\n\ngetElementById()：方法，返回当前节点的指定标签名后代节点\n\nchildNodes：属性，表示当前节点的所有子节点\n该属性会获取包括文本节点（包括标签间的空白、换行）在内的所有节点\n注：在IE8及以下浏览器中不会将空白文本当成子节点\n\nchildren：属性，表示当前节点的所有子元素（标签）\n\nfirstChild：属性，表示当前节点的第一个子节点（包括空白文本）\n\nfirstElementChild：属性，表示当前节点的第一个子元素\n兼容性不高\n\nlastChild：属性，表示当前节点的最后一个子节点\n\n\n\n通过具体的节点调用\n\nparentNode：属性，表示当前节点的父节点\npreviousSibling：属性，表示当前节点的前一个兄弟节点（包括空白文本）\npreviousElementSibling：属性，表示当前节点的前一个兄弟元素\nnextSibling：属性，表示当前节点的后一个兄弟节点\n\n\n\n\ninnerHTML：用于获取元素内部的HTML代码\n对于自结束标签没有意义\ninnerText：用于获取元素内部的文本内容（自动将标签去除）\n\n获取元素节点的属性\n直接使用  元素.属性名\neg. 元素.id 元素.name 元素.value\n注：读取class属性时要用 元素.className\n\n\nDOM的增删改\ncreateElement()：创建一个元素节点对象，需要一个标签名作为参数\n\ncreateTextNode()：创建一个文本节点对象，需要一个文本内容作为参数\n\nappendChild()：向一个父节点中添加一个新的子节点\n语法：父节点.appendChild(子节点)；\n另一种方式：父节点.innerHTML +&#x3D; “文本”；\n\ninsertBefore()：在指定的子节点前插入新子节点\n语法：父节点.insertBefore(新节点，旧节点)；\n\nreplaceChild()：使用指定子节点替换已有子节点\n语法：父节点.replaceChild(新节点，旧节点)；\n\nremoveChild()：删除一个子节点\n语法：父节点.removeChild(子节点)；\n常用：子节点.parentNode.removeChild(子节点)；\n\n\nDOM访问元素样式\n修改样式（内联样式）\n语法：元素.style.样式名 &#x3D; 样式值 \n注意：若CSS样式名中含有减号-，则将该样式名改为驼峰命名法（去掉-，将-后的字母大写）\nbox1.style.width=&quot;300px&quot;;box1.style.backgroundColor=&quot;yellow&quot;;\n\n获取元素样式（内联样式）\n语法：元素.style.样式名\n只能读取内联样式，无法读取样式表中的样式\n\n获取元素样式（当前显示的样式，包括内联+样式表）\n\n语法：元素.currentStyle.样式名\n谁生效旧获取谁，如果当前元素没有设置该样式，则返回它的默认值\n缺点：只有IE支持，其它浏览器都不支持，且通过此方法读取的样式只读。\n\n语法：getComputedStyle()  可直接使用\n​            参数1：要获取的元素\n​            参数2：可以传递一个伪元素，一般为null\n该方法会返回一个对象，对象中封装了当前元素对应的样式\nvar obj = getComputedStyle(box1,null);alert(obj.width);\n\n若获取的样式没有设置，则会获取到真实的值，而不是默认值。如没有设置width，它不会返回auto，而是一个数值。\n缺点：IE8不支持，且通过此方法读取的样式只读。\n\n自定义函数，获取指定元素的当前的样式\n参数：obj 要获取样式的元素，name 要获取的样式名\nfunction getStyle(obj,name)&#123;        if(window.getComputedStyle)&#123;        //正常浏览器的方式        return getComputedStyle(obj,null)[name];    &#125;else&#123;        //IE8的方式    \treturn obj.currentStyle[name];    &#125;&#125;\n\n\nclientWidth 属性，获取元素可见宽度（包括内容区和内边距）\nclientHeight 属性，获取元素可见高度（包括内容区和内边距）\n返回值不带单位，均为数字，可直接进行计算，只读不可修改\n\noffsetWidth 属性，获取元素整个宽度 （包括内容区、内边距和边框）\noffsetHeight 属性，获取元素整个高度 （包括内容区、内边距和边框）\n\noffsetParent 属性，获取元素的定位父元素\n获取到里当前元素最近的开启了定位的祖先元素，若所有祖先元素都没开启定位，则返回body\n\noffsetLeft 元素相对于其定位父元素的水平偏移量\noffsetTop 元素相对于其定位父元素的垂直偏移量\n\n\n","categories":["JavaScript"],"tags":["JS","DOM","事件"]},{"title":"JS基础（三）：this和arguments","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Athis%E5%92%8Carguments/","content":"\n在调用函数时，浏览器每次都会传递进两个隐含的参数：\n\n函数的上下文对象this\n封装实参的对象arguments\n\n\nthis\n解析器在调用函数每次都会向函数内部传递进一个隐含的参数，\n这个隐含的参数就是this，this指向的是一个对象，这个对象称为函数执行的上下文对象\n\n\n任何函数本质上都是通过某个对象来调用的\n所有函数内部都有一个变量this\n它的值是调用函数的当前对象\n\n根据函数的调用方式的不同，this会指向不同的对象。\n\n以函数的形式调用时（没有指定对象），this永远都是window\nPerson()   //this是windowvar test = p.setColortest()   //this是windowfunction fun1()&#123;    function fun2()&#123;        console.log(this)    &#125;    fun2()&#125;fun1()     //this是window\n\n以方法的形式调用时，this就是调用方法的那个对象\np.getColor() //this是p\n\n以构造函数的形式调用时，this就是新创建的那个对象\nvar p = new Person() //this是p\n\n以call()和apply()调用时，this是第一个参数指定的那个对象（通过此方法修改this）\nvar obj = &#123;&#125;p.setColor.call(obj,&quot;black&quot;) //this是obj\n\narguments\narguments是一个类数组对象，它也可以通过索引来操作数组，也可获取长度\n在调用函数时，所传递的实参都会在arguments中保存\n因此，即使不定义形参，也可以通过arguments来使用实参\n\n\narguments.length 获取实参的长度\n\narguments[0] 第一个实参\narguments[1] 第二个实参….\n\narguments.callee 该属性对应一个函数对象，即当前正在指向的函数的对象\n\n\n","categories":["JavaScript"],"tags":["JS","this","arguments"]},{"title":"JS基础（九）：BOM","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9ABOM/","content":"BOM简介\nBOM，浏览器对象模型，BOM可以让我们通过JS来操作浏览器\n在BOM中提供了一组对象，用来完成对浏览器的操作\n\n\nBOM对象：\n\nWindow\n\n代表整个浏览器的窗口，同时window也是网页中的全局对象\n\n\nNavigator\n\n代表当前浏览器信息，通过该对象可识别不同浏览器\n由于历史原因，Navigator中的大部分属性都已经无法帮助我们识别浏览器了\n一般使用userAgent来判断浏览器的信息\n\n\nLocation\n\n代表当前浏览器的地址栏信息，通过该对象可操作浏览器跳转页面\n\nassign() 跳转到其它页面，作用和直接修改location一样\n\nreload() 重新加载当前页面，作用和刷新按钮一样\n若在方法中传递true作为参数，则会强制情况缓存刷新界面\n\nreplace() 跳转到其它页面，不会生成历史记录，不能使用回退按钮\n\n\n\nHistory\n\n代表浏览器的历史记录\n由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前翻页或向后翻页，且该操作只在档次访问时有效\nlength属性，获取到当前访问的链接数量\nback() 回退到上一个页面\nforward() 跳转下一个页面\ngo() 跳转到指定页面，需要整数作为参数\n\n\nScreen\n\n代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息\n\n\n\n\nBOM对象在浏览器中都是作为window对象的属性保存的，可通过window对象来使用，也可以直接使用\n\n\n\n","categories":["JavaScript"],"tags":["JS","BOM"]},{"title":"JS基础（二）：对象和函数","url":"/2022/03/08/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0/","content":"对象什么是对象？\n多个数据的封装体\n用来保存多个数据的容器\n一个对象代表现实中的一个事物\n\n为什么要用对象？\n统一管理多个数据\n\n对象的组成\n属性：属性名（字符串，允许不写引号）和属性值（任意数据类型）组成\n方法：一种特别的属性（属性值是函数）\n\n如何访问对象的内部数据？\n.属性名 常用，但有时不能用\n\n[&#39;属性名&#39;]  不常用，但任何情况下都能用\n\n什么时候必须用[&#39;属性名&#39;] \n\n属性名包含特殊字符：- 空格\n属性名不确定\n\nvar p=&#123;&#125;//1.给p对象添加一个属性：content-type:text/jsonp[&#x27;content-type&#x27;]=&#x27;text/json&#x27;console.log(p[&#x27;content-type&#x27;])//2.属性名不确定var propName = &#x27;myAge&#x27;var valve = 18// p.propNa = value //不能用p[propName] = valueconsole.log(p[propName])\n\n\n\n对象的分类内建对象\n由ES标准定义的对象，在任何的ES的实现中都可以使用\n比如Date、Math、String、Number、Boolean、Function、Object……\n\n宿主对象\n由JS的运行环境提供的对象，目前来说主要指由浏览器提供的对象\n比如BOM、DOM（一组对象）\n\n自定义对象\n由开发任意自己创建的对象\n\n\n创建对象\n\nvar obj &#x3D;  new Object();\n\nvar obj &#x3D; {\n​    name:”猪八戒”,\n​    age:28,\n​    test:{name:”沙和尚”}\n};\n\n\n\n添加属性\n\nobj.name &#x3D; “孙悟空”;\n\n属性值可以是任何数据类型，也可是函数（即对象的方法）\nobj.sayName &#x3D; function(){\n​        console.log(obj.name)；\n};\n调用对象的方法：obj.sayName();\n\n\n\n删除属性\n\ndelete obj.name;\n\n\nin 运算符：可检查一个对象中是否由指定的属性\n语法：”属性名” in 对象\n示例：console.log(“name” in obj);\n\nfor … in 语句：枚举对象中的属性\n语法：for(var 变量 in 对象) {  }\n示例：for(var n in obj){\n​                    console.log(“属性名：”+n);\n​                    console.log(“属性值：”+obj[n]);\n​            }\n\n\n函数什么是函数？\n函数也是一种对象\n\n\n函数：具有特定功能的n条语句的封装体\n只有函数是可以执行的，其它类型的数据不能执行\n\n为什么要用函数？\n提高代码复用\n便于阅读交流\n\n如何定义函数？\n创建函数\n\nvar fun &#x3D; new Function()  少用\n\n使用函数声明：\nfunction 函数名([形参1，形参2…形参N]){\n​        语句…\n}\n最后不用写分号\n函数内部还可以在声明函数\n\n使用函数表达式：（var 函数名 &#x3D; 匿名函数）\nvar 函数名 &#x3D; function([形参1，形参2…形参N]){\n​        语句…\n}；\n注意结尾要写分号\n\n\n\n形参与实参\n\n声明形参相当于在函数内部声明了对于变量，但是没有赋值\n\n调用时指定实参，实参会赋值给函数中对应的形参\nfunction sum(a,b)&#123;    console.log(a+b);&#125;sum(1,2);\n\n调用函数时解析器不会检查实参类型、数量\n\n实参可以是一个对象，也可以是一个函数\nfunction sayHello(o)&#123;    console.log(&quot;我是&quot;+o.name);&#125;function fun(a)&#123;    a(obj);&#125;fun(sayHello);\n\n形参为匿名函数 (在开发中常见)\nfunction fun(a)&#123;    a(obj);&#125;fun(function()&#123;alert(&quot;hello&quot;)&#125;);\n\n\n返回值\n\nreturn xxx；\n可以是任意的数据类型，也可以是对象，也可以是函数\n\n\n\n如何调用（执行）函数？\ntest()：直接调用\n\nobj.test()：通过对象调用\n\nnew test()：new调用\n\ntest.call(obj)&#x2F;apply(obj)：相当于obj.test()，可以让一个函数成为指定任意对象的方法进行调用\nvar obj = &#123;&#125;function test()&#123;\tthis.xxx = &#x27;atguigu&#x27;&#125;//相当于obj.test() 不能直接调用，根本就没有test.call(obj)   //相当于obj.test()console.log(obj.xxx) //&#x27;atguigu&#x27;\n\n回调函数什么函数是回调函数？\n自己定义的、自己没有调用、但最终执行了（某个时刻或某个条件下）\n\n常见的回调函数\ndom事件回调函数（this是发生事件的dom元素）\ndocument.getElement(&#x27;btn&#x27;).onclick = function()&#123;    alert(this.innerHTML)&#125;\n\n定时器回调函数（this是window）\n//超时定时器、循环定时器setTimeout(function()&#123;    alert(&#x27;到点了&#x27;)&#125;,2000)\n\najax请求回调函数\n\n生命周期回调函数\n\n\n立即执行函数（IIFE，Immediately-Invoked Function Expression）\n立即执行函数：函数定义完，立即被调用（别名：匿名函数自调用）\n立即执行函数往往只会执行一次\n\n//直接这样写会报错function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;//加括号表示它是一个整体，则不会报错，但不会执行(function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;)//立即执行函数(function()&#123;\talert(&quot;我是一个匿名函数&quot;);&#125;)();//立即执行函数（带参数）(function()&#123;\tconsole.log(&quot;a=&quot;+a);    console.log(&quot;b=&quot;+b);&#125;)();\n\n\n作用：\n\n隐藏实现\n\n不会污染外部（全局）命名空间\n\n用它来编写js模块\n(function ()&#123;    var a = 3    console.log(a+3)&#125;)()var a = 4console.log(a);(function ()&#123;    var a = 1    function test()&#123;        console.log(++a)    &#125;    window.$ = function()&#123;        return &#123;            test:test        &#125;    &#125;&#125;)()$().test() //2\n\n\n\n作用域\n作用域：指一个变量的作用范围\n在JS中一共有两种作用域：全局作用域、函数作用域\n\n全局作用域\n直接在script标签中的JS代码，都在全局作用域\n全局作用域在打开时创建，在页面关闭时销毁\n全局作用域中有一个全局对象window，它代表浏览器的窗口\n在全局作用域中：\n​    创建的变量都会作为window对象的属性保存\n​    创建的函数都会作为window对象的方法保存\n\n函数作用域\n调用函数时创建函数作用域，函数执行完毕后函数作用域销毁\n每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的\n在函数作用域中要访问同名的全局作用域属性a，可用window.a\n\n对象创建模式使用Object构造函数创建对象\n套路：先创建空Object对象，再动态添加属性&#x2F;方法\n适用场景：起始时不确定对象内部数据\n问题：语句太多（使用对象字面量模式解决）\n\nvar p = new Object()p.name = &#x27;Tom&#x27;p.age = 12p.setName = function(name)&#123;    this.name = name&#125;\n\n使用对象字面量创建对象\n套路：使用{}创建对象，同时指定属性&#x2F;方法\n适用场景：起始时对象内部数据是确定的\n问题：如果创建多个对象，有重复代码（使用工厂模式解决）\n\nvar p = &#123;    name = &#x27;Tom&#x27;    age = 12    setName = function(name)&#123;        this.name = name    &#125;&#125;\n\n使用工厂方法创建对象\n批量创建对象\n\n\n套路：通过工厂函数创建对象并返回\n适用场景：需要创建多个对象\n问题：对象没有一个具体的类型，都是Object类型（使用自定义构造函数解决）\n\nfuction createPerson(name, age, gender)&#123;    var obj = new Object();        obj.name = name;    obj.age = age;    obj.gender = gender;    obj.sayName = function()&#123;        alert(this.name);    &#125;;        return obj;&#125;var obj1 = createPerson(&quot;孙悟空&quot;,18,&quot;男&quot;);var obj2 = createPerson(&quot;猪八戒&quot;,28,&quot;男&quot;);\n\n\n使用工厂方法创建的对象，使用的构造函数都是Object，所创建的对象都是Object类型，导致无法区分出多种不同类型的对象\n\n使用自定义构造函数创建对象\n套路：自定义构造函数，通过new创建对象\n适用场景：需要创建多个类型确定的对象\n问题：每个兑现都有相同的数据，浪费内存（使用构造函数+原型解决）\n\n\n构造函数和普通函数的区别就调用方式的不同\n普通函数直接调用，构造函数需要使用new关键词调用\n构造函数执行流程：\n​    1.立刻创建一个新的对象\n​    2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象\n​    3.逐行执行函数中的代码\n​    4.将新建的对象作为返回值返回\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;    this.sayName = function()&#123;        alert(this.name);    &#125;;&#125;var per = new Person(&quot;孙悟空&quot;,18,&quot;男&quot;);function Dog(name, age)&#123;    this.name = name;    this.age = age;    this.sayName = function()&#123;        alert(this.name);    &#125;;&#125;var dog = new Dog(&quot;小白&quot;,5);\n\n\n使用同一个构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类\n将通过一个构造函数创建的对象称为该类的实例\n\n使用instanceof可以检查一个对象是否是一个类的示例\n\n语法：对象 instanceof 构造函数\n示例：console.log(dog instanceof Person)      False\n\n\n构造函数每执行一次就会创建一个新的sayName方法，所有实例的sayName都是唯一的。为了提高性能，可将sayName在全局作用域定义。\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;    this.sayName = fun;    &#125;;&#125;function fun()&#123;    alert(this.name);&#125;\n\n\n但将函数定义在全局作用域，污染了全局作用域的命名空间，且不安全（容易被覆盖）\n因此可以将将sayName在原型对象里定义\n\n构造函数+原型的组合模式\n套路：自定义构造函数，属性再函数中初始化，方法添加到原型上\n适用场景：需要创建多个类型确定的对象\n\nfunction Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n原型对象\n我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象称原型对象\n\n\n若函数以普通函数的形式调用，prototype没有任何作用\n若函数以构造函数的形式调用，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可通过___proto__来访问该属性\n\n\nconsole.log(mc.__proto__ == MyClass.prototype);//返回true\n\n\n原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象。\n因此，创建构造函数时，可将对象中共有的属性和方法统一设置到原型对象中。（不用为每个对象创建属性，也不会影响到全局作用域）\n当访问对象的一个属性或方法时，会先在对象自身中寻找，若没有则会去原型对象中寻找。\n（若再没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined。\n\nfunction Person()&#123;    &#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n\n使用in检查对象中是否有某属性时，如果对象中没有但原型中有，也会返回true\n可使用对象的hasOwnProperty()来检查对象自身中是否有该属性\n\n","categories":["JavaScript"],"tags":["JS","对象","函数"]},{"title":"JS基础（五）：函数的方法call和apply","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95call%E5%92%8Capply/","content":"\ncall()和apply()，这两个方法都是函数对象的方法，需要通过函数对象来调用\n\nfunction fun()&#123;    alert(&quot;我是fun函数&quot;);&#125;//以下三者效果相同fun.call();fun.aplly();fun();\n\n\n在调用call()和apply()时，可以将一个对象指定为第一个参数\n此时这个对象将会成为函数执行时的this\n因此，利用call()和apply()可修改this\n\n\ncall()方法可以将实参在对象之后依次传递\napply()方法需要将实参封装到一个数组中统一传递\n\nfunction fun(a,b)&#123;    console.log(&quot;a=&quot;+a);    console.log(&quot;b=&quot;+b);&#125;;var obj = &#123;    name:&quot;obj&quot;;    sayName:function()&#123;        alert(this.name);    &#125;&#125;;fun.call(obj,2,3);  //this 为objfun.call(obj,[2,3]); //this 为obj\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"JS基础（八）：事件","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6/","content":"事件对象\n当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数\n事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标、键盘按下的按键、鼠标滚轮滚动的方向\n\n\nonmousemove 该事件会在鼠标在元素中移动时被触发\nareaDiv.onmousemove = function(event)&#123;    //在IE8中，将事件对象作为window对象的属性保存的    //解决兼容问题    if(!event)&#123;        event=window.event;    &#125;    //另一种写法（常用）    event = event || window.event;        var x = event.clientX;    var y = event.clientY;        showMsg.innerHTML = &quot;x=&quot;+x+&quot;,y=&quot;+y;&#125;;\n\n事件的冒泡(Bubble)\n\n\n冒泡：指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发\n在实际开发中大部分情况冒泡时有益的，若不希望发生事件冒泡可以通过事件对象（event）来取消冒泡\n\n将事件对象的cancelBubble设置为true，即可取消冒泡\ns1.onclick = function(event)&#123;    alert(&quot;我是span的单击响应函数&quot;);    event.cancelBubble = true;&#125;\n\n\n\n事件的委派\n希望只绑定一次事件，即可应用到多个元素上，即使元素是后添加的\n委派：将事件统一绑定给元素的共同祖先元素，当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。\n事件委派利用了冒泡，可以减少事件的绑定次数，提高程序性能\n\n\nevent.target 返回触发事件的对象\n\n&lt;ul id=&quot;u1&quot;&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n\nu1.onclick = function()&#123;    //如果触发事件的对象是我们期望的元素，则执行否则不执行    if (event.target.className == &quot;link&quot;)&#123;    \talert(&quot;我是ul的单击响应函数&quot;);    &#125;);\n\n事件的绑定\n使用 对象.事件 &#x3D; 函数 的形式绑定响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，若绑定了多个，则后面的会覆盖掉前面的\n\n\naddEventListener() 此方法也可以为元素绑定响应函数\n参数1：事件的字符串，不要on（click）\n参数2：回调函数，当事件触发时该函数会被调用\n参数3：是否在捕获阶段触发事件，需要一个布尔值，一般都是false\n\n它可同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行。\n这里的this是绑定事件的对象。\n\n\n\nbtn01.addEventListener(&quot;click&quot;,function()&#123;    alert(1);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123;    alert(2);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123;    alert(3);&#125;,false);\n\n​    IE8中不支持以上方法，可使用attachEvent()来绑定事件\n\nattachEvent() \n参数1：事件的字符串，要on （onclick）\n参数2：回调函数\n\n它可同时为一个元素的相同事件同时绑定多个响应函数，执行顺序与addEventListener()相反，先绑定的后执行。\n这里的this是window\n\n\nbind函数：用来为指定元素绑定响应函数\n参数1：obj 要绑定事件的对象\n参数2：eventStr 事件的字符串(不要on)\n参数3：callback 回调函数\nfunction bind(obj,eventStr,callback)&#123;    if(obj.addEventListener)&#123;        //大部分浏览器兼容方式        obj.addEventListener(eventStr,callbak,false);    &#125;else&#123;        /*        * this是谁由调用方式决定，通过call()修改this        * callback.call(obj)        * 但callback是浏览器调用的，可通过匿名函数方式代替        */        //IE8及以下    \tobj.attachEvent(&quot;on&quot;+eventStr,function()&#123;            //在匿名函数中调用回调函数            callback.call(obj);        &#125;);    &#125;&#125;bind(btn01,&quot;click&quot;,function()&#123;    alert(this);&#125;);\n\n拖拽事件\n当我们拖拽网页中的内容是，浏览器会默认区搜索引擎中搜索内容，\n此时会导致拖拽功能的异常，若不希望发生这个行为，则可通过return false来取消默认行为\n\n\n元素.setCapture() 设置当前元素捕获所有鼠标按下的事件\n\n滚轮事件\nonmousewheel 鼠标滚动时触发\nevent.wheelDelta 获取鼠标滚轮滚动的方向\n\n键盘事件\n键盘事件一般会绑定给一些可以获取到焦点的对象或者document\n\n\nonkeydown 按键被按下\n如果一直按着某个键不松，则事件会一直触发。当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其它次会非常快，为了防止误操作的发生。\n在文本框中输入内容属于onkeydown的默认行为，如果在onkeydown中取消了默认行为（return false），则输入的内容不会出现在文本框中。\ninput.onkeydown = function(event)&#123;    event = eventt || window.event;    //使文本框中不能输入数字    if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;=57)&#123;        return false;    &#125;&#125;\n\nonkeyup 按键被松开\n\nevent.keyCode 获取按键的编码\nevent.altKey 判断alt是否被按下\nevent.ctrlKey 判断ctrl是否被按下\nevent.shiftKey 判断shift是否被按下\n\n示例：键盘上下左右移动div\n\n\nwindow.onload = function()&#123;    document.onkeydown = function(event)&#123;        event = event || window.event;        //定义一个变量，来表示移动的速度        var speed = 10;        //37左，38上，39右，40下        switch(event.keyCode)&#123;            case 37:                //向左                box1.style.left = box1.offsetLeft - speed + &quot;px&quot;;                break;            case 39:                //向右                box1.style.left = box1.offsetLeft + speed + &quot;px&quot;;                break;            case 38:                //向上                box1.style.top = box1.offsetLeft - speed + &quot;px&quot;;                break;            case 40:                //向下                box1.style.top = box1.offsetLeft + speed + &quot;px&quot;;                break;        &#125;    &#125;&#125;\n\n","categories":["JavaScript"],"tags":["JS","事件"]},{"title":"JS基础（六）：正则表达式","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"创建正则表达式的对象\n语法：var 变量 &#x3D; new RegExp(“正则表达式”,”匹配模式”)；\ntest() 检查字符串是否符合正则表达式的规则\n\nvar reg = new RegExp(&quot;a&quot;);console.log(reg.test(&quot;a&quot;));  //trueconsole.log(reg.test(&quot;bcabc&quot;));  //trueconsole.log(reg.test(&quot;bcbc&quot;));  //false\n\n\n匹配模式：\ni 忽略大小写\ng 全局匹配模式\n\n\n\nvar reg = new RegExp(&quot;a&quot;,&quot;i&quot;);console.log(reg.test(&quot;A&quot;));  //trueconsole.log(reg.test(&quot;bcAbc&quot;));  //trueconsole.log(reg.test(&quot;bcbc&quot;));  //false\n\n正则语法\n创建正则表达式简单方法(字面量方式)\n语法：var 变量 &#x3D; &#x2F;正则表达式&#x2F;匹配模式\n使用字面量方式创建更加简单，使用构造函数创建更加灵活（因为可以传递正则表达式变量）\n\n\nvar reg = new RegExp(&quot;a&quot;);//相当于如下var reg = /a/i;\n\n\na|b   检查字符串中是否有a或b\n\n[abcd]  检查字符串中是否有a或b或c或d（[]中的内容也是或的关系)\n\n[a-z] 任意小写字母\n[A-Z] 任意大写字母\n[A-z] 任意字母\n\na[bde]c 检查字符串中是否含有abc或ade或aec\n\n[^ac] 含有除了ab的字母\n[^0-9] 除了数字\n\n量词：量词只对它前面的一个内容起作用\n\n{n} 正好连续出现n次\na{3} a连续出现3次\n(ab){3} ab连续出现3次\n\n{m,n} 出现m-n次\n\n{m，} 出现m次以上\n\n+，至少一个，相当于{1，}\n\n*，0个或多个，相当于{0，}\n\n？，0个或一个，相当于{0，1}\n\n\n\n^a 匹配以a开头  （与[^a]区分）\n\na$ 匹配以a结尾\n\n^a$ 完全匹配a\n如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式\n\n^a|a$ 以a开头或以a结尾\n\n示例：\n\n检查一个字符串是否是个合法手机号\n\n\n\n1\n3\n567890123\n\n\n\n以1开头\n第二位3-9\n第三位以后任意数字\n\n\n^1\n[3-9]\n[0-9]{9}$\n\n\nvar phoneStr = &quot;13067890123&quot;;var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneReg.test(phoneStr));\n\n\n.    表示任意字符\n\n检查一个字符串中是否含有. （\\） \nvar reg = /\\./;reg = new RegExo(&quot;\\\\.&quot;);var reg = /\\\\/;reg = new RegExo(&quot;\\\\\\\\&quot;);\n\n\n\\w 表示任意字母、数字、下划线_\n\\W 表示除任意字母、数字、下划线_外\n\n\\d 表示任意的数字\n\\D 表示除了数字\n\n\\s 空格\n\\S 除了空格\n//删除开头的空格str = str.replace(/^\\s*/,&quot;&quot;)//删除结尾的空格str = str.replace(/\\s*$/,&quot;&quot;)//删除开头和结尾的空格str = str.replace(/^\\s*|\\s*$/g,&quot;&quot;)\n\n\\b 单词边界\n\\D 除了单词边界\nreg = /\\bchild\\b/;console.log(reg.test(hello children));//falseconsole.log(reg.test(hello child));//ture\n\n示例：\n\n电子邮件正则表达式\n\n\n\nhello.nihao\n@\nabc.com.cn\n\n\n\n任意字母数字下划线.任意字母数字下划线\n\n任意字母数字.任意字母（2-5位）.任意字母（2-5位）\n\n\n^\\w{3,} (\\.\\w+)*\n@\n[A-z0-9]+ (\\.[A-z]{2,5}){1,2}$\n\n\n\n\nvar emaiReg = /^\\w&#123;3,&#125;(\\\\.\\w+)*@[A-z0-9]+ (\\\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/\n\n\n\n字符串和正则表达式\n\n\nsplit()\n可以将一个字符串拆分为一个数组\n方法中可以传递一个正则表达式作为参数，那么将会根据正则表达式去拆分字符串\n不需要设置全局匹配\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;//根据任意字母将字符串拆分var result = str.split(/[A-z]/);  //输出1，2，3，4，5，6，7\n\n\nsearch()可以搜索字符串中是否有指定内容\n不能设置全局匹配\n\nvar str =&quot;hello abc hello aec afc&quot;;var result = str.search(/a[bef]c/);  \n\n\nmatch()\n可以根据正则表达式，从一个字符串中将符合条件的内容提取出来\nmatch()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;var result = str.match(/[A-z]/); //输出a//全局匹配var result = str.match(/[A-z]/g); //输出a,b,c,d,e,fvar str =&quot;1a2b3c4d5e6f7A8B9C&quot;;//全局匹配+忽略大小写var result = str.match(/[a-z]/ig); //输出a,b,c,d,e,f,A,B,C\n\n\nreplace() \n可将字符串中指定内容替换为新的内容\n参数：\n\n被替换的内容，可接受一个正则表达式作为参数\n新的内容\n\n\nvar str =&quot;1a2b3c4d5e6f7&quot;;var result = str.replace(/[a-z]/ig,&quot;@&quot;); //输出1@2@3@4@5@6@7//删除字母var result = str.replace(/[a-z]/ig,&quot;&quot;); //输出1234567\n\n","categories":["JavaScript"],"tags":["JS","正则表达式"]},{"title":"JS基础（十一）：类的操作","url":"/2022/03/12/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C/","content":"修改class属性//向一个元素中添加指定的class属性值function addClass(obj,cn)&#123;    if(hasClass(obj,cn))&#123;        obj.className += &quot;&quot;+cn;    &#125;&#125;//判断一个元素中是否含有指定的class属性值function hasClass(cn)&#123;    var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;);    return reg.test(obj.className);&#125;//删除一个元素中指定的class属性值function removeClass(obj,cn)&#123;    var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;);    obj.className = obj.className.replace(reg,&quot;&quot;);&#125;//切换class属性值，元素中有该类则删除，没有该类则添加function toggleClass(obj,cn)&#123;    if(hasClass(obj,cn))&#123;        removeClass(obj,cn);    &#125;else&#123;        addClass(obj,cn);    &#125;&#125;\n\n","categories":["JavaScript"],"tags":["JS","class"]},{"title":"JS基础（十二）：JSON","url":"/2022/03/12/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9AJSON/","content":"JSON简介\nJS中的对象只有JS自己认识，其它语言都不认识\nJSON是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON再开发中主要用来数据的交互\nJSON：Javascript Object Notation (JS对象表示法)\n\n\nJSON和JS对象的格式一样，但是JSON字符串中的属性名必须加双引号，其它和JS语法一致\nJSON中允许的值：\n字符串\n数值\n布尔值\nnull\n对象（除了函数对象）\n数组\n\n\n\nJSON分类\n对象 {}\nvar obj = &#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;;\n\n数组 []\nvar arr = &#x27;[1,2,3,&quot;hello&quot;,true]&#x27;;\n\n将JSON字符串转换为JS中的对象\nJS中为我们提供了一个工具类，就叫JSON\n这个对象可以将一个JSON转换为JS对象，也可以将JS对象转换为JSON\nJSON在ie7中不兼容，可用eval()：用来执行一段字符串形式的JS代码，并将执行结果返回，如果字符串中有{}，它会将其当成代码块解析，若不希望，则需要在字符串前后各加一个()。开发中尽量避免使用。还可以通过引入一个外部的js文件来处理，json2.js.\n\njson –&gt; js对象：JSON.parse()\n将json字符串转换为js对象，参数：json字符串\n\njs对象 –&gt; json：JSON.stringify()\n将js对象转换为json字符串，参数：js对象\n\n\n","categories":["JavaScript"],"tags":["JS","JSON"]},{"title":"JS基础（四）：forEach","url":"/2022/03/09/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AforEach/","content":"\nforEach()方法需要一个函数（名）作为参数\nIE8及以下的浏览器均不支持该方法\n\nvar arr=[&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;,&quot;唐僧&quot;,&quot;白骨精&quot;];//一般不这么写arr.forEach(fun);//一般这么写（通过匿名函数）,由浏览器直接调用arr.forEach(function(value,index,obj)&#123;    console.log(&quot;value=&quot;+value);    console.log(&quot;index=&quot;+index);    console.log(&quot;obj=&quot;+obj);&#125;);\n\n\n类似这种由我们创建但不由我们调用的函数，称为回调函数。\n数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来。\n\n浏览器会在回调函数中传递三个参数：\n\n第一个参数，当前正在遍历的元素\n第二个参数，当前正在遍历的元素的索引\n第三个参数，正在遍历的数组本身\n\n","categories":["JavaScript"],"tags":["JS"]},{"title":"JS基础（十）：定时器","url":"/2022/03/11/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/","content":"定时调用\n定时调用，可以使一段程序每隔一段时间执行一次\n\n\nsetInterval() 定时调用\n参数1：回调函数，该函数会每隔一段时间被调用一次\n参数2：每次调用间隔的时间，单位是毫秒\n返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识。\nvar num = 1;var timer = setInterval(function()&#123;    count.innerHTML = num++;    if(num == 11)&#123;        //关闭定时器       clearInterval(timer)    &#125;&#125;,1000);\n\n切换图片练习var img1 = document.getElementById(&quot;img1&quot;);var imgArr = [&quot;img/1.jpg&quot;,&quot;img/2.jpg&quot;,&quot;img/3.jpg&quot;,&quot;img/4.jpg&quot;];var index = 0;setInterval(function()&#123;    index = index % imgArr.length;    img1.src = imgArr[index];&#125;,1000);\n\n延时调用\n延时调用一个函数不马上执行，而是隔一段时间后再执行，且只会执行一次\n延时调用和定时调用实际上是可以相互代替的\n\n\nsetTimeout()\nvar time = setTimeout(function()&#123;    console.    log(num++);&#125;,3000);clearTimeout(timer);\n\n移动（动画）练习\n参数：\nobj：要执行动画的对象\nattr：要执行动画的样式，比如：left top width height\ntarget：执行动画的目标位置\nspeed：移动速度（正数向右，负数向左）\ncallback：回调函数，该函数会在动画执行完毕后执行\n\n\n\nfunction move(obj,attr,target,speed,callback)&#123;    //关闭上一个定时器    clearInterval(obj.timer);    //获取元素目前的位置    var current = parseInt(getStyle(obj,attr));    //判断速度是正负值    if(current&gt;target)&#123;        speed = -speed;    &#125;    //开启一个定时器    //向执行动画的对象中添加一个timer属性，用来保存它自己的定时器标识    obj.timer = setInterval(function()&#123;        var oldValue = parseInt(getStyle(obj,attr));        var newValue = oldValue + speed;        if((speed &lt; 0 &amp;&amp; newValue &lt; target) || (speed&gt;0 &amp;&amp; newValue &gt; target))&#123;            nawValue = target;        &#125;        obj.style[attr]=newValue + &quot;px&quot;;        if(newValue == target)&#123;            //达到目标，关闭定时器            clearInterval(obj.timer);            //动画执行完毕，调用回调函数            callback &amp;&amp; callback();        &#125;    &#125;,30)&#125;//定义一个函数，用来获取指定元素的当前样式//参数：obj 要获取样式的元素，name 要获取的样式名function getStyle(obj,name)&#123;    if(window.getComputedStyle)&#123;        //正常浏览器的方式        return getComputedStyle(obj,null)[name];    &#125;else&#123;        return obj.currentStyle[name];    &#125;&#125;\n\n\n将以上代码单独放在一个js文件中\n\n轮播图练习//点击超链接切换到指定图片//为所有超链接绑定单击响应函数for(var i=0;i&lt;allA.length;i++)&#123;    allA[i].num = i;    allA[i].onlick = function()&#123;        //关闭自动切换的定时器        clearInterval(timer);        //获取点击超链接的索引        index = this.num;        //修改正在选中的a        srtA();         //使用自定义的move函数来切换图片        move(imgList,&quot;left&quot;,-520*index,20,function()&#123;            //动画执行完毕，开启定时器            autoChange();        &#125;);    &#125;;&#125;//自动切换图片autoChange();//创建一个函数，设置选中的afunction setA()&#123;    //判断当前索引是否是最后一张图片    if(index &gt;= imgArr.length -1)&#123;        index =0;        //此时显示最后一张图片，和第一张一模一样        //通过css将最后一张切换成第一张        imgList.style.left = 0;    &#125;    //将所有a的背景颜色设置为红色\tfor(var i=0;i&lt;allA.length;i++)&#123;        allA[i].style.backgoundColor = &quot;&quot;;  //默认为红色    &#125;    //选中的a设置为黑色    allA[index].style.backgroundColor = &quot;blace&quot;;&#125;;var timer;//创建一个函数，用来开启自动切换图片function autoChange()&#123;    //开启定时器     timer = setInterval(function()&#123;        index %= imgArr.length;        move(imgList,&quot;left&quot;,-520*index,20,function()&#123;            //修改导航按钮,回调函数会在每次函数执行完毕后执行            setA()        &#125;);    &#125;,3000);&#125;\n\n","categories":["JavaScript"],"tags":["JS","定时器"]},{"title":"JS提升（一）：浏览器本地存储（WebStorage）","url":"/2022/04/08/JS%E6%8F%90%E5%8D%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88WebStorage%EF%BC%89/","content":"WebStorage(js 本地存储)\n存储内容大小一般支持5MB左右（不同浏览器可能还不一样)\n\n浏览器端通过window.sessionStorage和 window.localstorage属性来实现本地存储机制\n\n相关API：\n\nxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;)\n该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值\n\nxxxStorage.getItem( &#39;key&#39;)\n该方法接受一个键名作为参数，返回键名对应的值\n\nxxxStorage.removeItem( &#39;key&#39;)\n该方法接受一个键名作为参数，并把该键名从存储中删除\n\nXXxStorage.clear()\n该方法会清空存储中的所有数据\n\n\n\n备注\n\nSessionStorage存储的内容会随着浏览器窗口关闭而消失\n\nLocalstorage存储的内容，需要手动清除才会消失\n\nxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem()的返回值是null\n\nJSON.parse(null)的结果依然是null\n\n\n\n\nlocalStorage\n&lt;h2&gt;localStorage&lt;/h2&gt;&lt;button onclick=&quot;saveDate()&quot;&gt;点我保存数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;readDate()&quot;&gt;点我读数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteDate()&quot;&gt;点我删除数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteAllDate()&quot;&gt;点我清空数据&lt;/button&gt;&lt;br/&gt;&lt;script&gt;  let person = &#123;name:&quot;JOJO&quot;,age:20&#125;  function saveDate()&#123;    localStorage.setItem(&#x27;msg&#x27;,&#x27;localStorage&#x27;)    localStorage.setItem(&#x27;person&#x27;,JSON.stringify(person))  &#125;  function readDate()&#123;    console.log(localStorage.getItem(&#x27;msg&#x27;))    const person = localStorage.getItem(&#x27;person&#x27;)    console.log(JSON.parse(person))  &#125;  function deleteDate()&#123;    localStorage.removeItem(&#x27;msg&#x27;)    localStorage.removeItem(&#x27;person&#x27;)  &#125;  function deleteAllDate()&#123;    localStorage.clear()  &#125;&lt;/script&gt;\n\nsessionStorage\n&lt;h2&gt;sessionStorage&lt;/h2&gt;&lt;button onclick=&quot;saveDate()&quot;&gt;点我保存数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;readDate()&quot;&gt;点我读数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteDate()&quot;&gt;点我删除数据&lt;/button&gt;&lt;br/&gt;&lt;button onclick=&quot;deleteAllDate()&quot;&gt;点我清空数据&lt;/button&gt;&lt;br/&gt;&lt;script&gt;  let person = &#123;name:&quot;JOJO&quot;,age:20&#125;  function saveDate()&#123;    sessionStorage.setItem(&#x27;msg&#x27;,&#x27;sessionStorage&#x27;)    sessionStorage.setItem(&#x27;person&#x27;,JSON.stringify(person))  &#125;  function readDate()&#123;    console.log(sessionStorage.getItem(&#x27;msg&#x27;))    const person = sessionStorage.getItem(&#x27;person&#x27;)    console.log(JSON.parse(person))  &#125;  function deleteDate()&#123;    sessionStorage.removeItem(&#x27;msg&#x27;)    sessionStorage.removeItem(&#x27;person&#x27;)  &#125;  function deleteAllDate()&#123;    sessionStorage.clear()  &#125;&lt;/script&gt;\n\n","categories":["JavaScript"],"tags":["WebStorage"]},{"title":"JS高级（一）：数据类型","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"数据类型分类\n基本（值）类型\n\nString：任意字符串\nNumber：任意的数字\nboolean：true&#x2F;false\nundefined：undefined\nnull：null\n\n\n对象（引用）类型:\n\nObject：任意对象(无序)\nvar obj = &#123;    name:&#x27;Tom&#x27;,    age:12&#125;\n\nFunction：一种特别的对象（可以执行）\nfunction test()&#123;    var a = 3&#125;\n\nArray：一种特别的对象（数值下标属性，内部数据是有序的）\nvar arr = [3,&#x27;abc&#x27;]\n\n\n\n判断数据类型\ntypeof\n返回数据类型的字符串表达\n\n可以判断：undefined&#x2F;数值&#x2F;字符串&#x2F;Boolean&#x2F;function\n不能判断：null与object，object和array  (输出均为’object’)\n\n\ninstanceof\n判断对象的具体类型\nAinstanceof B,判断A是否是B的实例对象\n\n&#x3D;&#x3D;&#x3D;\n\n可以判断：undefined &#x2F; null\n\n\n\n//基本（值）类型var aconsole.log(a,typeof a,typeof a===&#x27;undefined&#x27;,a===undefined) //undefined &#x27;undefined&#x27; true truea=3console.log(typeof a===&#x27;number&#x27;) //truea=&#x27;atguigu&#x27;console.log(typeof a===&#x27;string&#x27;) //truea=trueconsole.log(typeof a===&#x27;boolean&#x27;) //truea=nullconsole.log(typeof a,a===null) //&#x27;object&#x27; true//对象（引用）类型var b1 = &#123;    b2:[1,&#x27;abc&#x27;,console.log],    b3:function()&#123;        console.log(&#x27;b3&#x27;)        return function()&#123;            return &#x27;xfzhang&#x27;        &#125;    &#125;&#125;console.log(b1 instanceof Object,b1 instanceof Array) //true falseconsole.log(b1.b2 instanceof Object,b1.b2 instanceof Array) //true trueconsole.log(b1.b3 instanceof Object,b1.b2 instanceof Function) //true trueconsole.log(typeof b1.b2) //&#x27;object&#x27;console.log(typeof b1.b3===&#x27;function&#x27;) //trueconsole.log(typeof b1.b2[2]===&#x27;function&#x27;) //trueb1.b2[2](4)   // 4console.log(b1.b3()())  //xfzhang\n\n相关问题\nundefined和null的区别？【面试题】\n\nundefined：定义了未赋值\nnull：定义了并赋值为null\n\n\n何时要赋值为null？\n\nnull的类型为基本类型，但type时输出为’object‘，看似矛盾\n\n初始赋值：当要定义一个对象时，还未确定其值，可赋初始值为null，表明将要赋值的为一个对象\n\n结束赋值：结束前，让指对象成为垃圾对象（被垃圾回收器回收）\n//起始var b = null  //初始值为null，表明将要赋值为对象…………//确定对象就赋值b = &#123;&#x27;name&#x27;:&#x27;Tom&#x27;,&#x27;age&#x27;:16&#125;//最后b = null  //给b指向的对象成为垃圾对象（被垃圾回收器回收）\n\n\n严格区分变量类型与数据类型？\n\n数据的类型\n\n基本类型\n对象类型\n\n\n变量的类型：变量内存值的类型\n\n基本类型：变量保存是基本类型的数据\n\n引用类型：变量保存的是地址值\nvar c &#x3D; {}\n\n\n\njs是弱类型的语言，变量本身没有类型（声明变量用var）\n\n\n\n\n","categories":["JavaScript"],"tags":["数据类型"]},{"title":"JS高级（七）：内存溢出与内存泄露","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/","content":"内存溢出\n一种程序运行出现的错误\n当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误\n\n内存泄漏\n占用的内存没有及时释放，不会报错\n\n内存泄漏积累多了就容易导致内存溢出\n\n常见的内存泄漏：\n\n意外的全局变量\nfunction fn()&#123;    a = new Array(100000)    //应该用var    console.log(a)&#125;fn()\n\n没有即使清理的计时器或回调函数\nsetInterval(function()&#123;   //启动循环定时器后不清理    console.log(&#x27;-----&#x27;)&#125;,1000)//clearInterval(intervarId)\n\n闭包\nfunction fn1()&#123;    var a = 4    function fn2()&#123;        console.log(++a)    &#125;    return fn2&#125;var f = fn1()f()//f = null\n\n\n\n","categories":["JavaScript"],"tags":["内存溢出","内存泄漏"]},{"title":"JS高级（三）：原型与原型链","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"原型(prototype)函数的prototype属性\n每个函数都有一个prototype属性，它默认指向一个Object空对象（即成为：原型对象）\nconsole.log(Date.prototype,type Date.prototype)function fun()&#123;    &#125;fun.prototype.test = function()&#123;    consolo.log(&#x27;test&#x27;)&#125;console.log(fun.prototype) //默认指向一个Object空对象\n\n原型对象中有一个属性constructor，它指向函数对象\nconsole.log(Date.prototype.constructor===Date)  //trueconsole.log(fun.prototype.constructor===fun)  //true\n\n\n\n\n原型对象\n我们所定义的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象称原型对象\n\n\n若函数以普通函数的形式调用，prototype没有任何作用\n若函数以构造函数的形式调用，它所创建的实例对象中都会有一个隐含的属性，也指向该构造函数的原型对象，可通过___proto__来访问该属性\n\n\nconsole.log(mc.__proto__ == MyClass.prototype);//返回true\n\n\n原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象。\n因此，创建构造函数时，可将对象中共有的属性和方法统一设置到原型对象中。（不用为每个对象创建属性，也不会影响到全局作用域）\n当访问实例对象的一个属性或方法时，会先在实例对象自身中寻找，若没有则会去原型对象中寻找。\n（若再没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined。\n\nfunction Person()&#123;    &#125;Person.prototype.sayName = function()&#123;    alert(this.name);&#125;;\n\n\n使用in检查对象中是否有某属性时，如果对象中没有但原型中有，也会返回true\n可使用对象的hasOwnProperty()来检查对象自身中是否有该属性\n\n给原型对象添加属性(一般是方法)\n作用：函数的所有示例对象自动拥有原型中的属性（方法）\nFun.prototype.test = function()&#123;    consolo.log(&#x27;test()&#x27;)&#125;var fun = new Fun()fun.test()    //输出test()\n\n显式原型和隐式原型\n每个函数function都有一个prototype，即显式原型属性，是在定义函数时自动添加的，默认值是一个空Object对象\n\n每个实例对象都有一个__proto__，即隐式原型属性，是在创建对象时自动添加的，默认值为构造函数的prototype属性值\n\n对象的隐式原型的值为其对应的构造函数的显示原型的值\n\n\n\nfunction Fn()&#123;              //内部语句：this.prototype=&#123;&#125;    &#125;console.log(Fn.prototype)   //显式原型var fn = new Fn()           //内部语句：this.__proto__=Fn.prototypeconsolo.log(fn.__proto__)   //隐式原型console.log(Fn.prototype===fn.__proto__)  //true//给原型添加方法Fn.prototype.test = function()&#123;    consolo.log(&#x27;test()&#x27;)&#125;fn.test()    //输出test()\n\n\n\n程序员能直接操作（添加属性）显式原型，但不能直接操作隐式原型（ES6之前）\n\n原型链\n访问一个对象的属性时\n先在自身属性中查找，找到返回\n如果没有，再沿着__proto__这条链向上查找，找到返回\n如果最终没找到，返回undefined\n\n\n别名：隐式原型链\n作用：查找对象的属性（方法）\n\nfunction Fn()&#123;    this.test1 = function()&#123;        console.log(&#x27;test1()&#x27;)    &#125;&#125;Fn.prototype.test2 = function()&#123;    consolo.log(&#x27;test2()&#x27;)&#125;var fn  = new Fn()fn.test1()                //test1()fn.test2()                //test2()consolo.log(fn.toString())//[object Object]consolo.log(fn.test3)     //undefinedfn.test3()                //报错\n\n\n构造函数&#x2F;原型&#x2F;实例对象的关系\n&#96;&#96;&#96;var o1 &#x3D; new Object()var o2 &#x3D; {}\n  ![](https://cdn.jsdelivr.net/gh/Milky53/image-hosting@master/image.69i2t3bncc00.webp)- ```js  function Foo()&#123;&#125;  //相当于以下代码  var Foo = new Function()  Function = new Function()  Object = new Function()  //所有函数的__proto__都是一样的，指向大写Function的显式原型\n\n\n\n函数的显式原型（prototype）指向的对象默认是空Object实例对象（但Object函数不满足）\nconsole.log(Fn.prototype instanceof Object) //trueconsole.log(Object.prototype instanceof Object) //falseconsole.log(Function.prototype instanceof Object) //true\n\n所有函数都是Function()的实例（包含Function本身，即Function是它自身的实例）\nconsole.log(Function.__proto__ === Function.prototype) //true\n\nObject的原型对象是原型链的尽头\nconsole.log(Object.prototype.__proto__) //null\n\n\n\n原型链的属性问题function Fn()&#123;    &#125;Fn.prototype.a = &#x27;xxx&#x27;    //一般情况下不会在原型上添加属性，而是方法var fn1 = new Fn()consolo.log(fn1.a)var fn2 = new Fn()fn2.a = &#x27;yyy&#x27;consolo.log(fn1.a,fn2.a)\n\n\n读取对象的属性值时：会自动到原型链中查找\n\n设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值\n\n方法一般定义在原型中，属性一般通过构造函数定义在对象本身上\n每个对象都有自己的属性，但方法都在原型里\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;    this.name = name&#125;var p1 = new Pesson(&#x27;Tom&#x27;,12)p1.setName(&#x27;Bob&#x27;)consolo.lof(p1)var p2 = new Pesson(&#x27;Tom&#x27;,12)p2.setName(&#x27;Cat&#x27;)consolo.log(p1)consolo.log(p1.__proto__===p2.__proto__)  //true\n\n探索instanceofinstanceof是如何判断的？\n表达式：A instanceof B\nA是实例对象（有__proto__)，B是构造函数对象（有prototype)\n\n如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false\n\n案例1：\n\n\nfunction Foo()&#123;    &#125;var f1 = new Foo()console.log(f1 instanceof Foo) //trueconsole.log(f1 instanceof Object) //true\n\n\n\n案例2\n\nconsole.log(Object instanceof Function) //trueconsole.log(Object instanceof Object) //trueconsole.log(Function instanceof Function) //trueconsole.log(Function instanceof Object) //truefunction Foo()&#123;&#125;console.log(Object instanceof Foo) //false\n\n\n\n以上这幅图可借助3句话画出：\n所有实例对象的隐式原型就是其构造函数的显式原型\n所有函数的原型对象都是空Object实例对象，Object()除外\n所有函数都是Function()的实例对象，包含Function本身\n\n\n\n面试题\n测试题1\nfunction A()&#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123;    n:2,    m:3&#125;var c = new A()consolo.log(b.n,b.m,c.n,c.m) //1 undefined 2 3\n\n测试题2\nfunction F()&#123;&#125;Object.prototype.a = function()&#123;    console.log(&#x27;a()&#x27;)&#125;Function.prototype.b = function()&#123;    console.log(&#x27;b()&#x27;)&#125;var f = new F()f.a()    //a()f.b()    //报错F.a()    //a()F.b()    //b()\n\n","categories":["JavaScript"],"tags":["原型","原型链"]},{"title":"JS高级（九）：线程机制与事件机制","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","content":"进程与线程进程（process）\n程序的一次执行，它占有一片独有的内存空间\n可通过winodws任务管理器查看进程\n\n线程（thread）\n是进程内的一个独立执行单元\n是程序执行的一个完整流程\n是CPU的最小调度单元\n\n\n相关知识\n应用程序必须运行在某个进程的某个线程上\n一个进程中至少有一个运行的线程：主线程，进程启动过后自动创建\n一个进程中也可以同时运行多个线程，称该程序是多线程运行的\n一个进程内的数据可以供其中的多个线程直接共享\n多个进程之间的数据是不能直接共享的\n线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用\n\n相关问题\n何为多进程与多线程？\n多进程：一个应用程序可以同时开启多个实例运行，比如chrome浏览器可以开很多个\n多线程：在一个进程内，同时有多个线程运行\n\n\n单线程与多线程的区别？\n多线程\n优点\n有效提升CPU的利用率\n\n\n缺点\n创建多线程开销\n线程间切换开销\n死锁与状态同步问题\n\n\n\n\n单线程\n优点：顺序编程简单易懂\n缺点：效率低\n\n\n\n\nJS是单线程的还是多线程的？\njs是单线程运行的\n但使用H5中的Web Workers可以多线程运行\n\n\n浏览器运行时单线程还是多线程？\n多线程\n\n\n浏览器运行时单进程还是多进程？\n有的是多进程：chrome、新版IE\n有的是单进程：老版IE\n\n\n\n浏览器内核\n支撑浏览器运行的最核心的程序\n不同浏览器的内核不同\nChrome，Safari：webkit\nfirefox：Gecko\nIE：Trident\n360，搜狗等国内浏览器：Trident+webkit\n\n\n内核由很多模块组成\n主线程：\njs引擎模块：负责js程序的编译与运行\nhtml，css文档解析模块：负责页面文本的解析\nDOM&#x2F;CSS模块：负责dom&#x2F;css在内存中的相关处理\n布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）\n\n\n分线程：\n定时器模块：负责定时器的管理\n事件响应模块：负责事件的管理\n网络请求模块：负责ajax请求\n\n\n\n\n\n定时器引发的思考\n定时器真的是定时执行的吗？\n\n定时器并不能保证真正定时执行\n\n一般会延迟一丁点（可以接受），也可能延迟很长时间（不能接受）\n\n\n\n定时器回调函数实在分线程执行的吗？\n\n在主线程执行的，因为js是单线程的\n\n\n定时器是如何实现的\n\n事件循环模型\n\n\n\njs是单线程执行的\n如何证明js是单线程的？\nsetTimeout()的回调函数是在主线程执行的\n定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行\n\n\n为什么js要用单线程模式，而不用多线程模式？\nJavaScript的单线程，与它的用途有关\n作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM\n这决定了它只能是单线程（只能有1个线程去更新操作界面），否则会带来很复杂的同步问题\n\n\n代码的分类：\n初始化代码\n回调代码\n\n\njs引擎执行代码的基本流程\n先执行初始化代码：包含一些特别的代码 \n设置定时器（回调函数不执行）\n绑定事件监听（回调函数不执行）\n发送ajax请求\n\n\n后面再某个时刻才会执行回调代码：回调函数（异步执行）\n\n\n\n浏览器的事件循环（轮询）模型\n\n所有代码分类\n初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码\n回调执行代码（异步代码）：处理回调函数\n\n\njs引擎执行代码的基本流程：\n初始化代码&#x3D;&#x3D;》回调代码\n\n\n模型的2个重要组成部分：\n事件（定时器&#x2F;DOM&#x2F;ajax）管理模块\n回调队列\n\n\n模型的运转流程\n执行初始化代码，将事件回调函数交给对应模块管理\n当事件发生时，管理模块会将回调函数及其数据添加到回调队列中\n只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行\n\n\n\n相关概念\n执行栈（execution stack）：所有代码都是再此空间中执行的\n浏览器内核（browser core）：\njs引擎模块（在主线程处理）\n其它模块（在主&#x2F;分线程处理），这里的分线程指的是浏览器的分线程\n\n\n任务队列&#x2F;消息队列&#x2F;事件队列（callback queue）\n事件轮询（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）\n事件驱动模型（event-driven interaction model）：如上图\n请求响应模型（request-response model）\n\nH5 Web Workers(多线程)介绍\nHTML5规范提供了js分线程的实现，取名为：Web Workers\n可以将一些大计算量的代码交由web Worker运行而不冻结用户界面\n但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变JavaScript单线程的本质。\n相关API\nWorker：构造函数，加载分线程执行的js文件\nWorker.prototype.onmessage：\n\n\n\n使用\n创建在分线程执行的js文件\nworker.js\nfunction fibonacci(n)&#123;    return n&lt;=2 ? 1 : fibonacci(n-1)+fibonacci(n-2)&#125;var onmessage = function(event)&#123;    var number = event.data    console.log(&#x27;分线程接收到主线程发送的数据：&#x27;+number)    //计算    var result  = fibonacci(number)    postMessage(result)    console.log(&#x27;分线程向主线程返回数据：&#x27;+result)    //alert(result)   //报错，alert是window的方法，在分线程不能调用&#125;\n\n分线程中的全局对象不再是window，所以在分线程中不能操作DOM\n\n在主线程中的js中发消息并设置回调\nvar input = document.getElementById(&#x27;number&#x27;)document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;    var number = input.value    //创建一个Worker对象    var worker = new Worker(&#x27;worker.js&#x27;)    // 绑定接收消息的监听    worker.onmessage = function(event)&#123;        console.log(&#x27;主线程接收分线程返回的数据：&#x27;+event.data)        alert(event.data)    &#125;    //向分线程发送消息    worker.postMessage(number)    console.log(&#x27;主线程向分线程发送数据：&#x27;+number)&#125;\n\n不足\n慢\n不能跨域加载JS\nworker内代码不能访问DOM（更新UI）\n不是每个浏览器都支持这个新特性\n\n","categories":["JavaScript"],"tags":["事件","线程"]},{"title":"JS高级（二）：数据、变量、内存","url":"/2022/04/17/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%86%85%E5%AD%98/","content":"数据\n数据：存储再内存中代表特定信息的东西，本质上是010101……\n\n\n数据的特点：\n可传递\n可运算\n\n\n内存中所有操作的目标：数据\n算数运算\n逻辑运算\n赋值运算\n运行函数\n\n\n\n内存\n内存：内存条通电以后产生的可存储数据的空间（临时的）\n\n\n内存的产生和死亡：内存条（电路板）&#x3D;&#x3D;》通电&#x3D;&#x3D;》产生内存空间&#x3D;&#x3D;》存储数据&#x3D;&#x3D;》断电&#x3D;&#x3D;》内存空间和数据都消失\n一块小内存的2个数据：\n内部存储的数据\n自身的地址值\n\n\n内存分类：\n栈：全局变量&#x2F;局部变量\n堆：对象\n\n\n\n变量\n变量：可变化的量，由变量名和变量值组成\n\n\n每个变量都对应一块小内存，变量名用来查找对应的内存，变量值即是内存中保存的数据\n\n数据、内存、变量的关系\n内存是用来存储数据的空间\n变量（名）是内存的标识\n\n相关问题\nvar a &#x3D; xxx, a内存中保存的是什么？\n\n若xxx是基本数据，则保存的就是这个数据，var a &#x3D; 3\n\n若xxx是对象，则保存的是对象的地址值，var a &#x3D; {}\n\n若xxx是一个变量，则保存的是xxx的内存内容（可能是基本数据，也可能是地址值）\nvar b = &#x27;abc&#x27;a = b     //a保存的是&#x27;abc&#x27;b = &#123;&#125;a = b     //a保存的是地址值\n\n\n关于引用变量赋值问题\n\n2个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据\nvar obj1 = &#123;name:&#x27;Tom&#x27;&#125;var obj2 = obj1        //obj2保存的是obj1的内存内容，即对象的地址值obj1.name = &#x27;Jack&#x27;console.log(obj2.name) //&#x27;Jack&#x27;function fn(obj)&#123;    obj.name = &#x27;A&#x27;&#125;fn(obj1)console.log(obj2.name) //&#x27;A&#x27;\n\n2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象\nvar a = &#123;age:12&#125;var b = a        a = &#123;name:&#x27;BOB&#x27;,age:13&#125;b.age = 14console.log(b.age,a.name,a.age) //14 &#x27;BOB&#x27; 13function fn(obj)&#123;    obj = &#123;age:15&#125;&#125;fn(a)console.log(a.age) // 13\n\n\n在js调用函数传递变量参数时，是值传递还是引用传递？【面试题】\nvar a = 3function fn(a)&#123;    a = a + 1&#125;fn(a)console.log(a)  //3function fn2(obj)&#123;    console.log(obj.name)&#125;var obj = &#123;name:&#x27;Tom&#x27;&#125;fn2(obj)\n\n\n理解1：都是值（基本数据&#x2F;地址值）传递，即永远传递的是变量的值\n理解2：可能是值传递，也可能是引用传递（当变量值为地址值时，有些面试官会称作引用传递）\n\n\nJS引擎如何管理内存？\n\n内存生命周期\n分配小内存空间，得到它的使用权\n存储数据，可以反复进行操作\n释放当前的小内存空间\n\n\n释放内存\n局部变量：函数执行完自动释放\n对象：先成为垃圾对象&#x3D;&#x3D;》再由垃圾回收器回收\n全局变量：刷新页面也不会被释放\n\n\n\n\n\n","categories":["JavaScript"],"tags":["变量","数据","内存"]},{"title":"JS高级（五）：作用域与作用域链","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/","content":"作用域理解\n就是一块“地盘”，一个代码段所在的区域\n它是静态的（相对于上下文对象），再编写代码时就确定了\n\n分类\n全局作用域\n\n函数作用域\n\n没有块作用域（ES6有了）\nif(true)&#123;    var c = 3&#125;console.log(c)  //Js可以访问，Java不可以，Java有块作用域\n\n作用\n隔离变量，不同作用域下同名变量不会有冲突\n\n\n作用域与执行上下文区别\n区别1\n全局作用域外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时。\n全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建\n函数执行上下文是在调用函数时，函数题代码执行之前创建\n\n\n区别2\n作用域是静态的，只要函数定义好了就一直存在，且不会再变化\n执行上下文是动态的，调用函数时创建，函数调用结束时就会被释放\n\n\n\n联系\n上下文环境（对象）是从属于所在的作用域\n全局上下文环境&#x3D;&#x3D;》全局作用域\n函数上下文环境&#x3D;&#x3D;》对应的函数作用域\n\n作用域链理解\n多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）\n查找变量时就是沿着这个作用域链来查找的\n\n查找一个变量的查找规则\n在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2\n在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3\n再次执行2的相同操作，知道全局作用域，如果还找不到就抛出找不到的异常\n\n面试题\n&#96;&#96;&#96;jsvar x &#x3D; 10function fn(){console.log(x)}function show(f){var x &#x3D; 20f()}show(fn)      &#x2F;&#x2F;输出10  作用域是**静态**的，并不会说放在其他函数里执行而改变作用域的位置- ```js  var fn = function()&#123;      console.log(fn)  &#125;  fn()        //输出fn函数  var obj = &#123;      fn2:function()&#123;          console.log(fn2)      &#125;  &#125;  obj.fn2()   //报错，应该改成console.log(this.fn2)\n\n","categories":["JavaScript"],"tags":["作用域"]},{"title":"JS高级（八）：继承模式","url":"/2022/04/19/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/","content":"原型链继承\n套路：\n定义父类型构造函数\n给父类型的原型添加方法\n定义子类型的构造函数\n创建父类型的对象赋值给子类型的原型\n将子类型原型的构造属性设置为子类型\n给子类型原型添加方法\n创建子类型的对象：可以调用父类型的方法\n\n\n关键：\n子类型的原型为父类型的一个实例对象\n\n\n\n//父类型function Supper()&#123;    this.supProp = &#x27;Supper Property&#x27;&#125;Supper.prototype.showSupperProp = function()&#123;    console.log(this.supProp)&#125;//子类型function Sub()&#123;    this.subProp = &#x27;Sub Property&#x27;&#125;//实现继承:子类型的原型指向父类型的实例对象Sub.prototype = new Supper()//让子类型的原型的constructor指向子类型Sub.prototype.constructor = SubSupper.prototype.showSubProp = function()&#123;    console.log(this.subProp)&#125;var sub = new Sub()sub.showSupperProp()\n\n借用构造函数继承（假继承）\n套路：\n定义父类型构造函数\n定义子类型构造函数\n在子类型构造函数中调用父类型构造\n\n\n关键：\n在子类型构造函数中通用call()调用父类型构造函数\n\n\n\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;function Student(name,age,price)&#123;    Person.call(this,name,age)   //相当于:this.Person(name,age)    this.price = price&#125;\n\n原型链+借用构造函数的组合继承\n套路：\n利用原型链实现对父类型对象的方法继承\n利用call()借用父类型构造函数初始化相同属性\n\n\n\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;    this.name = name&#125;function Student(name,age,price)&#123;    Person.call(this,name,age)   //为了得到属性    this.price = price&#125;Student.prototype = new Person() //为了能看到父类型的方法  Student.prototype.constructor = StudentStudent.prototype.setPrice = function(price)&#123;    this.price = price&#125;var s = new Student(&#x27;Tom&#x27;,24,15000)s.setName(&#x27;Bob&#x27;)s.setPrice(16000)console.log(s.name,s.age,s.price)\n\n","categories":["JavaScript"],"tags":["继承"]},{"title":"JS高级（四）：执行上下文与执行上下文栈","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/","content":"变量提升与函数提升变量(声明)提升\n通过var定义（声明）的变量，在定义语句之前就可以访问到\n值：undefined\n\nconsole.log(b) //输出undefinedvar b = 3//相当于以下代码var bconsole.log(b)b = 3\n\n\n\n函数(声明)提升\n通过function声明的函数，在定义语句之前就可以直接调用\n值：函数定义（对象）\n\nfn2()      //可调用 函数提升fn3()      //不能调用 变量提升function fn2()&#123;    console.log(&#x27;fn2()&#x27;)&#125;var fn3 = function()&#123;    consolo.log(&#x27;fn3()&#x27;)&#125;\n\n执行上下文代码分类（按位置）\n全局代码\n函数（局部）代码\n\n全局执行上下文\n在执行全局代码前将window确定为全局执行上下文\n对全局数据进行预处理：\nvar定义的全局变量&#x3D;&#x3D;》undefined，添加为window的属性\nfunction声明的全局函数&#x3D;&#x3D;》赋值（fun），添加为window的方法\nthis&#x3D;&#x3D;》赋值（window）\n\n\n开始执行全局代码\n\n函数执行上下文\n在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，存在于栈中）\n对局部数据进行预处理：\n形参变量&#x3D;&#x3D;》赋值（实参），添加为执行上下文的属性\narguments&#x3D;&#x3D;》赋值（实参列表），添加为执行上下文的属性\nvar定义的局部变量&#x3D;&#x3D;》undefined，添加为执行上下文的属性\nfunction声明的函数&#x3D;&#x3D;》赋值（fun），添加为执行上下文的方法\nthis&#x3D;&#x3D;》赋值（调用函数的对象）\n\n\n开始执行函数体代码\n\nfunction fn(a1)&#123;    console.log(a1)          //2    console.log(a2)          //undefined    a3()                     //a3()    console.log(this)        //window    console.log(arguments)   //伪数组（2，3）        var a2 = 3    function a3()&#123;        console.log(&#x27;a3()&#x27;)    &#125;&#125;fn(2,3)\n\n执行上下文栈\n在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象\n在全局执行上下文（window）确定后，将其添加到栈中（压栈）\n在函数执行上下文创建后，将其添加到栈中（压栈）\n在当前函数执行完后，将栈顶的对象移除（出栈）\n当所有的代码执行完后，栈中只剩下window\n\n                            //1.进入全局执行上下文var a = 10var bar = function(x)&#123;    var b =5    foo(x+b)                //3.进入fn函数执行上下文&#125;var fn = function(y)&#123;    var c =5    console.log(a+c+y)&#125;bar(10)                     //2.进入bar函数执行上下文\n\n\n面试题\n依次输出什么？整个过程中产生了几个执行上下文？\nconsole.log(&#x27;global begin:&#x27;+i)var i = 1foo(1)function foo(i)&#123;    if(i==4)&#123;        return    &#125;    console.log(&#x27;foo() begin:&#x27;+i)    foo(i+1)    console.log(&#x27;foo() end:&#x27;+i)&#125;console.log(&#x27;global begin:&#x27;+i)\n\n输出：\nglobal begin:undefinedfoo() begin:1foo() begin:2foo() begin:3foo() end:3foo() end:2foo() end:1global begin:1\n\n产生了5个执行上下文\n\n&#96;&#96;&#96;jsfunction a(){}var aconsolo.log(typeof a)  &#x2F;&#x2F;‘function’\n  **函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖**  - ```js  if(!(b in window))&#123;        var b =1  &#125;  console.log(b)    //undefined\n\n​        var没有块级作用域，不管在函数内部还是外部，都会变量提升到window    \n​        var定义的全局变量&#x3D;&#x3D;》undefined，添加为window的属性\n​        b in window &#x3D;&#x3D; true\n\n&#96;&#96;&#96;jsvar c &#x3D; 1function c(c){console.log(c)var c &#x3D; 3}c(2)       &#x2F;&#x2F;报错相当于```jsvar cfunction c(c)&#123;    console.log(c)    var c = 3&#125;c=1c(2)       //报错,提示c不是一个function\n\n函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖\n\n","categories":["JavaScript"],"tags":["执行上下文"]},{"title":"JS高级（六）：闭包","url":"/2022/04/18/JS%E9%AB%98%E7%BA%A7%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85/","content":"闭包理解如何产生闭包？\n当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（或函数）时，就产生了闭包\n\n闭包是什么？\n使用chrome调试查看\n理解一：闭包是嵌套的内部函数（大部分人理解）\n理解二：包含被引用变量（函数）的对象（少数人理解）\n注意：闭包存在于嵌套的内部函数中\n\n产生闭包的条件？\n函数嵌套\n内部函数引用了外部函数的数据（变量&#x2F;函数）\n执行外部函数（本质上是执行内部函数定义，创建内部函数对象&#x3D;&#x3D;&gt;创建闭包，但不一定要执行内部函数）\n\nfunction fn1()&#123;    var a=2    var b=&#x27;abc&#x27;    function fn2()&#123;        console.log(a)    &#125;&#125;fn1()     //闭包产生了\n\nfunction fn1()&#123;    var a=2    var b=&#x27;abc&#x27;    var fn2 = function()&#123;        console.log(a)    &#125;&#125;fn1()     //闭包没有产生\n\n常见的闭包\n将函数作为另一个函数的返回值\nfunction fn1()&#123;    var a = 2    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()   //执行fn1()的同时创建了一个闭包对象，并赋值给ff() //3f() //4\n\n执行fn1()，返回fn2指向的函数对象，创建了一个闭包对象，并将函数（闭包）的地址赋值给f。\n虽然fn1执行结束（断开了fn3的指向函数对象的引用），但闭包一直存在（没有断开f指向函数对象的引用）。\n又因为闭包包含着被引用变量（函数），所以可以操作引用变量的值。\n\n将函数作为实参传递给另一个函数调用\nfunction showDelay(msg,time)&#123;    setTimeout(function()&#123;        alert(msg)    &#125;,time)&#125;showDelay(&#x27;atguigu&#x27;,2000)\n\n闭包的作用\n使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）\n让函数外部可以操作（读写）到函数内部的数据（变量&#x2F;函数）\n\n思考\n函数执行完后，函数内部声明的局部变量是否还存在？\n\n一般不存在\n存在于闭包中的变量才可能存在\n\nfunction fn1()&#123;    var a = 2    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()   //执行fn1()的同时创建了一个闭包对象，并赋值给ff() //3f() //4//如果这么写，则不存在fn1()\n\n执行fn1()，返回fn2指向的函数对象，创建了一个闭包对象，并将函数（闭包）的地址赋值给f。\n虽然fn1执行结束（断开了fn3的指向函数对象的引用），但闭包一直存在（没有断开f指向函数对象的引用）。\n又因为闭包包含着被引用变量（函数），所以可以操作引用变量的值。\n\n在函数外部能直接访问函数内部的局部变量吗？\n\n不能，但是可以通过闭包让外部操作它\n\n\n\n闭包的生命周期\n产生：在嵌套内部函数定义执行完时就产生了（不是在调用）\nfunction fn1()&#123;            var a = 2             //2. 在这一行就可以说闭包已经存在了，因为函数声明提升，内部函数对象已经创建了    function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()    //1.调用\n\nfunction fn1()&#123;            var a = 2                 var fn2 = function()&#123;        a++        console.log(a)    &#125;     //2. 此时在这一行才可以说闭包已经存在了    return fn2&#125;var f = fn1()    //1.调用\n\n\n\n死亡：在嵌套的内部函数成为垃圾对象时\nfunction fn1()&#123;            var a = 2                 function fn2()&#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()    f()f()f = null    //闭包死亡，包含闭包的函数对象成为垃圾对象（引用它的变量不再引用它了）\n\n闭包的应用定义JS模块\nJS模块：具特定功能的js文件\n​               将所有的数据和功能都封装在一个函数内部（私有的）\n​                只向外暴露一个包括n个方法的对象或函数\n​                模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能\n\nmyMoudule.js\nfunction myModule()&#123;    //私有数据    var msg = &#x27;My atguigu&#x27;    //操作数据的函数    function doSomething()&#123;        console.log(&#x27;doSomething() &#x27;+msg.toUpperCase())    &#125;    function doOtherthing()&#123;        console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase())    &#125;    //向外暴露对象（给外部使用的方法）    return &#123;        doSomething:doSomething,        doOtherthing:doOtherthing    &#125;&#125;\n\nindex.html\n&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var module = myModule()    module.doSomething()    module.doOtherthing()&lt;/script&gt;\n\n另一种暴露方法：\nmyMoudule2.js\n(function myModule(window)&#123;    //私有数据    var msg = &#x27;My atguigu&#x27;    //操作数据的函数    function doSomething()&#123;        console.log(&#x27;doSomething() &#x27;+msg.toUpperCase())    &#125;    function doOtherthing()&#123;        console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase())    &#125;    //向外暴露对象（给外部使用的方法）    window.myMoudule2 =  &#123;        doSomething:doSomething,        doOtherthing:doOtherthing    &#125;&#125;)(window)\n\nindex.html\n&lt;script type=&quot;text/javascript&quot; src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    myModule2.doSomething()    myModule2.doOtherthing()&lt;/script&gt;\n\n闭包的缺点及解决缺点\n函数执行完后，函数内的局部变量没有释放，占用内存时间会边长\n容易造成内存泄漏\n\n解决\n能不用闭包就不用\n及时释放：f = null（让内部函数成为垃圾对象–》回收闭包）\n\n面试题\n输出什么？\nvar name = &quot;The Window&quot;;var object = &#123;    name:&quot;My Object&quot;,    getNameFun:function()&#123;        return function()&#123;            return this.name        &#125;;    &#125;&#125;;alert(object.getNemaFunc()());   //The Window\n\nobject.getNemaFunc()是一个函数，执行此函数，因为此时是window调用此函数，相当于：window.object.getNemaFunc()(),因此this为window\n此题不存在闭包：存在函数嵌套，但内部函数没有引用外部函数的数据\n\n输出什么？\nvar name2 = &quot;The Window&quot;;var object2 = &#123;    name2:&quot;My Object&quot;,    getNameFun:function()&#123;        var that = this;        return function()&#123;            return that.name2;        &#125;;    &#125;&#125;;alert(object2.getNemaFunc()());   //My Object\n\nobject.getNemaFunc()是一个函数，执行此函数，因为此时是window调用此函数，相当于：window.object.getNemaFunc()()。\n但是在函数中，var that = this，此时的this为调用getNameFun()的对象object2\n此题存在闭包：存在函数嵌套，且内部函数引用了外部函数的数据\n\n输出什么？（难）\nfunction fun(n,o)&#123;    console.log(o)    return &#123;        fun:function(m)&#123;            return fun(m,n);        &#125;    &#125;&#125;var a = fun(0); a.fun(1); a.fun(2); a.fun(3);  //undefined,0,0,0var b = fun(0).fun(1).fun(2).fun(3);  //undefined,0,1,2var c = fun(0).fun(1); c.fun(2); c.fun(3);  //undefined,0,1,1\n\n","categories":["JavaScript"],"tags":["闭包"]},{"title":"Promise（一）：入门","url":"/2022/04/21/Promise%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8/","content":"1. 预备知识1.1 实例对象与函数对象\n实例对象：new 函数产生的对象，称为实例对象，简称为对象\n函数对象：将函数作为对象使用时，称为函数对象\n\nfunction Fn() &#123; // Fn只能称为函数&#125;const fn = new Fn() // Fn只有new过的才可以称为构造函数//fn称为实例对象console.log(Fn.prototype)// Fn作为对象使用时，才可以称为函数对象Fn.bind(&#123;&#125;) //Fn作为函数对象使用$(&#x27;#test&#x27;) // $作为函数使用$.get(&#x27;/test&#x27;) // $作为函数对象使用\n\n\n()左边是函数，点左边是对象(函数对象、实例对象)\n\n1.2 两种类型的回调函数1. 同步回调\n立即执行，完全执行完了才结束，不会放入回调队列中\n\n数组遍历相关的回调 &#x2F; Promise的executor函数\nconst arr = [1, 3, 5];arr.forEach(item =&gt; &#123; // 遍历回调，同步回调，不会放入队列，一上来就要执行  console.log(item);&#125;)console.log(&#x27;forEach()之后&#x27;)\n\n\n2. 异步回调\n不会立即执行，会放入回调队列中将来执行\n\n定时器回调 &#x2F; ajax回调 &#x2F; Promise成功或失败的回调\n// 定时器回调setTimeout(() =&gt; &#123; // 异步回调，会放入队列中将来执行  console.log(&#x27;timeout callback()&#x27;)&#125;, 0)console.log(&#x27;setTimeout()之后&#x27;)\n\n\n// Promise 成功或失败的回调new Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;console.log(&#x27;value&#x27;, value)&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;, reason)&#125;)console.log(&#x27;----&#x27;)// ----// value 1\n\n\njs 引擎先把初始化的同步代码都执行完成后，才执行回调队列中的代码\n\n1.3 JS中的异常error处理1. 错误的类型Error：所有错误的父类型\nReferenceError：引用的变量不存在\nconsole.log(a) // ReferenceError:a is not defined\n\nTypeError：数据类型不正确\nlet bconsole.log(b.xxx)// TypeError:Cannot read property &#x27;xxx&#x27; of undefinedlet c = &#123;&#125;c.xxx()// TypeError:c.xxx is not a function\n\nRangeError：数据值不在其所允许的范围内\nfunction fn() &#123;  fn()&#125;fn()// RangeError:Maximum call stack size exceeded\n\nSyntaxError：语法错误\nconst c = &quot;&quot;&quot;&quot;// SyntaxError:Unexpected string\n\n2. 错误处理（捕获与抛出）抛出错误：throw error\nfunction something() &#123;  if (Date.now()%2===1) &#123;    console.log(&#x27;当前时间为奇数，可以执行任务&#x27;)  &#125; else &#123; //如果时间为偶数抛出异常，由调用来处理    throw new Error(&#x27;当前时间为偶数，无法执行任务&#x27;)  &#125;&#125;\n\n捕获错误：try ... catch\n// 捕获处理异常try &#123;  something()&#125; catch (error) &#123;  alert(error.message)&#125;\n\n3. 错误对象\nmassage 属性：错误相关信息\nstack 属性：函数调用栈记录信息\n\ntry &#123;  let d  console.log(d.xxx)&#125; catch (error) &#123;  console.log(error.message)  console.log(error.stack)&#125;console.log(&#x27;出错之后&#x27;)// Cannot read property &#x27;xxx&#x27; of undefined// TypeError:Cannot read property &#x27;xxx&#x27; of undefined// 出错之后\n\n\n因为错误被捕获处理了，后面的代码才能运行下去，打印出‘出错之后’\n\n2. Promise的理解和使用2.1 Promise是什么1. 理解Promise\n抽象表达：Promise是JS中进行异步编程的新的解决方案(旧方案是单纯使用回调函数)\n[推荐阅读 js中的同步和异步的个人理解 、【JavaScript】同步与异步-异步与并行-异步运行机制-为什么要异步编程-异步与回调-回调地狱-JavaScript中的异步操作】\n—- 异步编程 ①fs 文件操作 ②数据库操作 ③Ajax ④定时器\n\n具体表达：\n①从语法上看：Promise是一个构造函数，可进行对象的实例化 (自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法)\n②从功能上看：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值\n\n阮一峰的解释：\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果\n从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\nPromise 提供统一的 API，各种异步操作都可以用同样的方法进行处理\n\n\n2. Promise 的状态实例对象promise中的一个属性 PromiseState\nPromiseState的值可以为：pending 未决定的（最开始的状态）、resolved &#x2F; fullfilled 成功、rejected 失败\n\npending 变为 resolved&#x2F;fullfilled\npending 变为 rejected\n\n注意\n\n对象的状态不受外界影响\n只有这两种改变方式（反过来不行），且一个 promise 对象只能改变一次\n一旦状态改变，就不会再变，任何时候都可以得到这个结果\n无论成功还是失败，都会有一个结果数据。成功的结果数据一般称为 value，而失败的一般称为 reason。\n\n3. Promise对象的值实例对象promise的另一个属性 PromiseResult保存着对象（异步任务）成功&#x2F;失败 的值（value&#x2F;reason）\nresolve&#x2F;reject可以修改值\n4. Promise 的基本流程\n\n若状态为resolved，则调用then()方法中的第一个回调函数\n若状态为rejected，则调用then()方法中的第二个回调函数\n\n5. Promise 的基本使用const promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(reason);  &#125;&#125;);\n\nPromise构造函数接受一个函数（执行器函数）作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数value传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数error/reason传递出去。\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\npromise.then(function(value) &#123;  // success&#125;, function(reason) &#123;  // failure&#125;);\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数onResolved()是Promise对象的状态变为resolved时调用第二个回调函数onRejected()是Promise对象的状态变为rejected时调用这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数\n\n一个例子\n// 创建一个新的p对象promiseconst p = new Promise((resolve, reject) =&gt; &#123; // 执行器函数  // 执行异步操作任务  setTimeout(() =&gt; &#123;    const time = Date.now()     // 如果当前时间是偶数代表成功，否则失败    if (time % 2 == 0) &#123;      // 如果成功，调用resolve(value)      resolve(&#x27;成功的数据，time=&#x27; + time)    &#125; else &#123;      // 如果失败，调用reject(reason)      reject(&#x27;失败的数据，time=&#x27; + time)    &#125;  &#125;, 1000);&#125;)p.then(  value =&gt; &#123; // 接收得到成功的value数据 onResolved    console.log(&#x27;成功的回调&#x27;, value)  // 成功的回调 成功的数据，time=1615015043258  &#125;,  reason =&gt; &#123; // 接收得到失败的reason数据 onRejected    console.log(&#x27;失败的回调&#x27;, reason)    // 失败的回调 失败的数据，time=1615014995315  &#125;)\n\n\n.then() 和执行器(executor)同步执行，.then() 中的回调函数异步执行\n\n\n\n2.2 为什么要用 Promise1.指定回调函数的方式更加灵活旧的：必须在启动异步任务前指定\n// 1. 纯回调的形式// 成功的回调函数function successCallback(result) &#123;  console.log(&quot;声音文件创建成功：&quot; + result);&#125;// 失败的回调函数function failureCallback(error) &#123;  console.log(&quot;声音文件创建失败：&quot; + error);&#125;// 必须先指定回调函数，再执行异步任务createAudioFileAsync(audioSettings, successCallback, failureCallback) // 回调函数在执行异步任务（函数）前就要指定\n\npromise：启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)\n// 2. 使用Promiseconst promise = createAudioFileAsync(audioSettings);  // 执行2秒setTimeout(() =&gt; &#123;  promise.then(successCallback, failureCallback) // 也可以获取&#125;, 3000);\n\n2.支持链式调用，可以解决回调地狱问题什么是回调地狱？\n回调函数嵌套调用，外部回调函数异步执行的结果是其内部嵌套的回调函数执行的条件\n\ndoSomething(function(result) &#123;  doSomethingElse(result, function(newResult) &#123;    doThirdThing(newResult, function(finalResult) &#123;      console.log(&#x27;Got the final result:&#x27; + finalResult)    &#125;, failureCallback)  &#125;, failureCallback)&#125;, failureCallback)\n\n回调地狱的缺点？\n不便于阅读\n不便于异常处理\n\n解决方案？\npromise 链式调用\n\n使用 promise 的链式调用解决回调地狱\ndoSomething()  .then(result =&gt; doSomethingElse(result))  .then(newResult =&gt; doThirdThing(newResult))  .then(finalResult =&gt; &#123;console.log(&#x27;Got the final result:&#x27; + finalResult)&#125;)  .catch(failureCallback)\n\n2.3 Promise初体验1.抽奖案例使用传统回调函数实现&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;基本使用&lt;/title&gt;    &lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h2 class=&quot;page-header&quot;&gt;Promise 初体验&lt;/h2&gt;        &lt;button class=&quot;btn btn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        //生成随机数        function rand(m,n)&#123;            return Math.ceil(Math.random() * (n-m+1)) + m-1;        &#125;        /**            点击按钮,  1s 后显示是否中奖(30%概率中奖)                若中奖弹出    恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券                若未中奖弹出  再接再厉        */        //获取元素对象        const btn = document.querySelector(&#x27;#btn&#x27;);        //绑定单击事件        btn.addEventListener(&#x27;click&#x27;, function()&#123;            //定时器            setTimeout(() =&gt; &#123;                //30%  1-100  1 2 30                //获取从1 - 100的一个随机数                let n = rand(1, 100);                //判断                if(n &lt;= 30)&#123;                    alert(&#x27;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券&#x27;);                &#125;else&#123;                    alert(&#x27;再接再厉&#x27;);                &#125;            &#125;, 1000);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n使用Promise实现&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;基本使用&lt;/title&gt;    &lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;h2 class=&quot;page-header&quot;&gt;Promise 初体验&lt;/h2&gt;        &lt;button class=&quot;btn btn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        //生成随机数        function rand(m,n)&#123;            return Math.ceil(Math.random() * (n-m+1)) + m-1;        &#125;        /**            点击按钮,  1s 后显示是否中奖(30%概率中奖)                若中奖弹出    恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券                若未中奖弹出  再接再厉        */        //获取元素对象        const btn = document.querySelector(&#x27;#btn&#x27;);        //绑定单击事件        btn.addEventListener(&#x27;click&#x27;, function()&#123;            //Promise 形式实现            // resolve 解决  函数类型的数据            // reject  拒绝  函数类型的数据            const p = new Promise((resolve, reject) =&gt; &#123;                setTimeout(() =&gt; &#123;                    //30%  1-100  1 2 30                    //获取从1 - 100的一个随机数                    let n = rand(1, 100);                    //判断                    if(n &lt;= 30)&#123;                        resolve(n); // 将 promise 对象的状态设置为 『成功』                    &#125;else&#123;                        reject(n); // 将 promise 对象的状态设置为 『失败』                    &#125;                &#125;, 1000);            &#125;);            console.log(p);            //调用 then 方法            // value 值            // reason 理由            p.then((value) =&gt; &#123;                alert(&#x27;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 &#x27; + value);            &#125;, (reason) =&gt; &#123;                alert(&#x27;再接再厉, 您的号码为 &#x27; + reason);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n2.fs读取文件使用传统回调函数实现const fs = require(&#x27;fs&#x27;);//回调函数 形式fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123;    // 如果出错 则抛出错误    if(err)  throw err;    //输出文件内容    console.log(data.toString());&#125;);\n\n使用Promise实现const fs = require(&#x27;fs&#x27;);//Promise 形式let p = new Promise((resolve , reject) =&gt; &#123;    fs.readFile(&#x27;./resource/content.tx&#x27;, (err, data) =&gt; &#123;        //如果出错        if(err) reject(err);        //如果成功        resolve(data);    &#125;);&#125;);//调用 then p.then(value=&gt;&#123;    console.log(value.toString());&#125;, reason=&gt;&#123;    console.log(reason);&#125;);\n\n3.Ajax请求使用传统方式实现//接口地址 https://api.apiopen.top/getJokebtn.addEventListener(&#x27;click&#x27;, function()&#123;    //1.创建对象    const xhr = new XMLHttpRequest();    //2. 初始化    xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;);    //3. 发送    xhr.send();    //4. 处理响应结果    xhr.onreadystatechange = function()&#123;        if(xhr.readyState === 4)&#123;            //判断响应状态码 2xx               if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                //控制台输出响应体                resolve(xhr.response);            &#125;else&#123;                //控制台输出响应状态码                reject(xhr.status);            &#125;        &#125;    &#125;&#125;);\n\n使用Promise实现//接口地址 https://api.apiopen.top/getJokebtn.addEventListener(&#x27;click&#x27;, function()&#123;    //创建 Promise    const p = new Promise((resolve, reject) =&gt; &#123;        //1.创建对象        const xhr = new XMLHttpRequest();        //2. 初始化        xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;);        //3. 发送        xhr.send();        //4. 处理响应结果        xhr.onreadystatechange = function()&#123;            if(xhr.readyState === 4)&#123;                //判断响应状态码 2xx                   if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                    //控制台输出响应体                    resolve(xhr.response);                &#125;else&#123;                    //控制台输出响应状态码                    reject(xhr.status);                &#125;            &#125;        &#125;    &#125;);    //调用then方法    p.then(value=&gt;&#123;        console.log(value);    &#125;, reason=&gt;&#123;        console.warn(reason);    &#125;);&#125;);\n\n4. Promise封装fs读取文件操作/** * 封装一个函数 mineReadFile 读取文件内容 * 参数:  path  文件路径 * 返回:  promise 对象 */function mineReadFile(path)&#123;    return new Promise((resolve, reject) =&gt; &#123;        //读取文件        require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt;&#123;            //判断            if(err) reject(err);            //成功            resolve(data);        &#125;);    &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123;    //输出文件内容    console.log(value.toString());&#125;, reason=&gt;&#123;    console.log(reason);&#125;);\n\n5. util.promisify方法进行promise风格化\n将传统异步回调函数转化成Promise风格函数\n\n/** * util.promisify 方法 *///引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123;    console.log(value.toString());&#125;);\n\n6. Promise封装Ajax请求/*** 封装一个函数 sendAJAX 发送 GET AJAX 请求* 参数   URL* 返回结果 Promise 对象*/function sendAJAX(url)&#123;    return new Promise((resolve, reject) =&gt; &#123;        const xhr = new XMLHttpRequest();        xhr.responseType = &#x27;json&#x27;;        xhr.open(&quot;GET&quot;, url);        xhr.send();        //处理结果        xhr.onreadystatechange = function()&#123;            if(xhr.readyState === 4)&#123;                //判断成功                if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;                    //成功的结果                    resolve(xhr.response);                &#125;else&#123;                    reject(xhr.status);                &#125;            &#125;        &#125;    &#125;);&#125;sendAJAX(&#x27;https://api.apiopen.top/getJok&#x27;).then(value =&gt; &#123;    console.log(value);&#125;, reason =&gt; &#123;    console.warn(reason);&#125;);\n\n\n\n2.4 如何使用 Promise （API）1. Promise 构造函数：Promise(executor) &#123;&#125;\nexecutor 函数：同步调用 (resolve, reject) &#x3D;&gt; {}  \n\nresolve 函数：内部定义成功时调用的函数 resove(value)\n\nreject 函数：内部定义失败时调用的函数 reject(reason)\n\n\n说明：executor 是执行器，会在 Promise 内部立即同步回调（即代码运行到时立即执行），异步操作 resolve&#x2F;reject 就在 executor 中执行\nlet p = new Promise((resolve,reject) =&gt; &#123;    console.log(111);&#125;);console.log(222);//先输出111//再输出222\n\n2. Promise.prototype.then 方法：p.then(onResolved, onRejected)指定两个回调（成功+失败）\n\nonResolved 函数：成功的回调函数 (value) &#x3D;&gt; {}\nonRejected 函数：失败的回调函数 (reason) &#x3D;&gt; {}\n\n说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，返回一个新的 promise 对象\n3. Promise.prototype.catch 方法：p.catch(onRejected)指定失败的回调\n1）onRejected 函数：失败的回调函数 (reason) =&gt; &#123;&#125;\n说明：这是then() 的语法糖，相当于 then(undefined, onRejected)\nnew Promise((resolve, reject) =&gt; &#123; // excutor执行器函数 setTimeout(() =&gt; &#123;   if(...) &#123;     resolve(&#x27;成功的数据&#x27;) // resolve()函数   &#125; else &#123;      reject(&#x27;失败的数据&#x27;) //reject()函数    &#125; &#125;, 1000)&#125;).then(value =&gt; &#123; // onResolved()函数      console.log(value) // 成功的数据    &#125;).catch(reason =&gt; &#123; // onRejected()函数      console.log(reason) // 失败的数据    &#125;)\n\n4. Promise.resolve 方法：Promise.resolve(value)value：将被 Promise 对象解析的参数，也可以是一个成功或失败的 Promise 对象\n返回：返回一个带着给定值解析过的 Promise 对象，如果参数本身就是一个 Promise 对象，则直接返回这个 Promise 对象。（返回结果可能是成功的对象，也可能是失败的对象）\n\n如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象\n\nlet p1 = Promise.resolve(521);console.log(p1); // Promise &#123;&lt;fulfilled&gt;: 521&#125;\n\n\n\n如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果\nlet p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123;    // resolve(&#x27;OK&#x27;); // 成功的Promise    reject(&#x27;Error&#x27;);&#125;));console.log(p2);p2.catch(reason =&gt; &#123;    console.log(reason);&#125;)\n\n\n\n\n5. Promise.reject 方法：Promise.resolve(reason)reason：失败的原因\n说明：返回一个失败的 promise 对象(返回结果一直都是失败的对象)\n失败值：传入什么就是什么\nlet p = Promise.reject(521);let p2 = Promise.reject(&#x27;iloveyou&#x27;);let p3 = Promise.reject(new Promise((resolve, reject) =&gt; &#123;    resolve(&#x27;OK&#x27;);&#125;));console.log(p);console.log(p2);console.log(p3);\n\n\n\nPromise.resolve()&#x2F;Promise.reject() 方法就是一个语法糖\n用来快速得到Promise对象\n\n//产生一个成功值为1的promise对象new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)//相当于const p1 = Promise.resolve(1)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)p1.then(value =&gt; &#123;console.log(value)&#125;) // 1p2.then(value =&gt; &#123;console.log(value)&#125;) // 2p3.catch(reason =&gt; &#123;console.log(reason)&#125;) // 3\n\n6. Promise.all 方法：Promise.all(iterable)iterable：包含 n 个 promise 的可迭代对象，如 Array 或 String\n说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败\n成功值：每个promise成功结果组成的数组\n失败值：数组中失败promise的值（多个失败显式第一个失败值）\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;OK&#x27;);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);const result = Promise.all([p1, p2, p3]);console.log(result);\n\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;OK&#x27;);&#125;)let p2 = Promise.reject(&#x27;Error&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);const result = Promise.all([p1, p2, p3]);console.log(result);\n\n\nconst p1 = Promise.resolve(1)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)const pAll = Promise.all([p1, p2, p3])const pAll2 = Promise.all([p1, p2])//因为其中p3是失败所以pAll失败pAll.then(value =&gt; &#123;   console.log(&#x27;all onResolved()&#x27;, value) &#125;,reason =&gt; &#123;   console.log(&#x27;all onRejected()&#x27;, reason)  &#125;)// all onRejected() 3pAll2.then(values =&gt; &#123;   console.log(&#x27;all onResolved()&#x27;, values) &#125;,reason =&gt; &#123;   console.log(&#x27;all onRejected()&#x27;, reason)  &#125;)// all onResolved() [1, 2]\n\n7. Promise.race方法：Promise.race(iterable)iterable：包含 n 个 promise 的可迭代对象，如 Array 或 String\n说明：返回一个新的 promise，第一个完成的 promise 的结果状态就是最终的结果状态谁先完成就输出谁(不管是成功还是失败)\nconst pRace = Promise.race([p1, p2, p3])// 谁先完成就输出谁(不管是成功还是失败)const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;   resolve(1) &#125;, 1000)&#125;)const p2 = Promise.resolve(2)const p3 = Promise.reject(3)pRace.then(value =&gt; &#123;   console.log(&#x27;race onResolved()&#x27;, value) &#125;,reason =&gt; &#123;   console.log(&#x27;race onRejected()&#x27;, reason)  &#125;)//race onResolved() 2\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  &#125;, 1000);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);//调用const result = Promise.race([p1, p2, p3]);console.log(result);\n\n\n3. Promise 的几个关键问题1. 如何改变 promise 的状态？\n(1)resolve(value)：如果当前是 pending 就会变为 resolved &#x2F; fulfilled\n(2)reject(reason)：如果当前是 pending 就会变为 rejected\n(3) 抛出异常throw：如果当前是 pending 就会变为 rejected\n\nconst p = new Promise((resolve, reject) =&gt; &#123;  //resolve(1) // promise变为resolved成功状态  //reject(2) // promise变为rejected失败状态  throw new Error(&#x27;出错了&#x27;) // 抛出异常，promise变为rejected失败状态，reason为抛出的error&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;,reason)&#125;)// reason Error:出错了\n\n2. 一个 promise 指定多个成功&#x2F;失败回调函数，都会调用吗？当 promise 改变为对应状态时都会调用\nconst p = new Promise((resolve, reject) =&gt; &#123;  //resolve(1)  reject(2)&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason&#x27;,reason)&#125;)p.then(  value =&gt; &#123;&#125;,  reason =&gt; &#123;console.log(&#x27;reason2&#x27;,reason)&#125;)// reason 2// reason2 2\n\n3. 改变 promise 状态和指定回调函数谁先谁后？\n先执行resolve()，还是先指定then()中的回调？\n都有可能，常规是先指定回调再改变状态，但也可以先改状态再指定回调\n\n\n如何先改状态再指定回调？\n\n(1)在执行器中实现同步任务：直接调用 resolve()&#x2F;reject()\n\n(2)延迟更长时间才调用 then()\n\n\n\n\nlet p = new Promise((resolve, reject) =&gt; &#123;  // setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  // &#125;, 1000); // 有异步就先指定回调，否则先改变状态&#125;);p.then(value =&gt; &#123;  console.log(value);&#125;,reason=&gt;&#123;  &#125;)\n\n\n什么时候才能得到数据？( then()中的回调函数什么时候执行？)\n\n(1)如果先指定的回调，那当状态发生改变时，回调函数就会调用得到数据\n（指定回调 &#x3D;&gt; 改变状态 &#x3D;&gt; 执行回调）\n\n(2)如果先改变的状态，那当指定回调时，回调函数就会调用得到数据\n（改变状态 &#x3D;&gt; 指定回调 &#x3D;&gt; 执行回调）\n\n\n\n\nnew Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1) // 改变状态  &#125;, 1000)&#125;).then( // 指定回调函数 （先指定）  value =&gt; &#123;&#125;,  reason =&gt;&#123;&#125;)\n\n以上，先指定回调函数，保存当前指定的回调函数；后改变状态(同时指定数据)，然后异步执行之前保存的回调函数。\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1) // 改变状态&#125;).then( // 指定回调函数  value =&gt; &#123;&#125;,  reason =&gt;&#123;&#125;)\n\n以上，先改变的状态(同时指定数据)，后指定回调函数(不需要再保存)，直接异步执行回调函数\n4. promise.then() 返回的新 promise 的结果状态由什么决定？(1) 简单表达：由 then() 指定的回调函数执行的结果决定\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;  console.log(value);     //因为这里没有返回值，所以是undefined&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n(2) 详细表达：\n ① 如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;  //1. 抛出错误  throw &#x27;出了问题&#x27;;&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n ② 如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;\t//2. 返回结果是非 Promise 类型的对象\treturn 521;&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n ③ 如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果\nlet p = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123;\t//3. 返回结果是 Promise 对象\treturn new Promise((resolve, reject) =&gt; &#123;\t\t// resolve(&#x27;success&#x27;);\t\treject(&#x27;error&#x27;);\t&#125;);&#125;, reason =&gt; &#123;  console.warn(reason);&#125;);console.log(result);\n\n\n\n代码示例\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected2()&#x27;, reason)  &#125;)// onResolved1() 1// onResolved2() undefined\n\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    //return 2                   // onResolved2() 2    //return Promise.resolve(3)  // onResolved2() 3    //return Promise.reject(4)   // onRejected2() 4    //throw 5                    // onRejected2() 5  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)  &#125;,  reason =&gt; &#123;    console.log(&#x27;onRejected2()&#x27;, reason)  &#125;)// onResolved1() 1// onResolved2() undefined// Promise &#123;&lt;fulfilled&gt;: undefined&#125;// 对应输出如上所示\n\n5.promise 如何串联多个操作任务？(1)promise 的 then() 返回一个新的 promise，可以并成 then() 的链式调用\n(2)通过 then 的链式调用串联多个同步&#x2F;异步任务\nlet p = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;      resolve(&#x27;OK&#x27;);  &#125;, 1000);&#125;);p.then(value =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;      resolve(&quot;success&quot;);  &#125;);&#125;).then(value =&gt; &#123;  console.log(value); // success     //因为这里没有返回值，所以下面输出undefined&#125;).then(value =&gt; &#123;  console.log(value); // undefined&#125;)\n\nnew Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;执行任务1(异步)&#x27;)    resolve(1)  &#125;, 1000)&#125;).then(  value =&gt; &#123;    console.log(&#x27;任务1的结果&#x27;, value)    console.log(&#x27;执行任务2(同步)&#x27;)    return 2 // 同步任务直接return返回结果  &#125;).then(  value =&gt; &#123;    console.log(&#x27;任务2的结果&#x27;, value)    return new Promise((resolve, reject) =&gt; &#123; // 异步任务需要包裹在Promise对象中      setTimeout(() =&gt; &#123;        console.log(&#x27;执行任务3(异步)&#x27;)        resolve(3)      &#125;, 1000)    &#125;)  &#125;).then(  value =&gt; &#123;    console.log(&#x27;任务3的结果&#x27;, value)  &#125;)// 执行任务1(异步)// 任务1的结果 1// 执行任务2(同步)// 任务2的结果 2// 执行任务3(异步)// 任务3的结果 3\n\n6.Promise 异常穿透(传透)？(1)当使用 promise 的 then 链式调用时，可以在最后指定失败的回调\n(2)前面任何操作出了异常，都会传到最后失败的回调中处理\nnew Promise((resolve, reject) =&gt; &#123;   //resolve(1)   reject(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    return 2  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)    return 3  &#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved3()&#x27;, value)  &#125;).catch(  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;)// onRejected1() 1\n\n相当于这种写法：多写了很多reason =&gt; &#123;throw reason&#125;\nnew Promise((resolve, reject) =&gt; &#123;   //resolve(1)   reject(1)&#125;).then(  value =&gt; &#123;    console.log(&#x27;onResolved1()&#x27;, value)    return 2  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).then(  value =&gt; &#123;    console.log(&#x27;onResolved2()&#x27;, value)    return 3  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).then(  value =&gt; &#123;    console.log(&#x27;onResolved3()&#x27;, value)  &#125;,  reason =&gt; &#123;throw reason&#125; // 抛出失败的结果reason).catch(  reason =&gt; &#123;    console.log(&#x27;onRejected1()&#x27;, reason)  &#125;)// onRejected1() 1\n\n所以失败的结果是一层一层处理下来的，最后传递到 catch 中。\n或者，将 reason =&gt; &#123;throw reason&#125; 替换为 reason =&gt; Promise.reject(reason) 也是一样的\n7.中断 promise 链？当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数\n办法：在回调函数中返回一个 pending 状态的 promise 对象\nlet p = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&#x27;OK&#x27;);    &#125;, 1000);&#125;);p.then(value =&gt; &#123;    console.log(111);    //有且只有一个方式    return new Promise(() =&gt; &#123;&#125;);    // 返回一个pending的promise&#125;).then(value =&gt; &#123;    console.log(222);&#125;).then(value =&gt; &#123;    console.log(333);&#125;).catch(reason =&gt; &#123;    console.warn(reason);&#125;);\n\n在 then 中返回一个新的 promise，因为这个对象状态没有改变，所以没有结果。\n由于，返回的新的 promise 结果决定了后面 then 中的结果，所以后面的 then 中也没有结果。\n这就实现了中断 promise链的效果。\n","categories":["Promise"],"tags":["Promise"]},{"title":"Promise（三）：async与await","url":"/2022/04/22/Promise%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Aasync%E4%B8%8Eawait/","content":"参考笔记\nPromise+ async + await1)Promise&#x3D;&#x3D;&gt;异步2)await&#x3D;&#x3D;&gt;异步转同步\nawait 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。\nawait 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行\n\n3)async&#x3D;&#x3D;&gt;同步转异步\n方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法\n\n4)mdn文档\nasync\nawait\n\nasync函数\n函数的返回值为promise对象\npromise对象的结果由async函数执行的返回值决定\n\nawait表达式\n\nawait 右侧的表达式一般为 promise 对象, 但也可以是其它的值\n如果表达式是 promise 对象, await 返回的是 promise 成功的值\n如果表达式是其它值, 直接将此值作为 await 的返回值\n\n\n注意\n\nawait 必须写在 async 函数中, 但 async 函数中可以没有 await\n如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理\n\n\n","categories":["Promise"],"tags":["async","await"]},{"title":"Promise（二）：自定义（手写）Promise（源码解析）","url":"/2022/04/21/Promise%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%88%E6%89%8B%E5%86%99%EF%BC%89Promise/","content":"1. 整体结构框架/** * 自定义Promise函数模块：IIFE */(function (window) &#123;  const PENDING = &#x27;pending&#x27;  const RESOLVED = &#x27;fulfilled&#x27;  const REJECTED = &#x27;rejected&#x27;  /**   * Promise构造函数   * @param &#123;function&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125;   */  function Promise(executor) &#123;    &#125;  /**   * Promise原型对象then方法    * 指定成功和失败的回调函数   * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125;   * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;   * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定   */  Promise.prototype.then = function (onResolved, onRejected) &#123;      &#125;  /**   * Promise原型对象catch方法   * 指定失败的回调函数   * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;   * @returns 一个新的promise对象   */  Promise.prototype.catch = function (onRejected) &#123;      &#125;  /**   * Promise函数对象resolve方法   * @param &#123;*&#125; value 成功的值   * @returns 一个成功/失败的promise   */   Promise.resolve = function (value) &#123;  &#125;  /**   * Promise函数对象reject方法   * @param &#123;*&#125; resaon 失败的原因   * @returns 一个失败的promise   */  Promise.reject = function (resaon) &#123;  &#125;  /**   * Promise函数对象all方法   * @param &#123;Array&lt;Promise&gt;&#125; promises    * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败   */  Promise.all = function (promises) &#123;  &#125;  /**   *Promise函数对象race方法   * @param &#123;Array&lt;Promise&gt;&#125; promises    * @returns 返回 一个promise，其结果由第一个完成的promise决定   */  Promise.race = function (promises) &#123;  &#125;  // 向外暴露Promise函数  window.Promise = Promise&#125;)(window)\n\n2. Promise(executor)\nPromise构造函数\nexecutor: 执行器函数（同步执行）\n\n/** * Promise构造函数 * @param &#123;*&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125; */function Promise(executor) &#123;  const self = this; // 保存当前实例对象的this的值  // 添加属性  self.PromiseState = PENDING // 给promise对象指定status属性，初始值为pending  self.PromiseResult = null // 给promise对象指定一个用于存储结果数据的属性  self.callbacks = [] // 存的是对象 每个元素的结构：&#123;onResolved() &#123;&#125;, onRejected() &#123;&#125;&#125;  /**   * executor内部定义成功时调用的函数   * @param &#123;*&#125; value 成功的值   * @returns    */  function resolve(value) &#123;    // 如果当前状态不是pending，直接结束    if (self.PromiseState !== PENDING) return    // 1. 修改对象的状态（promiseState）为 fulfilled    self.PromiseState = RESOLVED     // 2. 设置对象结果值（promiseResult）为 value    self.PromiseResult = value    // 如果有待执行的callback函数，立即【异步】执行回调函数onResolved    if (self.callbacks.length &gt; 0) &#123;      setTimeout(() =&gt; &#123; // 放入队列中执行所有成功的回调        self.callbacks.forEach(callbacksObj =&gt; &#123;          callbacksObj.onResolved(value)        &#125;)      &#125;, 0)    &#125;  &#125;    /**   * executor内部定义失败时调用的函数   * @param &#123;*&#125; reason 失败的原因   * @returns    */  function reject(reason) &#123;    // 如果当前状态不是pending，直接结束    if (self.PromiseState !== PENDING) return    // 1. 修改对象的状态（promiseState）为 rejected    self.PromiseState = REJECTED    // 2. 设置对象结果值（promiseResult）为 reason    self.PromiseResult = reason    // 如果有待执行的callback函数，立即【异步】执行回调函数onRejected    if (self.callbacks.length &gt; 0) &#123;      setTimeout(() =&gt; &#123; // 放入队列中执行所有失败的回调        self.callbacks.forEach(callbacksObj =&gt; &#123;          callbacksObj.onRejected(reason)        &#125;)      &#125;, 0)    &#125;  &#125;    // 立即【同步】执行executor函数  try &#123;    executor(resolve, reject)  &#125; catch(error) &#123; // 如果执行器抛出异常，promise对象变成rejected状态    reject(error)  &#125;&#125;\n\n3. Promise.prototype.thenPromise.prototype.then = function (onResolved, onRejected) &#123;  const self = this  return new Promise((resolve, reject) =&gt; &#123;    if (self.PromiseState === PENDING) &#123; // 假如当前状态还是pending状态，将回调函数保存起来      self.callbacks.push(&#123;        onResolved(value) &#123;          // onResolved(self.PromiseResult)          try &#123;            const result = onResolved(self.PromiseResult) // 执行成功的回调 result接收返回值            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              // result.then(              //   value =&gt; &#123;              //     resolve(value) // 当result成功时，让return的promise也成功              //   &#125;,              //   reason =&gt; &#123;              //     reject(reason) // 当result失败时，让return的promise也失败              //   &#125;              // )              result.then(resolve, reject) // 简洁写法            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;         &#125;,        onRejected(reason) &#123;          // onRejected(self.PromiseResult)          try &#123;            const result = onRejected(self.PromiseResult) // 执行失败的回调 result接收返回值            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              result.then(resolve, reject)            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;         &#125;      &#125;)    &#125; else if (self.PromiseState === RESOLVED) &#123; // resolved      setTimeout(() =&gt; &#123;        /**         * 1. 如果抛出异常，return的promise就会失败，reason是error         * 2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值         * 3. 如果回调函数返回的是promise，return的promise结果就是这个promise的结果         */        try &#123;          const result = onResolved(self.PromiseResult) // 执行成功的回调 result接收返回值          if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise            // result.then(            //   value =&gt; &#123;            //     resolve(value) // 当result成功时，让return的promise也成功            //   &#125;,            //   reason =&gt; &#123;            //     reject(reason) // 当result失败时，让return的promise也失败            //   &#125;            // )            result.then(resolve, reject) // 简洁写法          &#125; else &#123; // 2. 如果回调函数返回的不是promise            resolve(result)          &#125;        &#125; catch (error) &#123; //1. 如果抛出异常          reject(error)        &#125;      &#125;, 0)    &#125; else &#123; // rejected      setTimeout(() =&gt; &#123;        try &#123;          const result = onRejected(self.PromiseResult) // 执行失败的回调 result接收返回值          if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise            result.then(resolve, reject)          &#125; else &#123; // 2. 如果回调函数返回的不是promise            resolve(result)          &#125;        &#125; catch (error) &#123; //1. 如果抛出异常          reject(error)        &#125;      &#125;, 0)    &#125;  &#125;)&#125;\n\n简化封装一下\n/** * Promise原型对象then方法  * 指定成功和失败的回调函数 * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125; * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125; * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定 */Promise.prototype.then = function (onResolved, onRejected) &#123;  // 指定默认的成功的回调onResolved （向后传递成功的value）  onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value  // 指定默认的失败的回调onRejected（向后传递失败的reason 实现错误/异常传透的关键点）  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;throw reason&#125;  const self = this  return new Promise((resolve, reject) =&gt; &#123;    /**     * 调用指定回调函数处理，根据执行的结果改变return的promise的状态     * @param &#123;function&#125; callback 指定回调函数     */    function handle(callback) &#123;      try &#123;        const result = callback(self.PromiseResult) // result获取回调函数执行(return)的结果        if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise          result.then(resolve, reject) // 简洁写法        &#125; else &#123; // 2. 如果回调函数返回的不是promise          resolve(result)        &#125;      &#125; catch (error) &#123; //1. 如果抛出异常        reject(error)      &#125;    &#125;    if (self.PromiseState === PENDING) &#123; // 1. 当前状态是pending状态，将回调函数保存起来      self.callbacks.push(&#123;        onResolved(value) &#123; //执行成功的回调函数，改promise的状态          handle(onResolved)         &#125;,        onRejected(reason) &#123; //执行失败的回调函数，改promise的状态          handle(onRejected)         &#125;      &#125;)    &#125; else if (self.PromiseState === RESOLVED) &#123; // 2. resolved，【异步】执行onResolved并改变return的promise的状态      setTimeout(() =&gt; &#123;        handle(onResolved)      &#125;, 0)    &#125; else &#123; // 3. rejected，【异步】执行onRejected并改变return的promise的状态      setTimeout(() =&gt; &#123;        handle(onRejected)      &#125;, 0)    &#125;  &#125;)&#125;\n\n4. Promise.prototype.catch/** * Promise原型对象catch方法 * 指定失败的回调函数 * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125; * @returns 一个新的promise对象 */Promise.prototype.catch = function (onRejected) &#123;  return this.then(undefined, onRejected)&#125;\n\n5. Promise.resolve/** * Promise函数对象resolve方法 * @param &#123;*&#125; value 成功的值 * @returns 一个成功/失败的promise */Promise.resolve = function (value) &#123;  // 返回一个成功/失败的promise  return new Promise((resolve, reject) =&gt; &#123;    if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果      value.then(resolve,reject)    &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value      resolve(value)    &#125;  &#125;)&#125;\n\n6. Promise.reject/** * Promise函数对象reject方法 * @param &#123;*&#125; resaon 失败的原因 * @returns 一个失败的promise */Promise.reject = function (reason) &#123;  // 返回一个失败的promise  return new Promise((resolve, reject) =&gt; &#123;    reject(reason)  &#125;)&#125;\n\n7. Promise.all/** * Promise函数对象all方法 * @param &#123;Array&lt;Promise&gt;&#125; promises  * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败 */Promise.all = function (promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let count = 0 // 声明计数变量    // const values = []; // 保存每个成功promise结果的数组    const values = new Array(promises.length) // 指定数组长度    for (let i = 0; i &lt; promises.length; i++)&#123;      // promises[i].then(value =&gt; &#123;      Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素        // 得知对象状态是成功        count++        // 将当前promise对象成功的结果存入到数组中        values[i] = value        if (count === promises.length) &#123; //每个promise对象都成功          resolve(values) // 修改函数状态        &#125;      &#125;, reason =&gt; &#123;          reject(reason)        &#125;)    &#125;  &#125;)&#125;\n\n8. Promise.race/** *Promise函数对象race方法 * @param &#123;Array&lt;Promise&gt;&#125; promises  * @returns 返回 一个promise，其结果由第一个完成的promise决定 */Promise.race = function (promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    for (let i = 0; i &lt; promises.length; i++)&#123;      // promises[i].then(value =&gt; &#123;      Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素        // 修改返回对象的状态为 成功        resolve(value)      &#125;, reason =&gt; &#123;        reject(reason)      &#125;)    &#125;  &#125;)&#125;\n\n9. 自定义函数对象方法Promise.resolveDelay&amp;Promise.rejectDelay/** * 自定义方法 延时返回一个成功/失败的promise * @param &#123;*&#125; value 成功的数据 * @param &#123;Number&#125; timeout 延迟时间 * @returns 一个成功/失败的promise */Promise.resolveDelay = function (value, timeout) &#123;  // 延时返回一个成功/失败的promise  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果        value.then(resolve,reject)      &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value        resolve(value)      &#125;    &#125;)  &#125;, timeout);&#125;/** * 自定义方法 延时返回一个失败的promise * @param &#123;*&#125; reason 失败的原因 * @param &#123;*&#125; timeout 延迟时间 * @returns 一个失败的promise */Promise.rejectDelay = function (reason, timeout) &#123;  // 延时返回一个失败的promise  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      reject(reason)    &#125;, timeout)  &#125;)&#125;\n\n10. class写法/** * 自定义Promise函数模块：IIFE */(function (window) &#123;  const PENDING = &#x27;pending&#x27;  const RESOLVED = &#x27;fulfilled&#x27;  const REJECTED = &#x27;rejected&#x27;  class Promise &#123;    /**     * Promise构造函数     * @param &#123;function&#125; executor 执行器函数（同步执行）(resolve, reject) =&gt; &#123;&#125;     */    constructor(executor) &#123;      const self = this; // 保存当前实例对象的this的值      // 添加属性      self.PromiseState = PENDING // 给promise对象指定status属性，初始值为pending      self.PromiseResult = null // 给promise对象指定一个用于存储结果数据的属性      self.callbacks = [] // 存的是对象 每个元素的结构：&#123;onResolved() &#123;&#125;, onRejected() &#123;&#125;&#125;      /**       * executor内部定义成功时调用的函数       * @param &#123;*&#125; value 成功的值       * @returns        */      function resolve(value) &#123;        // 如果当前状态不是pending，直接结束        if (self.PromiseState !== PENDING) return        // 1. 修改对象的状态（promiseState）为 fulfilled        self.PromiseState = RESOLVED        // 2. 设置对象结果值（promiseResult）为 value        self.PromiseResult = value        // 如果有待执行的callback函数，立即【异步】执行回调函数onResolved        if (self.callbacks.length &gt; 0) &#123;          setTimeout(() =&gt; &#123; // 放入队列中执行所有成功的回调            self.callbacks.forEach(callbacksObj =&gt; &#123;              callbacksObj.onResolved(value)            &#125;)          &#125;, 0)        &#125;      &#125;          /**       * executor内部定义失败时调用的函数       * @param &#123;*&#125; reason 失败的原因       * @returns        */      function reject(reason) &#123;        // 如果当前状态不是pending，直接结束        if (self.PromiseState !== PENDING) return        // 1. 修改对象的状态（promiseState）为 rejected        self.PromiseState = REJECTED        // 2. 设置对象结果值（promiseResult）为 reason        self.PromiseResult = reason        // 如果有待执行的callback函数，立即【异步】执行回调函数onRejected        if (self.callbacks.length &gt; 0) &#123;          setTimeout(() =&gt; &#123; // 放入队列中执行所有失败的回调            self.callbacks.forEach(callbacksObj =&gt; &#123;              callbacksObj.onRejected(reason)            &#125;)          &#125;, 0)        &#125;      &#125;          // 立即【同步】执行executor函数      try &#123;        executor(resolve, reject)      &#125; catch (error) &#123; // 如果执行器抛出异常，promise对象变成rejected状态        reject(error)      &#125;    &#125;    /**     * Promise原型对象then方法      * 指定成功和失败的回调函数     * @param &#123;function&#125; onResolved 成功的回调函数(value) =&gt; &#123;&#125;     * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;     * @returns 一个新的promise对象结果由onResolved/onRejected执行的结果决定     */    then (onResolved, onRejected) &#123;      // 指定默认的成功的回调onResolved （向后传递成功的value）      onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : value =&gt; value      // 指定默认的失败的回调onRejected（向后传递失败的reason 实现错误/异常传透的关键点）      onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;throw reason&#125;      const self = this      return new Promise((resolve, reject) =&gt; &#123;        /**         * 调用指定回调函数处理，根据执行的结果改变return的promise的状态         * @param &#123;function&#125; callback 指定回调函数         */        function handle(callback) &#123;          try &#123;            const result = callback(self.PromiseResult) // result获取回调函数执行(return)的结果            if (result instanceof Promise) &#123; // 3. 如果回调函数返回的是promise              result.then(resolve, reject) // 简洁写法            &#125; else &#123; // 2. 如果回调函数返回的不是promise              resolve(result)            &#125;          &#125; catch (error) &#123; //1. 如果抛出异常            reject(error)          &#125;        &#125;        if (self.PromiseState === PENDING) &#123; // 1. 当前状态是pending状态，将回调函数保存起来          self.callbacks.push(&#123;            onResolved(value) &#123; //执行成功的回调函数，改promise的状态              handle(onResolved)            &#125;,            onRejected(reason) &#123; //执行失败的回调函数，改promise的状态              handle(onRejected)            &#125;          &#125;)        &#125; else if (self.PromiseState === RESOLVED) &#123; // 2. resolved，【异步】执行onResolved并改变return的promise的状态          setTimeout(() =&gt; &#123;            handle(onResolved)          &#125;, 0)        &#125; else &#123; // 3. rejected，【异步】执行onRejected并改变return的promise的状态          setTimeout(() =&gt; &#123;            handle(onRejected)          &#125;, 0)        &#125;      &#125;)    &#125;    /**     * Promise原型对象catch方法     * 指定失败的回调函数     * @param &#123;function&#125; onRejected 失败的回调函数(reason) =&gt; &#123;&#125;     * @returns 一个新的promise对象     */    catch (onRejected) &#123;      return this.then(undefined, onRejected)    &#125;    /**     * Promise函数对象resolve方法     * @param &#123;*&#125; value 成功的值     * @returns 一个成功/失败的promise     */    static resolve(value) &#123;      // 返回一个成功/失败的promise      return new Promise((resolve, reject) =&gt; &#123;        if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果          value.then(resolve,reject)        &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value          resolve(value)        &#125;      &#125;)    &#125;    /**     * Promise函数对象reject方法     * @param &#123;*&#125; resaon 失败的原因     * @returns 一个失败的promise     */    static reject (reason) &#123;      // 返回一个失败的promise      return new Promise((resolve, reject) =&gt; &#123;        reject(reason)      &#125;)    &#125;      /**     * Promise函数对象all方法     * @param &#123;Array&lt;Promise&gt;&#125; promises      * @returns 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就失败     */     static all (promises) &#123;      return new Promise((resolve, reject) =&gt; &#123;        let count = 0 // 声明计数变量        // const values = []; // 保存每个成功promise结果的数组        const values = new Array(promises.length) // 指定数组长度        for (let i = 0; i &lt; promises.length; i++)&#123;          // promises[i].then(value =&gt; &#123;            Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素            // 得知对象状态是成功            count++            // 将当前promise对象成功的结果存入到数组中            values[i] = value            if (count === promises.length) &#123; //每个promise对象都成功              resolve(values) // 修改函数状态            &#125;          &#125;, reason =&gt; &#123;              reject(reason)            &#125;)        &#125;      &#125;)    &#125;    /**     *Promise函数对象race方法    * @param &#123;Array&lt;Promise&gt;&#125; promises     * @returns 返回 一个promise，其结果由第一个完成的promise决定    */    static race (promises) &#123;      return new Promise((resolve, reject) =&gt; &#123;        for (let i = 0; i &lt; promises.length; i++)&#123;          // promises[i].then(value =&gt; &#123;          Promise.resolve(promises[i]).then(value =&gt; &#123; // 防止数组中有不是promise的元素            // 修改返回对象的状态为 成功            resolve(value)          &#125;, reason =&gt; &#123;            reject(reason)          &#125;)        &#125;      &#125;)    &#125;    /**     * 自定义方法 延时返回一个成功/失败的promise     * @param &#123;*&#125; value 成功的数据     * @param &#123;Number&#125; timeout 延迟时间     * @returns 一个成功/失败的promise     */    static resolveDelay (value, timeout) &#123;      // 延时返回一个成功/失败的promise      return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;          if (value instanceof Promise) &#123; // value是promise =&gt; 使用value的结果作为promise的结果            value.then(resolve,reject)          &#125; else &#123; // value不是promise =&gt; promise状态变为成功，数据是value            resolve(value)          &#125;        &#125;)      &#125;, timeout);    &#125;    /**     * 自定义方法 延时返回一个失败的promise     * @param &#123;*&#125; reason 失败的原因     * @param &#123;*&#125; timeout 延迟时间     * @returns 一个失败的promise     */     static rejectDelay (reason, timeout) &#123;      // 延时返回一个失败的promise      return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;          reject(reason)        &#125;, timeout)      &#125;)    &#125;  &#125;  // 向外暴露Promise函数  window.Promise = Promise&#125;)(window)\n\n","categories":["Promise"],"tags":["手写Promise"]},{"title":"Vue（一）：Vue简介","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AVue%E7%AE%80%E4%BB%8B/","content":"什么是Vue？\nVue官网\n\nVue：动态构建用户界面的渐进式 JavaScript 框架\n\n构建用户界面：把数据通过某种办法变成用户界面\n渐进式：Vue可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心\n\n\n作者：尤雨溪\n\n\n\nVue的特点\n遵循MVVM模式\n编码简洁，体积小，运行效率高，适合移动&#x2F;PC端开发\n它本身只关注 UI，可以引入其它第三方库开发项目\n采用组件化模式，提高代码复用率、且让代码更好维护\n声明式编码，让编码人员无需直接操作DOM，提高开发效率\n使用虚拟DOM 和 Diff算法，尽量复用DOM节点\n\nVue与其它JS框架的关联\n借鉴 angular 的 模板 和 数据绑定 技术\n借鉴 react 的 组件化 和 虚拟DOM 技术\n\nVue周边库\nvue-cli：vue 脚手架\nvue-resource(axios)：ajax 请求\nvue-router：路由\nvuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）\nvue-lazyload：图片懒加载\nvue-scroller：页面滑动相关\nmint-ui：基于 vue 的 UI 组件库（移动端）\nelement-ui：基于 vue 的 UI 组件库（PC 端）\n\n初识Vue前置工作\n给浏览器安装 Vue Devtools 插件\n标签引入Vue包\n（可选）阻止vue在启动时生成生产提示Vue.config.productionTip &#x3D; false\nfavicon 需要将页签图标放在项目根路径，重新打开就有了（shfit+F5 强制刷新）\n\n初识Vue\n想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象\n\nroot 容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法\n\nroot 容器里的代码被称为【Vue模板】\n\nVue 实例与容器是一一对应的\n\n真实开发中只有一个Vue实例，并且会配合着组件一起使用\n\n中的 xxx 要写 **js 表达式**，且 xxx 可以自动读取到data中的所有属性\n\n注意区分：js 表达式 和 js代码（语句）\n\n表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方a a+b demo(1) x &#x3D;&#x3D;&#x3D; y ? ‘a’ : ‘b’\njs代码（语句）if(){} for(){}\n\n\n一旦data中的数据发生变化，那么模板中用到该数据的地方也会自动更新\n\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\t\t&lt;title&gt;初识Vue&lt;/title&gt;\t\t&lt;!-- 引入Vue --&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;!-- 准备好一个容器 --&gt;\t\t&lt;div id=&quot;demo&quot;&gt;\t\t\t&lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot; &gt;\t\t\tVue.config.productionTip = false //阻止 vue 在启动时生成生产提示。\t\t\t//创建Vue实例\t\t\tnew Vue(&#123;\t\t\t\tel:&#x27;#demo&#x27;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。\t\t\t\tdata:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。\t\t\t\t\tname:&#x27;atguigu&#x27;,\t\t\t\t\taddress:&#x27;北京&#x27;\t\t\t\t&#125;\t\t\t&#125;)\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue（七）：绑定样式和条件渲染","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","content":"绑定样式\nclass样式\n\n写法：:class=&quot;xxx&quot;，xxx 可以是字符串、数组、对象\n字符串写法适用于：类名不确定，要动态获取\n数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\n对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\n\n\n\n\nstyle样式\n\n写法：：style=&quot;xxx&quot;,xxx 可以是对象、数组\n\n对象写法:style=&quot;&#123;fontSize: xxx&#125;&quot;其中 xxx 是动态值\n\n数组写法:style=&quot;[a,b]&quot;其中a、b是样式对象\n\n\n\n\n&lt;style&gt;  .basic &#123;width: 300px;height: 50px;border: 1px solid black;&#125;  .happy &#123;border: 3px solid red;background-color: rgba(255, 255, 0, 0.644);    background: linear-gradient(30deg, yellow, pink, orange, yellow);&#125;  .sad &#123;border: 4px dashed rgb(2, 197, 2);background-color: skyblue;&#125;  .normal &#123;background-color: #bfa;&#125;  .atguigu1 &#123;background-color: yellowgreen;&#125;  .atguigu2 &#123;font-size: 20px;text-shadow: 2px 2px 10px red;&#125;  .atguigu3 &#123;border-radius: 20px;&#125;&lt;/style&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;  &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定style样式--对象写法 --&gt;  &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;  &lt;!-- 绑定style样式--数组写法 --&gt;  &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      name: &#x27;尚硅谷&#x27;,      mood: &#x27;normal&#x27;,      classArr: [&#x27;atguigu1&#x27;, &#x27;atguigu2&#x27;, &#x27;atguigu3&#x27;],      classObj: &#123;        atguigu1: false,        atguigu2: false,      &#125;,      styleObj: &#123;        fontSize: &#x27;40px&#x27;,        color: &#x27;red&#x27;,      &#125;,      styleObj2: &#123;        backgroundColor: &#x27;orange&#x27;      &#125;,      styleArr: [        &#123;          fontSize: &#x27;40px&#x27;,          color: &#x27;blue&#x27;,        &#125;,        &#123;          backgroundColor: &#x27;gray&#x27;        &#125;      ]    &#125;,    methods: &#123;      changeMood() &#123;        const arr = [&#x27;happy&#x27;, &#x27;sad&#x27;, &#x27;normal&#x27;]        const index = Math.floor(Math.random() * 3)        this.mood = arr[index]      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\n条件渲染v-show\n写法：v-show=&quot;表达式&quot; （true or false）\n适用于：切换频率较高的场景\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉display: none\n\nv-if\n写法 跟 if else 语法类似\nv-if=&quot;表达式&quot;\nv-else-if=&quot;表达式&quot;\nv-else\n\n\n适用于：切换频率较低的场景，因为不展示的DOM元素直接被移除\n注意：v-if可以和v-else-if v-else一起使用，但要求结构不能被打断（中间不能插入别的结构）\n\n备注：\n使用v-if的时，元素可能无法获取到（因为不展示的DOM元素直接被移除），而使用v-show一定可以获取到\n\ntemplate标签不影响结构，页面html中不会有此标签，但只能配合v-if，不能配合v-show\n\n\n","categories":["Vue"],"tags":["绑定样式","条件渲染"]},{"title":"Vue（三十）：Vue3快速上手","url":"/2022/04/13/Vue%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9AVue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","content":"Vue3快速上手\n\n\n\n1.Vue3简介\n2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 \ngithub上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n2.Vue3带来了什么1.性能的提升\n打包大小减少41%\n\n初次渲染快55%, 更新渲染快133%\n\n内存减少54%\n……\n\n\n2.源码的升级\n使用Proxy代替defineProperty实现响应式\n\n重写虚拟DOM的实现和Tree-Shaking\n……\n\n\n3.拥抱TypeScript\nVue3可以更好的支持TypeScript\n\n4.新的特性\nComposition API（组合API）\n\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject\n……\n\n\n新的内置组件\n\nFragment \nTeleport\nSuspense\n\n\n其他改变\n\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n……\n\n\n\n一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve\n\n2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\nvite官网：https://vitejs.cn\n\n什么是vite？—— 新一代前端构建工具。\n优势如下：\n开发环境中，无需打包操作，可快速的冷启动。\n轻量快速的热重载（HMR）。\n真正的按需编译，不再等待整个应用编译完成。\n\n\n传统构建 与 vite构建对比图\n\n\n## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev\n\n二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n1.拉开序幕的setup\n理解：Vue3.0中一个新的配置项，值为一个函数。\nsetup是所有Composition API（组合API）“ 表演的舞台 ”。\n组件中所用到的：数据、方法等等，均要配置在setup中。\nsetup函数的两种返回值：\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n注意点：\n尽量不要与Vue2.x配置混用\nVue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…）。\n如果有重名, setup优先。\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n\n2.ref函数\n作用: 定义一个响应式的数据\n语法: const xxx = ref(initValue) \n创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。\nJS中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。\n\n\n\n3.reactive函数\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n4.Vue3.0中的响应式原理vue2.x的响应式\n实现原理：\n\n对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n\n数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\nObject.defineProperty(data, &#x27;count&#x27;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)\n\n\n存在问题：\n\n新增属性、删除属性, 界面不会更新。\n直接通过下标修改数组, 界面不会自动更新。\n\n\n\nVue3.0的响应式\n实现原理: \n\n通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n\n通过Reflect（反射）:  对源对象的属性进行操作。\n\nMDN文档中描述的Proxy与Reflect：\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\nnew Proxy(data, &#123;\t// 拦截读取属性值    get (target, prop) &#123;    \treturn Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;    \treturn Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;    \treturn Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#x27;tom&#x27;   \n\n\n\n\n\n5.reactive对比ref\n从定义数据角度对比：\nref用来定义：基本类型数据。\nreactive用来定义：对象（或数组）类型数据。\n备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\nref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\nref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\n6.setup的两个注意点\nsetup执行的时机\n\n在beforeCreate之前执行一次，this是undefined。\n\n\nsetup的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\n\n\n7.计算属性与监视1.computed函数\n与Vue2.x中computed配置功能一致\n\n写法\nimport &#123;computed&#125; from &#x27;vue&#x27;setup()&#123;    ...\t//计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#x27;-&#x27; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#x27;-&#x27; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#x27;-&#x27;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;\n\n2.watch函数\n与Vue2.x中watch配置功能一致\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n3.watchEffect函数\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect有点像computed：\n\n但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;)\n\n8.生命周期vue2.x的生命周期vue3.0的生命周期\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\nVue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\nbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()\ncreated&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\nbeforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount\nmounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted\nbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated\nbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted\n\n\n\n9.自定义hook函数\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n\n类似于vue2.x中的mixin。\n\n自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n10.toRef\n作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n\n语法：const name = toRef(person,&#39;name&#39;)\n\n应用:   要将响应式对象中的某个属性单独提供给外部使用时。\n\n扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\n\n三、其它 Composition API1.shallowReactive 与 shallowRef\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\n\n\n\n2.readonly 与 shallowReadonly\nreadonly: 让一个响应式数据变为只读的（深只读）。\nshallowReadonly：让一个响应式数据变为只读的（浅只读）。\n应用场景: 不希望数据被修改时。\n\n3.toRaw 与 markRaw\ntoRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n4.customRef\n作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n\n实现防抖效果：\n&lt;template&gt;\t&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;ref,customRef&#125; from &#x27;vue&#x27;\texport default &#123;\t\tname:&#x27;Demo&#x27;,\t\tsetup()&#123;\t\t\t// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref\t\t\t//自定义一个myRef\t\t\tfunction myRef(value,delay)&#123;\t\t\t\tlet timer\t\t\t\t//通过customRef去实现自定义\t\t\t\treturn customRef((track,trigger)=&gt;&#123;\t\t\t\t\treturn&#123;\t\t\t\t\t\tget()&#123;\t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\t\t\t\t\t\t\treturn value\t\t\t\t\t\t&#125;,\t\t\t\t\t\tset(newValue)&#123;\t\t\t\t\t\t\tclearTimeout(timer)\t\t\t\t\t\t\ttimer = setTimeout(()=&gt;&#123;\t\t\t\t\t\t\t\tvalue = newValue\t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\t\t\t\t\t\t\t&#125;,delay)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t\tlet keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref\t\t\treturn &#123;\t\t\t\tkeyword\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n5.provide 与 inject\n\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\t......    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)    provide(&#x27;car&#x27;,car)    ......&#125;\n\n后代组件中：\nsetup(props,context)&#123;\t......    const car = inject(&#x27;car&#x27;)    return &#123;car&#125;\t......&#125;\n\n\n\n6.响应式数据的判断\nisRef: 检查一个值是否为一个 ref 对象\nisReactive: 检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly: 检查一个对象是否是由 readonly 创建的只读代理\nisProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n    \n\n\n     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n    \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、新的组件1.Fragment\n在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\n2.Teleport\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。\n&lt;teleport to=&quot;移动位置&quot;&gt;\t&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;\t\t&lt;div class=&quot;dialog&quot;&gt;\t\t\t&lt;h3&gt;我是一个弹窗&lt;/h3&gt;\t\t\t&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/teleport&gt;\n\n3.Suspense\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\n\n异步引入组件\nimport &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;))\n\n使用Suspense包裹组件，并配置好default 与 fallback\n&lt;template&gt;\t&lt;div class=&quot;app&quot;&gt;\t\t&lt;h3&gt;我是App组件&lt;/h3&gt;\t\t&lt;Suspense&gt;\t\t\t&lt;template v-slot:default&gt;\t\t\t\t&lt;Child/&gt;\t\t\t&lt;/template&gt;\t\t\t&lt;template v-slot:fallback&gt;\t\t\t\t&lt;h3&gt;加载中.....&lt;/h3&gt;\t\t\t&lt;/template&gt;\t\t&lt;/Suspense&gt;\t&lt;/div&gt;&lt;/template&gt;\n\n\n\n六、其他1.全局API的转移\nVue 2.x 有许多全局 API 和配置。\n\n例如：注册全局组件、注册全局指令等。\n//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123;  inserted: el =&gt; el.focus()&#125;\n\n\nVue3.0中对这些API做出了调整：\n\n将全局的API，即：Vue.xxx调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n\n\n2.其他改变\ndata选项应始终被声明为一个函数。\n\n过度类名的更改：\n\nVue2.x写法\n.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;\n\nVue3.x写法\n.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;\n\n\n移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n移除v-on.native修饰符\n\n父组件中绑定事件\n&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;\n\n子组件中声明自定义事件\n&lt;script&gt;  export default &#123;    emits: [&#x27;close&#x27;]  &#125;&lt;/script&gt;\n\n\n移除过滤器（filter）\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n……\n\n\n","categories":["Vue"],"tags":["Vue3"]},{"title":"Vue（三）：el和data的两种写法","url":"/2022/04/01/Vue%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Ael%E5%92%8Cdata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/","content":"el有2种写法\n创建Vue实例对象的时候配置el属性\n先创建Vue实例，随后再通过vm.$mount(&#39;#root&#39;)指定el的值\n\ndata有2种写法\n对象式：data： { }\n\n函数式：data() { return { } }\n如何选择：目前哪种写法都可以，以后到组件时，data必须使用函数，否则会报错\n一个重要的原则\n由Vue管理的函数，一定不要写箭头函数，否则 this 就不再是Vue实例了\n\n\n&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    // el的两种写法    // const v = new Vue(&#123;    // \t//el:&#x27;#root&#x27;, // 第一种写法    // \tdata: &#123;    // \t\tname:&#x27;cess&#x27;    // \t&#125;    // &#125;)    // console.log(v)    // v.$mount(&#x27;#root&#x27;) // 第二种写法    // data的两种写法    new Vue(&#123;        el: &#x27;#root&#x27;,        // data的第一种写法：对象式        // data:&#123;        // \tname:&#x27;cess&#x27;        // &#125;        //data的第二种写法：函数式        data() &#123;            console.log(&#x27;@@@&#x27;, this) // 此处的this是Vue实例对象            return &#123;                name: &#x27;cess&#x27;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["el","data"]},{"title":"Vue（九）：数据监视","url":"/2022/04/02/Vue%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86/","content":"更新数据时的一个问题\nthis.persons[0] = &#123;id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;&#125; \n更改data数据，Vue不监听，模板不改变\n\n\n&lt;title&gt;更新时的一个问题&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 30, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 31, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 18, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 19, sex: &#x27;男&#x27; &#125;      ]    &#125;,    methods: &#123;      updateMei() &#123;        // this.persons[0].name = &#x27;马老师&#x27;\t//奏效        // this.persons[0].age = 50\t\t\t\t//奏效        // this.persons[0].sex = &#x27;男&#x27;\t\t\t//奏效        // this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效        this.persons.splice(0, 1, &#123; id: &#x27;001&#x27;, name: &#x27;马老师&#x27;, age: 50, sex: &#x27;男&#x27; &#125;)      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n模拟一个数据检测let data = &#123;  name: &#x27;尚硅谷&#x27;,  address: &#x27;北京&#x27;,&#125;function Observer(obj) &#123;  // 汇总对象中所有的属性形成一个数组  const keys = Object.keys(obj)  // 遍历  keys.forEach((k) =&gt; &#123;    Object.defineProperty(this, k, &#123;      get() &#123;        return obj[k]      &#125;,      set(val) &#123;        console.log(`$&#123;k&#125;被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)        obj[k] = val      &#125;    &#125;)  &#125;)&#125;// 创建一个监视的实例对象，用于监视data中属性的变化const obs = new Observer(data)console.log(obs)// 准备一个vm实例对象let vm = &#123;&#125;vm._data = data = obs\n\n原理（数据劫持）\nvue会监视data中所有层次的数据\n\n如何监测对象中的数据？ \n通过setter实现监视，且要在new Vue()时就传入要监测的数据\n\n对象创建后追加的属性，Vue默认不做响应式处理 (响应式：有get、set)\n\n如需给后添加的属性做响应式，请使用如下API\nVue.set(target,propertyName/index,value)\nvm.$set(target,propertyName/index,value)\n\n\n\n如何监测数组中的数据？ \n通过包裹数组更新元素的方法实现，本质就是做了两件事\n\n调用原生对应的方法对数组进行更新\n重新解析模板，进而更新页面\n\n\n在Vue修改数组中的某个元素一定要用如下方法\n\n使用这些API：push() pop() unshift() shift() splice() sort() reverse()这几个方法被Vue重写了\nVue.set()或vm.$set()\n\n\n特别注意：Vue.set() 和 vm.$set() 不能给vm或vm的根数据对象（_data等）添加属性\n\n\n&lt;title&gt;总结数据监视&lt;/title&gt;&lt;style&gt;button &#123;margin-top: 10px;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h1&gt;学生信息&lt;/h1&gt;  &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;student.sex = &#x27;未知&#x27; &quot;&gt;修改性别&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br /&gt;  &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br /&gt;  &lt;h3&gt;姓名：&#123;&#123; student.name &#125;&#125;&lt;/h3&gt;  &lt;h3&gt;年龄：&#123;&#123; student.age &#125;&#125;&lt;/h3&gt;  &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;  &lt;h3&gt;爱好：&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;&#123;&#123; h &#125;&#125; &lt;/li&gt;  &lt;/ul&gt;  &lt;h3&gt;朋友们：&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;&#123;&#123; f.name &#125;&#125;--&#123;&#123; f.age &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      student: &#123;        name: &#x27;tom&#x27;,        age: 18,        hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;],        friends: [          &#123; name: &#x27;jerry&#x27;, age: 35 &#125;,          &#123; name: &#x27;tony&#x27;, age: 36 &#125;        ]      &#125;    &#125;,    methods: &#123;      addSex() &#123;        // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)        this.$set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;)      &#125;,      addFriend() &#123;        this.student.friends.unshift(&#123; name: &#x27;jack&#x27;, age: 70 &#125;)      &#125;,      updateFirstFriendName() &#123;        this.student.friends[0].name = &#x27;张三&#x27;      &#125;,      addHobby() &#123;        this.student.hobby.push(&#x27;学习&#x27;)      &#125;,      updateHobby() &#123;        // this.student.hobby.splice(0,1,&#x27;开车&#x27;)        // Vue.set(this.student.hobby,0,&#x27;开车&#x27;)        this.$set(this.student.hobby, 0, &#x27;开车&#x27;)      &#125;,      removeSmoke() &#123;        this.student.hobby = this.student.hobby.filter((h) =&gt; &#123;          return h !== &#x27;抽烟&#x27;        &#125;)      &#125;    &#125;  &#125;)\n\n\n","categories":["Vue"],"tags":["数据监视"]},{"title":"Vue（二十一）：Vue脚手架之消息的订阅与发布","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E6%B6%88%E6%81%AF%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83/","content":"消息订阅与发布(pubsub)消息订阅与发布（pubsub）消息订阅与发布是一种组件间通信的方式，适用于任意组件间通信（类似全局事件总线，用得不多）\n使用步骤\n安装pubsub：npm i pubsub-js\n\n引入：import pubsub from &#39;pubsub-js&#39;\n\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身\nexport default &#123;    methods: &#123;        demo(msgName, data) &#123;...&#125;    &#125;    ...    mounted() &#123;\t\t\tthis.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo)    &#125;&#125;\n\n提供数据：pubsub.publish(&#39;xxx&#39;,data)\n\n最好在beforeDestroy钩子中，使用pubsub.unsubscribe(this.pid)取消订阅\n\n\n代码示例：\nsrc/components/School.vue\n&lt;template&gt;\t&lt;div class=&quot;school&quot;&gt;\t\t&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;\t\t&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport pubsub from &#x27;pubsub-js&#x27;\texport default &#123;\t\tname: &#x27;School&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;尚硅谷&#x27;,\t\t\t\taddress:&#x27;北京&#x27;,\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tdemo(msgName, data) &#123;\t\t\t\tconsole.log(&#x27;我是School组件，收到了数据：&#x27;,msgName, data)\t\t\t&#125;\t\t&#125;,\t\tmounted() &#123;\t\t\tthis.pubId = pubsub.subscribe(&#x27;demo&#x27;, this.demo) // 订阅消息\t\t&#125;,\t\tbeforeDestroy() &#123;\t\t\tpubsub.unsubscribe(this.pubId) // 取消订阅\t\t&#125;\t&#125;&lt;/script&gt;&lt;style scoped&gt;\t.school&#123;\t\tbackground-color: skyblue;\t\tpadding: 5px;\t&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;student&quot;&gt;    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import pubsub from &#x27;pubsub-js&#x27;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;JOJO&#x27;,        sex:&#x27;男&#x27;,      &#125;    &#125;,    methods: &#123;      sendStudentName()&#123;        pubsub.publish(&#x27;demo&#x27;, this.name) // 发布消息      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .student&#123;    background-color: pink;    padding: 5px;    margin-top: 30px;  &#125;&lt;/style&gt;\n\n使用消息的订阅与发布优化Todo-List案例src/App.vue\n&lt;template&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div class=&quot;todo-container&quot;&gt;    &lt;div class=&quot;todo-wrap&quot;&gt;      &lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;      &lt;MyList :todos=&quot;todos&quot;/&gt;      &lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;  \t&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import pubsub from &#x27;pubsub-js&#x27;\t// 习惯第三方库写上面  import MyHeader from &#x27;./components/MyHeader.vue&#x27;  import MyList from &#x27;./components/MyList.vue&#x27;  import MyFooter from &#x27;./components/MyFooter.vue&#x27;  export default &#123;    name:&#x27;App&#x27;,    components: &#123; MyHeader,MyList,MyFooter &#125;,    data() &#123;      return &#123;        todos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []      &#125;    &#125;,    methods:&#123;      //添加一个todo      addTodo(todoObj)&#123;        this.todos.unshift(todoObj)      &#125;,      //勾选or取消勾选一个todo      checkTodo(_,id)&#123;        this.todos.forEach((todo)=&gt;&#123;          if(todo.id === id) todo.done = !todo.done        &#125;)      &#125;,      //删除一个todo      deleteTodo(id)&#123;        this.todos = this.todos.filter(todo =&gt; todo.id !== id)      &#125;,      //全选or取消勾选      checkAllTodo(done)&#123;        this.todos.forEach(todo =&gt; todo.done = done)      &#125;,      //删除已完成的todo      clearAllTodo()&#123;        this.todos = this.todos.filter(todo =&gt; !todo.done)      &#125;    &#125;,    watch:&#123;      todos:&#123;        deep:true,        handler(value)&#123;          localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))        &#125;      &#125;    &#125;,    mounted()&#123;      this.pubId = pubsub.subscribe(&#x27;checkTodo&#x27;,this.checkTodo)\t// 两种对比      this.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo)    &#125;,    beforeDestroy()&#123;      pubsub.unsubscribe(this.pubId)      this.$bus.$off(&#x27;deleteTodo&#x27;)    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  ……&lt;/style&gt;\n\nsrc/components/myItem.vue\n&lt;template&gt;    &lt;li&gt;        &lt;label&gt;            &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @click=&quot;handleCheck(todo.id)&quot;/&gt;            &lt;span&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;        &lt;/label&gt;        &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id,todo.title)&quot;&gt;删除&lt;/button&gt;    &lt;/li&gt;&lt;/template&gt;&lt;script&gt;    import pubsub from &#x27;pubsub-js&#x27;    export default &#123;        name:&#x27;MyItem&#x27;,        props:[&#x27;todo&#x27;],        methods:&#123;            handleCheck(id)&#123;                                    pubsub.publish(&#x27;checkTodo&#x27;,id)            &#125;,            handleDelete(id,title)&#123;                if(confirm(&quot;确定删除任务：&quot;+title+&quot;吗？&quot;))&#123;                    this.$bus.$emit(&#x27;deleteTodo&#x27;,id)                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;   ……&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","订阅与发布"]},{"title":"Vue（二十三）：Vue脚手架之过渡与动画","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","content":"Vue封装的过渡与动画\n作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名\n\n图示：\n\n\n写法：\n\n准备好样式：\n\n元素进入的样式\nv-enter 进入的起点 （过渡需要，动画不需要）\nv-enter-active 进入过程中\nv-enter-to 进入的终点（过渡需要，动画不需要）\n\n\n○元素离开的样式\nv-leave 离开的起点（过渡需要，动画不需要）\nv-leave-active 离开过程中\nv-leave-to 离开的终点（过渡需要，动画不需要）\n\n\n\n\n使用&lt;transition&gt;包裹要过度的元素，并配置name属性，此时需要将上面样式名的v换为name\n\n要让页面一开始就显示动画，需要添加appear\n&lt;transition name=&quot;hello&quot; appear&gt;  &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt;&lt;style&gt;  .hello-enter-active&#123;    animation: hello 0.5s linear;  &#125;  .hello-leave-active&#123;    animation: hello 0.5s linear reverse;  &#125;  @keyframes hello &#123;    from&#123;      transform: translateX(-100%);    &#125;    to&#123;      transform: translateX(0px);    &#125;  &#125;&lt;/style&gt;\n\n备注：若有多个元素需要过度，则需要使用&lt;transition-group&gt;，且每个元素都要指定key值\n&lt;transition-group name=&quot;hello&quot; appear&gt;  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;  &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;&lt;/transition-group&gt;\n\n第三方库Aniamte.css\n&lt;transition-group appear          name=&quot;animate__animated animate__bounce&quot;          enter-active-class=&quot;animate__swing&quot;          leave-active-class=&quot;animate__backOutUp&quot;&gt;  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;  &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;&lt;/transition-group&gt;\n\n代码示例：\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;Test/&gt;\t\t&lt;Test2/&gt;\t\t&lt;Test3/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Test from &#x27;./components/Test&#x27;\timport Test2 from &#x27;./components/Test2&#x27;\timport Test3 from &#x27;./components/Test3&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;Test,Test2,Test3&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/test.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition name=&quot;hello&quot; appear&gt;      &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;    &lt;/transition&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;Test&#x27;,    data() &#123;return &#123;isShow:true&#125;&#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  h1&#123;background-color: orange;&#125;  .hello-enter-active&#123;    animation: atguigu 0.5s linear;  &#125;  .hello-leave-active&#123;    animation: atguigu 0.5s linear reverse;  &#125;  @keyframes atguigu &#123;    from&#123;transform: translateX(-100%);&#125;    to&#123;transform: translateX(0px);&#125;  &#125;&lt;/style&gt;\n\nsrc/components/test2.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group name=&quot;hello&quot; appear&gt;      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Test&#x27;,    data() &#123;return &#123;isShow:true&#125;&#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  h1 &#123;    background-color: orange;    /* transition: 0.5s linear; */  &#125;  /* 进入的起点、离开的终点 */  .hello-enter,.hello-leave-to &#123;    transform: translateX(-100%);  &#125;  .hello-enter-active,.hello-leave-active&#123;    transition: 0.5s linear;  &#125;  /* 进入的终点、离开的起点 */  .hello-enter-to,.hello-leave &#123;    transform: translateX(0);  &#125;&lt;/style&gt;\n\nsrc/components/test3.vue\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group appear                      name=&quot;animate__animated animate__bounce&quot;                      enter-active-class=&quot;animate__swing&quot;                      leave-active-class=&quot;animate__backOutUp&quot;&gt;      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &quot;animate.css&quot;    export default &#123;    name: &quot;Test&quot;,    data() &#123;return &#123;isShow: true,&#125;&#125;,  &#125;;&lt;/script&gt;&lt;style scoped&gt;  h1 &#123;background-color: orange;&#125;&lt;/style&gt;\n\n使用动画优化 Todo-List案例\n\nsrc/components/MyList.vue\n&lt;template&gt;  &lt;ul class=&quot;todo-main&quot;&gt;    &lt;transition-group name=&quot;todo&quot; appear&gt;      &lt;MyItem v-for=&quot;todoObj of todoList&quot; :key=&quot;todoObj.id&quot; :todoObj=&quot;todoObj&quot;/&gt;    &lt;/transition-group&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MyItem from &quot;./MyItem.vue&quot;;  export default &#123;    name: &quot;MyList&quot;,    components: &#123; MyItem &#125;,    props: [&quot;todoList&quot;],  &#125;;&lt;/script&gt;&lt;style scoped&gt;  /*main*/  .todo-main &#123;margin-left: 0px;border: 1px solid #ddd;border-radius: 2px;padding: 0px;&#125;  .todo-empty &#123;height: 40px;line-height: 40px;border: 1px solid #ddd;border-radius: 2px;    padding-left: 5px;margin-top: 10px;&#125;  .todo-enter-active &#123;    animation: atguigu 0.5s linear;  &#125;  .todo-leave-active &#123;    animation: atguigu 0.5s linear reverse;  &#125;  @keyframes atguigu &#123;    from &#123;      transform: translateX(100%);    &#125;    to &#123;      transform: translateX(0px);    &#125;  &#125;&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","过渡与动画"]},{"title":"Vue（二十七）：Vuex","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AVuex/","content":"理解VuexVuex是什么\n概念：专门在Vue中实现集中式状态（即数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信\nVuex Github地址\n\n\n\n什么时候使用Vuex\n多个组件依赖于同一状态\n来自不同组件的行为需要变更同一状态\n\nVuex 工作原理图\n求和案例使用纯vue编写\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;Count/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Count from &quot;./components/Count.vue&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123; Count &#125;,&#125;;&lt;/script&gt;\n\nsrc/components/Count.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;select v-model.number=&quot;n&quot;&gt;      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;    &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;    &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;Count&quot;,    data() &#123;      return &#123;        sum: 0, // 当前的和        n: 1, // 用户选择的数字      &#125;;    &#125;,    methods: &#123;      increment() &#123;        this.sum += this.n;      &#125;,      decrement() &#123;        this.sum -= this.n;      &#125;,      incrementOdd() &#123;        if (this.sum % 2) &#123;          this.sum += this.n;        &#125;      &#125;,      incrementWait() &#123;        setTimeout(() =&gt; &#123;          this.sum += this.n;        &#125;, 500);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  button &#123;margin-left: 5px;&#125;&lt;/style&gt;\n\n搭建Vuex环境\n下载安装vuex：npm i vuex\n\n创建src/store/index.js该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件const actions = &#123;&#125;\t\t// 准备actions——用于响应组件中的动作const mutations = &#123;&#125;\t// 准备mutations——用于操作数据（state）const state = &#123;&#125;\t\t\t// 准备state——用于存储数据// 创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\n在src/main.js中创建vm时传入store配置项\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27;\t// 引入storeVue.config.productionTip = falsenew Vue(&#123;\tel: &#x27;#app&#x27;,\trender: h =&gt; h(App),\tstore,\t\t\t\t\t\t\t\t\t\t// 配置项添加store\tbeforeCreate() &#123;\t\tVue.prototype.$bus = this\t&#125;&#125;)\n\n使用Vuex编写 Vuex的基本使用\n\n初始化数据state，配置actions、mutations，操作文件store.js\n\n组件中读取vuex中的数据$store.state.数据\n\n组件中修改vuex中的数据$store.dispatch(&#39;action中的方法名&#39;,数据)\n或$store.commit(&#39;mutations中的方法名&#39;,数据)\n若没有网络请求或其他业务逻辑，组件中也可越过actions，即不写dispatch，直接编写commit\n\n\nsrc/store/index.js\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件// 准备actions——用于响应组件中的动作const actions = &#123;\t/* jia(context,value)&#123;\t\tconsole.log(&#x27;actions中的jia被调用了&#x27;)\t\tcontext.commit(&#x27;JIA&#x27;,value)\t&#125;,\tjian(context,value)&#123;\t\tconsole.log(&#x27;actions中的jian被调用了&#x27;)\t\tcontext.commit(&#x27;JIAN&#x27;,value)\t&#125;, */\tjiaOdd(context,value)&#123;\t// context 相当于精简版的 $store\t\tconsole.log(&#x27;actions中的jiaOdd被调用了&#x27;)\t\tif(context.state.sum % 2)&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;\t&#125;,\tjiaWait(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaWait被调用了&#x27;)\t\tsetTimeout(()=&gt;&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;,500)\t&#125;&#125;// 准备mutations——用于操作数据（state）const mutations = &#123;\tJIA(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIA被调用了&#x27;)\t\tstate.sum += value\t&#125;,\tJIAN(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIAN被调用了&#x27;)\t\tstate.sum -= value\t&#125;&#125;// 准备state——用于存储数据const state = &#123;\tsum:0 //当前的和&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; $store.state.sum &#125;&#125;&lt;/h1&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tincrement()&#123;\t\t\t\tthis.$store.commit(&#x27;JIA&#x27;,this.n)\t\t\t&#125;,\t\t\tdecrement()&#123;\t\t\t\tthis.$store.commit(&#x27;JIAN&#x27;,this.n)\t\t\t&#125;,\t\t\tincrementOdd()&#123;\t\t\t\tthis.$store.dispatch(&#x27;jiaOdd&#x27;,this.n)\t\t\t&#125;,\t\t\tincrementWait()&#123;\t\t\t\tthis.$store.dispatch(&#x27;jiaWait&#x27;,this.n)\t\t\t&#125;,\t\t&#125;\t&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\ngetters配置项\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工，相当于全局计算属性\n\n在store.js中追加getters配置\n......const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum * 10\t&#125;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;\t......\tgetters&#125;)\n\n组件中读取数据$store.getters.bigSum\n\n\n\nsrc/store/index.js\nimport Vue from &#x27;vue&#x27;\t// 引入Vue核心库import Vuex from &#x27;vuex&#x27;\t// 引入VuexVue.use(Vuex)\t// 应用Vuex插件   // 准备actions对象——响应组件中用户的动作const actions = &#123;    addOdd(context,value)&#123;        console.log(&quot;actions中的addOdd被调用了&quot;)        if(context.state.sum % 2)&#123;context.commit(&#x27;ADD&#x27;,value)&#125;    &#125;,    addWait(context,value)&#123;        console.log(&quot;actions中的addWait被调用了&quot;)        setTimeout(()=&gt;&#123;context.commit(&#x27;ADD&#x27;,value)&#125;,500)    &#125;,&#125;// 准备mutations对象——修改state中的数据const mutations = &#123;    ADD(state,value)&#123;state.sum += value&#125;,    SUB(state,value)&#123;state.sum -= value&#125;&#125;// 准备state对象——保存具体的数据const state = &#123;    sum:0 // 当前的和&#125;// 准备getters对象——用于将state中的数据进行加工const getters = &#123;    bigSum()&#123;        return state.sum * 10    &#125;&#125;   //创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; $store.state.sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; $store.getters.bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1,\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tincrement()&#123;this.$store.commit(&#x27;ADD&#x27;,this.n)&#125;,\t\t\tdecrement()&#123;this.$store.commit(&#x27;SUBTRACT&#x27;,this.n)&#125;,\t\t\tincrementOdd()&#123;this.$store.dispatch(&#x27;addOdd&#x27;,this.n)&#125;,\t\t\tincrementWait()&#123;this.$store.dispatch(&#x27;addWait&#x27;,this.n)&#125;,\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\n四个map方法的使用\nmapState方法：用于帮助映射state中的数据为计算属性\ncomputed: &#123;  \t// 借助mapState生成计算属性：sum、school、subject（对象写法一）  \t...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),  \t// 借助mapState生成计算属性：sum、school、subject（数组写法二）  \t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;,\n\nmapGetters方法：用于帮助映射getters中的数据为计算属性\ncomputed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法一）    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法二）    ...mapGetters([&#x27;bigSum&#x27;])&#125;,\n\nmapActions方法：用于帮助生成与actions对话的方法，即包含$store.dispatch(xxx)的函数\nmethods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125;\n\nmapMutations方法：用于帮助生成与mutations对话的方法，即包含$store.commit(xxx)的函数\nmethods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125;\n\n注意：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象\n\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我是&#123;&#123; name &#125;&#125;，我在&#123;&#123; school &#125;&#125;学习&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;addOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;addWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState, mapGetters, mapMutations, mapActions&#125; from &#x27;vuex&#x27;\t//🔴\texport default &#123;\t\tname: &#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,  computed: &#123;\t\t\t\t\t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;name&#x27;]),\t\t\t...mapGetters([&#x27;bigSum&#x27;])\t\t&#125;,\t\tmethods: &#123;\t\t\t...mapMutations(&#123;increment:&#x27;ADD&#x27;, decrement:&#x27;SUBTRACT&#x27;&#125;),\t\t\t...mapActions([&#x27;addOdd&#x27;, &#x27;addWait&#x27;])\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;\tbutton&#123;\t\tmargin-left: 5px;\t&#125;&lt;/style&gt;\n\n多组件共享数据案例\nsrc/App/vue\n&lt;template&gt;  &lt;div&gt;    &lt;Count/&gt;&lt;hr/&gt;    &lt;Person/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Count from &quot;./components/Count.vue&quot;;import Person from &quot;./components/Person.vue&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123; Count, Person &#125;,&#125;;&lt;/script&gt;\n\nsrc/store/index.js 该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const actions = &#123;\tjiaOdd(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaOdd被调用了&#x27;)\t\tif(context.state.sum % 2)&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;\t&#125;,\tjiaWait(context,value)&#123;\t\tconsole.log(&#x27;actions中的jiaWait被调用了&#x27;)\t\tsetTimeout(()=&gt;&#123;\t\t\tcontext.commit(&#x27;JIA&#x27;,value)\t\t&#125;,500)\t&#125;&#125;//准备mutations——用于操作数据（state）const mutations = &#123;\tJIA(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIA被调用了&#x27;)\t\tstate.sum += value\t&#125;,\tJIAN(state,value)&#123;\t\tconsole.log(&#x27;mutations中的JIAN被调用了&#x27;)\t\tstate.sum -= value\t&#125;,\tADD_PERSON(state,value)&#123;\t\tconsole.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;)\t\tstate.personList.unshift(value)\t&#125;&#125;//准备state——用于存储数据const state = &#123;\tsum: 0,\tschool: &#x27;尚硅谷&#x27;,\tsubject: &#x27;前端&#x27;,\tpersonList: []&#125;//准备getters——用于将state中的数据进行加工const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum*10\t&#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,\tgetters&#125;)\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和放大10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我在&#123;&#123; school &#125;&#125;，学习&#123;&#123; subject &#125;&#125;&lt;/h3&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：&#123;&#123; personList.length &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#x27;vuex&#x27;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, //用户选择的数字\t\t\t&#125;\t\t&#125;,\t\tcomputed:&#123;\t\t\t...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;,&#x27;personList&#x27;]),\t\t\t...mapGetters([&#x27;bigSum&#x27;])\t\t&#125;,\t\tmethods: &#123;\t\t\t...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\t\t\t...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\t\t&#125;\t&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Person.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;人员列表&lt;/h1&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：&#123;&#123; sum &#125;&#125;&lt;/h3&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot;&gt;\t\t&lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;\t\t&lt;ul&gt;\t\t\t&lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123; p.name &#125;&#125;&lt;/li&gt;\t\t&lt;/ul&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;  import &#123; mapState &#125; from &quot;vuex&quot;  \texport default &#123;\t\tname:&#x27;Person&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tcomputed:&#123;\t\t\tpersonList()&#123;return this.$store.state.personList&#125;,\t\t\tsum()&#123;return this.$store.state.sum&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;        if (this.name === &quot;&quot;) return\t\t\t\tconst personObj = &#123;id:nanoid(),name:this.name&#125;\t\t\t\tthis.$store.commit(&#x27;ADD_PERSON&#x27;,personObj)\t\t\t\tthis.name = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n模块化+命名空间\n目的：让代码更好维护，让多种数据分类更加明确\n\n修改store.js\n为了解决不同模块命名冲突的问题，将不同模块的namespaced: true之后在不同页面中引入getter actions mutations时，需要加上所属的模块名\nconst countAbout = &#123;  namespaced: true,\t// 开启命名空间  state: &#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123; return state.sum * 10 &#125;  &#125;&#125;const personAbout = &#123;  namespaced: true,\t// 开启命名空间  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n\n开启命名空间后，组件中读取state数据\n// 方式一：自己直接读取this.$store.state.personAbout.list// 方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),\n\n开启命名空间后，组件中读取getters数据\n//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])\n\n开启命名空间后，组件中调用dispatch\n//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n\n开启命名空间后，组件中调用commit\n//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n\n\n\nsrc/store/index.js 该文件用于创建Vuex中最为核心的store\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import countOptions from &#x27;./count&#x27;\t\t// 引入countimport personOptions from &#x27;./person&#x27;\t// 引入personVue.use(Vuex)   //创建并暴露storeexport default new Vuex.Store(&#123;    modules:&#123;        countAbout:countOptions,        personAbout:personOptions,    &#125;&#125;)\n\nsrc/store/count.js \nexport default &#123;    namespaced:true,    actions: &#123;        addOdd(context,value)&#123;            console.log(&quot;actions中的addOdd被调用了&quot;)            if(context.state.sum % 2)&#123;                context.commit(&#x27;ADD&#x27;,value)            &#125;        &#125;,        addWait(context,value)&#123;            console.log(&quot;actions中的addWait被调用了&quot;)            setTimeout(()=&gt;&#123;                context.commit(&#x27;ADD&#x27;,value)            &#125;,500)        &#125;    &#125;,    mutations: &#123;        ADD(state,value)&#123; state.sum += value &#125;,        SUBTRACT(state,value)&#123; state.sum -= value &#125;    &#125;,    state: &#123;        sum:0,        school:&#x27;尚硅谷&#x27;,      \tsubject: &#x27;前端&#x27;    &#125;,    getters: &#123;        bigSum(state)&#123; return state.sum * 10 &#125;    &#125;&#125;\n\nsrc/store/person.js \nimport axios from &quot;axios&quot;import &#123; nanoid &#125; from &quot;nanoid&quot;export default&#123;    namespaced:true,    actions:&#123;        addPersonWang(context,value)&#123;            if(value.name.indexOf(&#x27;王&#x27;) === 0)&#123;                context.commit(&#x27;ADD_PERSON&#x27;,value)            &#125;else&#123;                alert(&#x27;添加的人必须姓王！&#x27;)            &#125;        &#125;,        addPersonServer(context)&#123;            axios.get(&#x27;http://api.uixsj.cn/hitokoto/get?type=social&#x27;).then(                response =&gt; &#123;                    context.commit(&#x27;ADD_PERSON&#x27;,&#123;id:nanoid(),name:response.data&#125;)                &#125;,                error =&gt; &#123; alert(error.message) &#125;            )        &#125;    &#125;,    mutations:&#123;        ADD_PERSON(state,value)&#123;            console.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;)            state.personList.unshift(value)        &#125;    &#125;,    state:&#123;        personList:[]    &#125;,    getters:&#123;        firstPersonName(state)&#123; return state.personList[0].name &#125;    &#125;&#125;\n\nsrc/components/Count.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;\t\t&lt;h3&gt;当前求和的10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;\t\t&lt;h3&gt;我是&#123;&#123; name &#125;&#125;，我在&#123;&#123; school &#125;&#125;学习&lt;/h3&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：&#123;&#123; personList.length &#125;&#125;&lt;/h3&gt;\t\t&lt;select v-model.number=&quot;n&quot;&gt;\t\t\t&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\t\t\t&lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\t\t\t&lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\t\t&lt;/select&gt;\t\t&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;\t\t&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;\t\t&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;\t\t&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#x27;vuex&#x27;\texport default &#123;\t\tname:&#x27;Count&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tn:1, // 用户选择的数字\t\t\t&#125;\t\t&#125;,    computed:&#123;\t\t\t...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;name&#x27;]),      ...mapState(&#x27;personAbout&#x27;,[&#x27;personList&#x27;]),\t\t\t...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]),\t\t&#125;\t\tmethods: &#123;\t\t\t...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;ADD&#x27;,decrement:&#x27;SUBTRACT&#x27;&#125;),\t\t\t...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;addOdd&#x27;,incrementWait:&#x27;addWait&#x27;&#125;)\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style&gt;button&#123;margin-left: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Person.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h1&gt;人员列表&lt;/h1&gt;\t\t&lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：&#123;&#123; sum &#125;&#125;&lt;/h3&gt;        &lt;h3&gt;列表中第一个人的名字是：&#123;&#123; firstPersonName &#125;&#125;&lt;/h3&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot;&gt;\t\t&lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;        &lt;button @click=&quot;addWang&quot;&gt;添加一个姓王的人&lt;/button&gt;        &lt;button @click=&quot;addPerson&quot;&gt;随机添加一个人&lt;/button&gt;\t\t&lt;ul&gt;\t\t\t&lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123; p.name &#125;&#125;&lt;/li&gt;\t\t&lt;/ul&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname: &#x27;Person&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname:&#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tcomputed: &#123;\t\t\tpersonList()&#123;\t\t\t\treturn this.$store.state.personAbout.personList\t\t\t&#125;,\t\t\tsum()&#123;\t\t\t\treturn this.$store.state.countAbout.sum\t\t\t&#125;,      firstPersonName()&#123;        return this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]      &#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\tconst personObj = &#123;id:nanoid(),name:this.name&#125;\t\t\t\tthis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,personObj)\t\t\t\tthis.name = &#x27;&#x27;\t\t\t&#125;,      addWang()&#123;        const personObj = &#123;id:nanoid(),name:this.name&#125;        this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,personObj)        this.name = &#x27;&#x27;         &#125;,      addPerson()&#123;        this.$store.dispatch(&#x27;personAbout/addPersonServer&#x27;)      &#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vuex"]},{"title":"Vue（二十九）：VueUI组件库","url":"/2022/04/13/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9AVueUI%E7%BB%84%E4%BB%B6%E5%BA%93/","content":"移动端常用UI组件库\nVant\nCube UI\nMint UI\nnutui（京东）\n\nPC端常用UI组件库\nElement UI（饿了么）\nIView UI\n\nelement-ui基本使用\n安装 element-ui：npm i element-ui -S\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementUI from &#x27;element-ui&#x27;;\t\t\t\t\t\t\t// 引入ElementUI组件库import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;\t// 引入ElementUI全部样式Vue.config.productionTip = falseVue.use(ElementUI)\t// 使用ElementUInew Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),&#125;)\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;br&gt;\t\t&lt;el-row&gt;\t\t\t&lt;el-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/el-button&gt;\t\t\t&lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt;\t\t&lt;/el-row&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;App&#x27;,\t&#125;&lt;/script&gt;\n\nelement-ui按需引入\n安装 babel-plugin-component：npm i babel-plugin-component -D\n\n修改 babel.config.js\nmodule.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;,    [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]  ],  plugins: [    [      &quot;component&quot;,      &#123;                &quot;libraryName&quot;: &quot;element-ui&quot;,        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;      &#125;    ]  ]&#125;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; Button,Row &#125; from &#x27;element-ui&#x27;\t// 按需引入Vue.config.productionTip = falseVue.component(Button.name, Button);Vue.component(Row.name, Row);/* 或写为 * Vue.use(Button) * Vue.use(Row) */new Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),&#125;)\n\n","categories":["Vue"],"tags":["UI"]},{"title":"Vue（二十二）：Vue脚手架之nextTick","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BnextTick/","content":"$nextTick\n这是一个生命周期钩子\n\n\n语法：this.$nextTick(回调函数)\n作用：在下一次DOM更新结束后执行其指定的回调\n什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行\n\n使用 $nextTick 优化 Todo-List案例src/components/MyItem.vue\n&lt;template&gt;  &lt;li&gt;    &lt;label&gt;      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;      &lt;span v-show=&quot;!todo.isEdit&quot;&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;      &lt;input type=&quot;text&quot; v-show=&quot;todo.isEdit&quot; :value=&quot;todo.title&quot;        @blur=&quot;handleBlur(todo, $event)&quot; ref=&quot;inputTitle&quot;/&gt;    &lt;/label&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;    &lt;button v-show=&quot;!todo.isEdit&quot; class=&quot;btn btn-edit&quot; @click=&quot;handleEdit(todo)&quot;&gt;      编辑    &lt;/button&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;MyItem&quot;,    props: [&quot;todo&quot;],\t// 声明接收todo  methods: &#123;    handleCheck(id) &#123;\t\t// 勾选or取消勾选      // 通知App组件将对应的todo对象的done值取反      // this.checkTodo(id)      this.$bus.$emit(&quot;checkTodo&quot;, id);    &#125;,    handleDelete(id) &#123;\t// 删除      if (confirm(&quot;确定删除吗？&quot;)) &#123;        // 通知App组件将对应的todo对象删除        // this.deleteTodo(id)        this.$bus.$emit(&#x27;deleteTodo&#x27;,id)      &#125;    &#125;,    handleEdit(todo) &#123;\t// 编辑      if (todo.hasOwnProperty(&quot;isEdit&quot;)) &#123;        todo.isEdit = true;      &#125; else &#123;        this.$set(todo, &quot;isEdit&quot;, true);      &#125;      this.$nextTick(function () &#123;        this.$refs.inputTitle.focus();      &#125;);    &#125;,    handleBlur(todo, e) &#123;\t// 失去焦点回调（真正执行修改逻辑）      todo.isEdit = false;      if (!e.target.value.trim()) return alert(&quot;输入不能为空！&quot;);      this.$bus.$emit(&quot;updateTodo&quot;, todo.id, e.target.value);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","nextTick"]},{"title":"Vue（二十八）：Vue路由Router","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue%E8%B7%AF%E7%94%B1Router/","content":"相关理解vue-router 的理解\nvue的一个插件库，专门用来实现SPA应用\n\n对SPA应用的理解\n单页Web应用（single page web application，SPA）\n整个应用只有一个完整的页面\n点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n数据需要通过ajax请求获取\n\n\n路由的理解什么是路由?\n一个路由就是一组映射关系（key - value）\nkey为路径，value可能是function或componen\n\n路由分类\n后端路由\n理解：value是function，用于处理客户端提交的请求\n工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n\n\n前端路由\n理解：value是component，用于展示页面内容\n工作过程：当浏览器的路径改变时，对应的组件就会显示\n\n\n\n\n基本路由\n安装vue-router，命令npm i vue-router\n\n应用插件Vue.use(VueRouter)\n\n编写router配置项\nimport VueRouter from &#x27;vue-router&#x27;\t\t\t// 引入VueRouterimport About from &#x27;../components/About&#x27;\t// 路由组件import Home from &#x27;../components/Home&#x27;\t\t// 路由组件// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)//暴露routerexport default router\n\n实现切换\n\n&lt;router-link&gt;&lt;/router-link&gt;浏览器会被替换为a标签\nactive-class可配置高亮样式\n\n&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\n指定展示位&lt;router-view&gt;&lt;/router-view&gt;\n\n\n\n代码示例：\nsrc/router/index.js该文件专门用于创建整个应用的路由器\nimport VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建并暴露一个路由器export default new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;\t// 引入VueRouterimport router from &#x27;./router&#x27;\t\t\t\t// 引入路由器Vue.config.productionTip = falseVue.use(VueRouter)\t// 应用插件new Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App),\trouter:router&#125;)\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;        &lt;div class=&quot;list-group&quot;&gt;\t\t\t\t\t&lt;!-- 原始html中我们使用a标签实现页面的跳转 --&gt;          &lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt; --&gt;          &lt;!-- &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;\t\t\t\t\t&lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;\t\t\t\t\t&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;          &lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;col-xs-6&quot;&gt;        &lt;div class=&quot;panel&quot;&gt;          &lt;div class=&quot;panel-body&quot;&gt;\t\t\t\t\t\t&lt;!-- 指定组件的呈现位置 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;App&#x27;\t&#125;&lt;/script&gt;\n\nsrc/components/Home.vue\n&lt;template&gt;\t&lt;h2&gt;我是Home的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Home&#x27;\t&#125;&lt;/script&gt;\n\nsrc/components/About.vue\n&lt;template&gt;\t&lt;h2&gt;我是About的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;About&#x27;\t&#125;&lt;/script&gt;\n\n几个注意事项\n路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹\n比如上一节的案例就可以修改为\nsrc/pages/Home.vue \nsrc/pages/About.vue \nsrc/router/index.js \nsrc/components/Banner.vue \nsrc/App.vue\n\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n\n每个组件都有自己的$route属性，里面存储着自己的路由信息\n\n整个应用只有一个router（路由器），可以通过组件的$router属性获取到\n\n\n// 该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home        &#125;    ]&#125;)\n\n&lt;template&gt;    &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Banner&#x27;    &#125;&lt;/script&gt;\n\n&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;Banner/&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;        &lt;div class=&quot;list-group&quot;&gt;          &lt;!-- 原始html中我们使用a标签实现页面跳转 --&gt;          &lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;           &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;          &lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;            About&lt;/router-link&gt;          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;            Home&lt;/router-link&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;col-xs-6&quot;&gt;\t\t\t\t&lt;div class=&quot;panel&quot;&gt;\t\t\t\t\t&lt;div class=&quot;panel-body&quot;&gt;\t\t\t\t\t\t&lt;!-- 指定组件的呈现位置 --&gt;\t\t\t\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Banner from &#x27;./components/Banner.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; Banner &#125;\t&#125;&lt;/script&gt;\n\n多级（嵌套）路由\n配置路由规则，使用children配置项\nroutes:[\t&#123;\t\tpath:&#x27;/about&#x27;,\t\tcomponent:About,\t&#125;,\t&#123;\t\tpath:&#x27;/home&#x27;,\t\tcomponent:Home,\t\tchildren:[ \t\t\t\t\t// 通过children配置子级路由\t\t\t&#123;\t\t\t\tpath:&#x27;news&#x27;, \t\t// 此处一定不要带斜杠，写成 /news\t\t\t\tcomponent:News\t\t\t&#125;,\t\t\t&#123;\t\t\t\tpath:&#x27;message&#x27;,\t// 此处一定不要写成 /message\t\t\t\tcomponent:Message\t\t\t&#125;\t\t]\t&#125;]\n\n跳转(要写完整路径)\n&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n\n\n\n代码示例：\nsrc/pages/Home.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;h2&gt;Home组件内容&lt;/h2&gt;\t\t&lt;div&gt;\t\t\t&lt;ul class=&quot;nav nav-tabs&quot;&gt;\t\t\t\t&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;\t\t\t\t&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot;                        active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t\t&lt;router-view&gt;&lt;/router-view&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Home&#x27;,\t&#125;&lt;/script&gt;\n\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;news001&lt;/li&gt;        &lt;li&gt;news002&lt;/li&gt;        &lt;li&gt;news003&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;a href=&quot;/message1&quot;&gt;message001&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;/message2&quot;&gt;message002&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;/message/3&quot;&gt;message003&lt;/a&gt;&amp;nbsp;&amp;nbsp;        &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;//创建并暴露一个路由器export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message                &#125;            ]        &#125;    ]&#125;)\n\n路由传参路由的query参数\n传递参数\n&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数，to的对象写法（推荐） --&gt;&lt;router-link \t:to=&quot;&#123;\t\tpath:&#x27;/home/message/detail&#x27;,\t\tquery:&#123;\t\t   id: m.id,       title: m.title\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数\n$route.query.id$route.query.title\n\n\n\n\n代码示例：\nsrc/router.index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;// 创建并暴露一个路由器export default new VueRouter(&#123;  routes:[    &#123;      path:&#x27;/about&#x27;,      component:About    &#125;,    &#123;      path:&#x27;/home&#x27;,      component:Home,      children:[        &#123;          path:&#x27;news&#x27;,          component:News        &#125;,        &#123;          path:&#x27;message&#x27;,          component:Message,          children:[            &#123;              path:&#x27;detail&#x27;,              component:Detail            &#125;          ]        &#125;      ]    &#125;  ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;        &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;        &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;                      &#123;&#123;m.title&#125;&#125;    \t\t\t\t &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;        &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;        &lt;router-link :to=&quot;&#123;                            path:&#x27;/home/message/detail&#x27;,                            query:&#123;                              id:m.id,                              title:m.title                            &#125;                          &#125;&quot;&gt;          &#123;&#123;m.title&#125;&#125;      &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;      &lt;/li&gt;    &lt;/ul&gt;    &lt;hr/&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;News&#x27;,    data()&#123;      return&#123;        messageList:[          &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,          &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,          &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;        ]      &#125;    &#125;  &#125;&lt;/script&gt;\n\nsrc/pages/Detail.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123; $route.query.id &#125;&#125;&lt;/li&gt;        &lt;li&gt;消息标题：&#123;&#123; $route.query.title &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;    &#125;&lt;/script&gt;\n\n命名路由\n作用：可以简化路由的跳转\n\n如何使用\n\n给路由命名\n&#123;\tpath:&#x27;/demo&#x27;,\tcomponent:Demo,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;test&#x27;,\t\t\tcomponent:Test,\t\t\tchildren:[\t\t\t\t&#123;          name:&#x27;hello&#x27; // 给路由命名\t\t\t\t\tpath:&#x27;welcome&#x27;,\t\t\t\t\tcomponent:Hello,\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n简化跳转\n&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;hello&#x27;,\t\tquery:&#123;\t\t    id:666,        title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message,                    children:[                        &#123;                            name:&#x27;detail&#x27;,\t// name配置项为路由命名                            path:&#x27;detail&#x27;,                            component:Detail                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;                &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;                &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;detail&#x27;,\t//使用name进行跳转                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n路由的params参数\n配置路由，声明接收params参数\n&#123;\tpath:&#x27;/home&#x27;,\tcomponent:Home,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;news&#x27;,\t\t\tcomponent:News\t\t&#125;,\t\t&#123;\t\t\tcomponent:Message,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiangqing&#x27;,\t\t\t\t\tpath:&#x27;detail/:id/:title&#x27;, // 🔴使用占位符声明接收params参数\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n传递参数\n\n特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t   id:666,       title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数\n$route.params.id$route.params.title\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;    routes:[        &#123;            path:&#x27;/about&#x27;,            component:About        &#125;,        &#123;            path:&#x27;/home&#x27;,            component:Home,            children:[                &#123;                    path:&#x27;news&#x27;,                    component:News                &#125;,                &#123;                    path:&#x27;message&#x27;,                    component:Message,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail/:id/:title&#x27;,\t// 使用占位符声明接收params参数                            component:Detail                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                              &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt;                &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;xiangqing&#x27;,                    params:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;&amp;nbsp;&amp;nbsp;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                  &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                  &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                  &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n​        src/pages/Detail.vue\n&lt;template&gt;  &lt;ul&gt;    &lt;li&gt;消息编号：&#123;&#123; $route.params.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;消息标题：&#123;&#123; $route.params.title &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;    &#125;&lt;/script&gt;\n\n路由的props参数\nprops作用：让路由组件更方便的收到参数\n&#123;\tname:&#x27;xiangqing&#x27;,\tpath:&#x27;detail/:id&#x27;,\tcomponent:Detail,\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\t// props:&#123;a:900&#125;\t//第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件\t// props:true\t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\tprops($route)&#123;\t\treturn &#123;\t\t\tid: $route.query.id,\t\t\ttitle: $route.query.title\t\t&#125;\t&#125;&#125;\n\n代码示例：\nsrc/router/index.js\nimport VueRouter from &quot;vue-router&quot;;import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;export default new VueRouter(&#123;  routes:[    &#123;      path: &#x27;/about&#x27;,      component: About    &#125;,    &#123;      path:&#x27;/home&#x27;,      component:Home,      children:[        &#123;          path:&#x27;news&#x27;,          component:News        &#125;,        &#123;          path:&#x27;message&#x27;,          component:Message,          children:[            &#123;              name:&#x27;xiangqing&#x27;,              path:&#x27;detail/:id/:title&#x27;,              component:Detail,              // props的第一种写法，值为对象，              // 该对象中的所有key-value都会以props的形式传给Detail组件              // props:&#123;a:1,b:&#x27;hello&#x27;&#125;              // props的第二种写法，值为布尔值，              // 若布尔值为真，会把该路由组件收到的所有params参数，以props的形式传给Detail组件              // props:true              // props的第三种写法，值为函数              props(params) &#123; // 这里可以使用解构赋值                return &#123;                  id: params.id,                  title: params.title,                &#125;              &#125;            &#125;          ]        &#125;      ]    &#125;  ]&#125;)\n\nsrc/pages/Message.vue\n&lt;template&gt;\t&lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;        &lt;router-link :to=&quot;&#123;                name:&#x27;xiangqing&#x27;,                params:&#123;                    id:m.id,                    title:m.title                &#125;         &#125;&quot;&gt;          \t&#123;&#123;m.title&#125;&#125;  \t\t\t&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;  \t\t&lt;/li&gt;  \t&lt;/ul&gt;    &lt;hr/&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;    &#125;&lt;/script&gt;\n\n​        src/pages/Detail.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;消息编号：&#123;&#123; id &#125;&#125;&lt;/li&gt;        &lt;li&gt;消息标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Detail&#x27;,        props:[&#x27;id&#x27;,&#x27;title&#x27;]    &#125;&lt;/script&gt;\n\n路由跳转的replace方法\n作用：控制路由跳转时操作浏览器历史记录的模式（前进后退）\n\n浏览器的历史记录有两种写入方式：push和replace\n\npush是追加历史记录\nreplace是替换当前记录，路由跳转时候默认为push方式\n\n\n开启replace模式\n&lt;router-link :replace=&quot;true&quot; ...&gt;News&lt;/router-link&gt;\n简写&lt;router-link replace ...&gt;News&lt;/router-link&gt;\n\n\n总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换\nsrc/pages/Home.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Home组件内容&lt;/h2&gt;    &lt;div&gt;      &lt;ul class=&quot;nav nav-tabs&quot;&gt;        &lt;li&gt;          &lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;    \t\t&lt;/li&gt;        &lt;li&gt;          &lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;    \t\t&lt;/li&gt;    &lt;/ul&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Home&#x27;  &#125;&lt;/script&gt;\n\n编程式路由导航（不用&lt;router-link&gt;）\n作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活\nthis.$router.push(&#123;&#125;) 内传的对象与&lt;router-link&gt;中的to相同\nthis.$router.replace(&#123;&#125;)\nthis.$router.forward() 前进\nthis.$router.back() 后退\nthis.$router.go(n) 可前进也可后退，n为正数前进n，为负数后退\nthis.$router.push(&#123;\tname:&#x27;xiangqing&#x27;,  params:&#123;    id:xxx,    title:xxx  &#125;&#125;)this.$router.replace(&#123;\tname:&#x27;xiangqing&#x27;,  params:&#123;    id:xxx,    title:xxx  &#125;&#125;)\n\n\n\n\nsrc/components/Banner.vue\n&lt;template&gt;\t&lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;\t\t&lt;div class=&quot;page-header&quot;&gt;\t\t\t&lt;h2&gt;Vue Router Demo&lt;/h2&gt;\t\t\t&lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;\t\t\t&lt;button @click=&quot;forward&quot;&gt;前进&lt;/button&gt;\t\t\t&lt;button @click=&quot;test&quot;&gt;测试一下go&lt;/button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;Banner&#x27;,\t\tmethods:&#123;\t\t\tback()&#123;\t\t\t\tthis.$router.back()\t\t\t&#125;,\t\t\tforward()&#123;\t\t\t\tthis.$router.forward()\t\t\t&#125;,\t\t\ttest()&#123;\t\t\t\tthis.$router.go(3)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/pages/Message.vue\n&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;                &lt;router-link :to=&quot;&#123;                    name:&#x27;xiangqing&#x27;,                    params:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;&quot;&gt;                    &#123;&#123;m.title&#125;&#125;                &lt;/router-link&gt;                &lt;button @click=&quot;showPush(m)&quot;&gt;push查看&lt;/button&gt;                &lt;button @click=&quot;showReplace(m)&quot;&gt;replace查看&lt;/button&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;hr/&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                messageList:[                    &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;                ]            &#125;        &#125;,        methods:&#123;            showPush(m)&#123;                this.$router.push(&#123;                    name:&#x27;xiangqing&#x27;,                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;)            &#125;,            showReplace(m)&#123;                this.$router.replace(&#123;                    name:&#x27;xiangqing&#x27;,                    query:&#123;                        id:m.id,                        title:m.title                    &#125;                &#125;)            &#125;        &#125;    &#125;&lt;/script&gt;\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁\n&lt;keep-alive include=&quot;News&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n&lt;keep-alive :include=&quot;[&#39;News&#39;, &#39;Message&#39;]&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n// 缓存一个路由组件&lt;keep-alive include=&quot;News&quot;&gt; // include中写想要缓存的组件名（不是陆游名），不写表示全部缓存    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 缓存多个路由组件&lt;keep-alive :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n\n\n\n代码示例：\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li&gt;news001 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news002 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news003 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;    &#125;&lt;/script&gt;\n\nsrc/pages/Home.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Home组件内容&lt;/h2&gt;    &lt;div&gt;      &lt;ul class=&quot;nav nav-tabs&quot;&gt;        &lt;li&gt;&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot;                        to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt;    \t&lt;/ul&gt;      &lt;keep-alive include=&quot;News&quot;&gt;        &lt;router-view&gt;&lt;/router-view&gt;    \t&lt;/keep-alive&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Home&#x27;    &#125;&lt;/script&gt;\n\n路由独有的生命周期钩子（activated deactivated）activated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\n具体使用\nactivated路由组件被激活时触发\ndeactivated路由组件失活时触发\n\n\n\n\nsrc/pages/News.vue\n&lt;template&gt;    &lt;ul&gt;        &lt;li :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习vue&lt;/li&gt;        &lt;li&gt;news001 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news002 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;        &lt;li&gt;news003 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;News&#x27;,        data()&#123;            return&#123;                opacity:1            &#125;        &#125;,        activated()&#123;            console.log(&#x27;News组件被激活了&#x27;)            this.timer = setInterval(() =&gt; &#123;                this.opacity -= 0.01                if(this.opacity &lt;= 0) this.opacity = 1            &#125;,16)        &#125;,        deactivated()&#123;            console.log(&#x27;News组件失活了&#x27;)            clearInterval(this.timer)        &#125;    &#125;&lt;/script&gt;\n\n路由守卫\n作用：对路由进行权限控制\n\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫\n\n\n​    meta路由源信息\n// 全局前置守卫：初始化时、每次路由切换前执行router.beforeEach((to,from,next) =&gt; &#123;\tconsole.log(&#x27;beforeEach&#x27;,to,from)\tif(to.meta.isAuth)&#123; // 判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; // 权限控制的具体规则\t\t\tnext()\t// 放行\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t&#125;\t&#125;else&#123;\t\tnext()\t// 放行\t&#125;&#125;)// 全局后置守卫：初始化时、每次路由切换后执行router.afterEach((to,from) =&gt; &#123;\tconsole.log(&#x27;afterEach&#x27;,to,from)\tif(to.meta.title)&#123; \t\tdocument.title = to.meta.title //修改网页的title\t&#125;else&#123;\t\tdocument.title = &#x27;vue_test&#x27;\t&#125;&#125;)\n\n\n独享守卫\n只有前置没有后置，写在路由配置项中\n\n\nbeforeEnter(to,from,next)&#123;\tconsole.log(&#x27;beforeEnter&#x27;,to,from)    if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;        next()    &#125;else&#123;        alert(&#x27;暂无权限查看&#x27;)    &#125;&#125;\n\n\n组件内守卫\n不能说前置、后置，写在组件配置项中\n\n\n//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;... next()&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;... next()&#125;,\n\n全局路由守卫src/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;//创建一个路由器const router = new VueRouter(&#123;    routes:[        &#123;            name:&#x27;guanyv&#x27;,            path:&#x27;/about&#x27;,            component:About,            meta:&#123;title:&#x27;关于&#x27;&#125;        &#125;,        &#123;            name:&#x27;zhuye&#x27;,            path:&#x27;/home&#x27;,            component:Home,            meta:&#123;title:&#x27;主页&#x27;&#125;,            children:[                &#123;                    name:&#x27;xinwen&#x27;,                    path:&#x27;news&#x27;,                    component:News,                    meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;                &#125;,                &#123;                    name:&#x27;xiaoxi&#x27;,                    path:&#x27;message&#x27;,                    component:Message,                    meta:&#123;isAuth:true,title:&#x27;消息&#x27;&#125;,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail&#x27;,                            component:Detail,                            meta:&#123;isAuth:true,title:&#x27;详情&#x27;&#125;,                            props($route)&#123;                                return &#123;                                    id:$route.query.id,                                    title:$route.query.title,                                &#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)// 🔴全局前置路由守卫————初始化的时候、每次路由切换之前被调用router.beforeEach((to,from,next) =&gt; &#123;    console.log(&#x27;前置路由守卫&#x27;,to,from)    if(to.meta.isAuth)&#123;        if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123;            next()        &#125;else&#123;            alert(&#x27;学校名不对，无权限查看！&#x27;)        &#125;    &#125;else&#123;        next()    &#125;&#125;)// 🔴全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;后置路由守卫&#x27;,to,from)\tdocument.title = to.meta.title || &#x27;硅谷系统&#x27;&#125;)// 导出路由器export default router\n\n独享路由守卫src/router/index.js\n//该文件专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;//引入组件import Home from &#x27;../pages/Home&#x27;import About from &#x27;../pages/About&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;//创建一个路由器const router = new VueRouter(&#123;    routes:[        &#123;            name:&#x27;guanyv&#x27;,            path:&#x27;/about&#x27;,            component:About,            meta:&#123;title:&#x27;关于&#x27;&#125;        &#125;,        &#123;            name:&#x27;zhuye&#x27;,            path:&#x27;/home&#x27;,            component:Home,            meta:&#123;title:&#x27;主页&#x27;&#125;,            children:[                &#123;                    name:&#x27;xinwen&#x27;,                    path:&#x27;news&#x27;,                    component:News,                    meta:&#123;title:&#x27;新闻&#x27;&#125;,                    // 🔴独享守卫，特定路由切换之后被调用                    beforeEnter(to,from,next)&#123;                        console.log(&#x27;独享路由守卫&#x27;,to,from)                        if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;                            next()                        &#125;else&#123;                            alert(&#x27;暂无权限查看&#x27;)                        &#125;                    &#125;                &#125;,                &#123;                    name:&#x27;xiaoxi&#x27;,                    path:&#x27;message&#x27;,                    component:Message,                    meta:&#123;title:&#x27;消息&#x27;&#125;,                    children:[                        &#123;                            name:&#x27;xiangqing&#x27;,                            path:&#x27;detail&#x27;,                            component:Detail,                            meta:&#123;title:&#x27;详情&#x27;&#125;,                            props($route)&#123;                                return &#123;                                    id:$route.query.id,                                    title:$route.query.title,                                &#125;                            &#125;                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;)//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;后置路由守卫&#x27;,to,from)\tdocument.title = to.meta.title || &#x27;硅谷系统&#x27;&#125;)//导出路由器export default router\n\n组件内路由守卫src/pages/About.vue\n&lt;template&gt;    &lt;h2&gt;我是About组件的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;About&#x27;,        // 通过路由规则，离开该组件时被调用        beforeRouteEnter (to, from, next) &#123;            console.log(&#x27;About--beforeRouteEnter&#x27;,to,from)            if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123;                next()            &#125;else&#123;                alert(&#x27;学校名不对，无权限查看！&#x27;)            &#125;        &#125;,        // 通过路由规则，离开该组件时被调用        beforeRouteLeave (to, from, next) &#123;            console.log(&#x27;About--beforeRouteLeave&#x27;,to,from)            next()        &#125;    &#125;&lt;/script&gt;\n\n路由器的两种工作模式\n对于一个url来说，什么是hash值？\n#及其后面的内容就是hash值\n\nhash值不会包含在HTTP请求中，即：hash值不会带给服务器\n\nhash模式\n\n地址中永远带着#号，不美观\n若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n兼容性较好\n\n\nhistory模式\n\n地址干净，美观\n兼容性和hash模式相比略差\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\n\n\nconst router =  new VueRouter(&#123;\tmode:&#x27;history&#x27;,\troutes:[...]&#125;)export default router\n\n","categories":["Vue"],"tags":["Vue Router","路由"]},{"title":"Vue（二十六）：slot插槽","url":"/2022/04/12/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9Aslot%E6%8F%92%E6%A7%BD/","content":"slot插槽&lt;slot&gt;插槽：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式\n\n默认插槽\n父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件Category中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n具名插槽\n父组件指明放入子组件的哪个插槽，如slot=&quot;footer&quot;，如果是template可以写成v-slot:footer\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n作用域插槽\nscope用于父组件往子组件插槽放的html结构接收子组件的数据\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n父组件中：        &lt;Category&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                  &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\t\t        &lt;script&gt;            export default &#123;                name:&#x27;Category&#x27;,                props:[&#x27;title&#x27;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;\n\n\n\n","categories":["Vue"],"tags":["插槽"]},{"title":"Vue（二十五）：Vue中的ajax","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9AVue%E4%B8%AD%E7%9A%84ajax/","content":"解决开发环境Ajax跨域问题\n使用代理服务器\nVue（二十四）：Vue脚手架之配置代理\n\nvue项目中常用的Ajax库：axios\n\n\ngithub用户搜索案例public/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;!-- 开启移动端的理想端口 --&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;!-- 配置页签图标 --&gt;        &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;              &lt;!-- 引入bootstrap样式 --&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;&gt;              &lt;!-- 配置网页标题 --&gt;        &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 容器 --&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App),    beforeCreate()&#123;        Vue.prototype.$bus = this    &#125;&#125;)\n\nsrc/App.vue\n&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;Search/&gt;    &lt;List/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Search from &#x27;./components/Search.vue&#x27;  import List from &#x27;./components/List.vue&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; Search, List &#125;,  &#125;&lt;/script&gt;\n\nsrc/components/Search.vue\n&lt;template&gt;  &lt;section class=&quot;jumbotron&quot;&gt;    &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot;/&gt;&amp;nbsp;      &lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;    &lt;/div&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123;  name: &quot;Search&quot;,  data() &#123;    return &#123;      keyWord: &quot;&quot;,    &#125;;  &#125;,  methods: &#123;    searchUsers() &#123;      //请求前更新List的数据      this.$bus.$emit(&quot;updateListData&quot;, &#123;        isLoading: true,        errMsg: &quot;&quot;,        users: [],        isFirst: false,      &#125;);      axios.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then(        (response) =&gt; &#123;          console.log(&quot;请求成功了&quot;);          this.$bus.$emit(&quot;updateListData&quot;, &#123;\t//请求成功后更新List的数据            isLoading: false,            errMsg: &quot;&quot;,            users: response.data.items,          &#125;);        &#125;,        (error) =&gt; &#123;          this.$bus.$emit(&quot;updateListData&quot;, &#123;\t//请求后更新List的数据            isLoading: false,            errMsg: error.message,            users: [],          &#125;);        &#125;      );    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\nsrc/components/List.vue\n&lt;template&gt;  &lt;div class=&quot;row&quot;&gt;    &lt;!-- 展示用户列表 --&gt;    &lt;div v-show=&quot;info.users.length&quot; class=&quot;card&quot;          v-for=&quot;user in info.users&quot; :key=&quot;user.login&quot;&gt;      &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;        &lt;img :src=&quot;user.avatar_url&quot; style=&quot;width: 100px&quot; /&gt;      &lt;/a&gt;      &lt;p class=&quot;card-text&quot;&gt;&#123;&#123; user.login &#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;!-- 展示欢迎词 --&gt;    &lt;h1 v-show=&quot;info.isFirst&quot;&gt;欢迎使用！&lt;/h1&gt;    &lt;!-- 展示加载中 --&gt;    &lt;h1 v-show=&quot;info.isLoading&quot;&gt;加载中....&lt;/h1&gt;    &lt;!-- 展示错误信息 --&gt;    &lt;h1 v-show=&quot;info.errMsg&quot;&gt;&#123;&#123; info.errMsg &#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;List&quot;,  data() &#123;    return &#123;      info: &#123;        isFirst: true,        isLoading: false,        errMsg: &quot;&quot;,        users: [],      &#125;,    &#125;;  &#125;,  mounted() &#123;    this.$bus.$on(&quot;updateListData&quot;, (dataObj) =&gt; &#123;      this.info = &#123; ...this.info, ...dataObj &#125;;    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.album &#123;min-height: 50rem; /* Can be removed; just added for demo purposes */  padding-top: 3rem;padding-bottom: 3rem;background-color: #f7f7f7;&#125;.card &#123;float: left;width: 33.333%;padding: 0.75rem;margin-bottom: 2rem;  border: 1px solid #efefef;text-align: center;&#125;.card &gt; img &#123;margin-bottom: 0.75rem;border-radius: 100px;&#125;.card-text &#123;font-size: 85%;&#125;&lt;/style&gt;\n\n\nvue-resource","categories":["Vue"],"tags":["Vue CLI","跨域问题"]},{"title":"Vue（二十四）：Vue脚手架之配置代理","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/","content":"Vue脚手架配置代理本案例需要下载axios库npm install axios\n配置参考文档 Vue-Cli devServer.proxy\nvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue&#x2F;cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写\n\n方法一\n在vue.config.js中添加如下配置\nmodule.exports = &#123;  devServer:&#123;    proxy:&quot;http://localhost:5000&quot;  &#125;&#125;\n\n说明\n\n优点：配置简单，请求资源时直接发给前端（8080）即可\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，才会将请求会转发给服务器 （优先匹配前端资源）\n\n\n\n\n方法二\n编写vue.config.js配置具体代理规则\nmodule.exports = &#123;\tdevServer: &#123;      proxy: &#123;      &#x27;/api1&#x27;: &#123;\t\t\t\t\t\t\t\t\t\t\t\t\t// 匹配所有以 &#x27;/api1&#x27;开头的请求路径        target: &#x27;http://localhost:5000&#x27;,\t// 代理目标的基础路径        pathRewrite: &#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125;,\t\t\t\t// 代理往后端服务器的请求去掉 /api1 前缀        ws: true,\t\t\t\t\t\t\t\t\t\t\t\t\t// WebSocket        changeOrigin: true,              &#125;,      &#x27;/api2&#x27;: &#123;        target: &#x27;http://localhost:5001&#x27;,        pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;,        changeOrigin: true      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000（撒谎）跨域   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080（不撒谎）不跨域   changeOrigin默认值为true*/\n\n说明\n\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理\n缺点：配置略微繁琐，请求资源时必须加前缀\n\n\n代码示例：\nvue.config.js\nmodule.exports = &#123;    pages: &#123;        index: &#123;            entry: &#x27;src/main.js&#x27;,        &#125;,    &#125;,    lintOnSave:false,    // 开启代理服务器（方式一）    // devServer: &#123;    //     proxy:&#x27;http://localhost:5000&#x27;    // &#125;    //开启代理服务器（方式二）\tdevServer: &#123;        proxy: &#123;            &#x27;/api1&#x27;: &#123;                target: &#x27;http://localhost:5000&#x27;,                pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125;,                // ws: true, //用于支持websocket,默认值为true                // changeOrigin: true //用于控制请求头中的host值,默认值为true            &#125;,            &#x27;/api2&#x27;: &#123;                target: &#x27;http://localhost:5001&#x27;,                pathRewrite:&#123;&#x27;^/api2&#x27;:&#x27;&#x27;&#125;,            &#125;        &#125;    &#125;&#125;\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;button @click=&quot;getStudents&quot;&gt;获取学生信息&lt;/button&gt;\t\t&lt;button @click=&quot;getCars&quot;&gt;获取汽车信息&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport axios from &#x27;axios&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tmethods: &#123;\t\t\tgetStudents() &#123;\t\t\t\taxios.get(&#x27;http://localhost:8080/students&#x27;).then(\t\t\t\t\tresponse =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求成功了&#x27;,response.data)\t\t\t\t\t&#125;,\t\t\t\t\terror =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求失败了&#x27;,error.message)\t\t\t\t\t&#125;\t\t\t\t)\t\t\t&#125;,\t\t\tgetCars() &#123;\t\t\t\taxios.get(&#x27;http://localhost:8080/demo/cars&#x27;).then(\t\t\t\t\tresponse =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求成功了&#x27;,response.data)\t\t\t\t\t&#125;,\t\t\t\t\terror =&gt; &#123;\t\t\t\t\t\tconsole.log(&#x27;请求失败了&#x27;,error.message)\t\t\t\t\t&#125;\t\t\t\t)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n\n\n\n","categories":["Vue"],"tags":["Vue CLI","配置代理"]},{"title":"Vue（二十）：Vue脚手架之全局事件总线","url":"/2022/04/11/Vue%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","content":"全局事件总线（GlobalEvenBus）一种可以在任意组件间通信的方式，本质上就是一个对象，它必须满足以下条件：\n\n所有的组件对象都必须能看见他\n这个对象必须能够使用$on $emit $off方法去绑定、触发和解绑事件\n\n\n利用一个重要的内置关系：VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype，定义全局事件总线，使得所有组件都能看得见它\n\n使用步骤\n定义全局事件总线\nnew Vue(&#123;   \t...   \tbeforeCreate() &#123;   \t\tVue.prototype.$bus = this // 安装全局事件总线，$bus 就是当前应用的 vm   \t&#125;,    ...&#125;)\n\n使用事件总线：A与B通信\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\nexport default &#123;    methods()&#123;        demo(data)&#123;...&#125;    &#125;    ...    mounted() &#123;        this.$bus.$on(&#x27;xxx&#x27;,this.demo)    &#125;&#125;\n\n提供数据：B提供数据，在B中\nthis.$bus.$emit(&#39;xxx&#39;,data)\n\n\n\n最好在beforeDestroy钩子中，用$off()去解绑当前组件所用到的事件\n\n\n代码示例\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this // 安装全局事件总线  &#125;&#125;)\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div class=&quot;app&quot;&gt;\t\t&lt;School/&gt;\t\t&lt;Student/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport Student from &#x27;./components/Student&#x27;\timport School from &#x27;./components/School&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; School, Student &#125;\t&#125;&lt;/script&gt;&lt;style scoped&gt;.app&#123;background-color: gray;padding: 5px;&#125;&lt;/style&gt;\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;school&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;School&quot;,    data() &#123;      return &#123;        name: &quot;尚硅谷&quot;,        address: &quot;北京&quot;,      &#125;;    &#125;,    mounted() &#123;  //🔴      // console.log(&#x27;School&#x27;,this)      this.$bus.$on(&quot;hello&quot;, (data) =&gt; &#123;        console.log(&quot;我是School组件，收到了数据&quot;, data);      &#125;);    &#125;,    beforeDestroy() &#123;  //🔴      this.$bus.$off(&quot;hello&quot;);    &#125;,  &#125;;&lt;/script&gt;&lt;style scoped&gt;.school &#123;background-color: skyblue;padding: 5px;&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;student&quot;&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt; //🔴  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,    methods: &#123;  //🔴      sendStudentName()&#123;        this.$bus.$emit(&#x27;demo&#x27;, this.name)      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;.student&#123;background-color: pink;padding: 5px;margin-top: 30px;&#125;&lt;/style&gt;\n\n\n使用全局事件总线优化Todo-List案例\n并非所有通信都需要改成全局事件总线：\n父传子直接用props；子传父用props、自定义组件；\n兄弟之间通信、或者跨级通信用全局事件总线\n\n此案例中，MyItem和App之间适用全局事件总线\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this // 安装全局事件总线  &#125;&#125;)\n\nsrc/App.vue 删除给MyItem绑定的事件，利用this.$bus.$on给总线bus绑定事件\n&lt;template&gt;  &lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyFooter from &#x27;./components/MyFooter&#x27;\timport MyList from &#x27;./components/MyList&#x27;\texport default &#123;\t\tname: &#x27;App&#x27;,\t\tcomponents: &#123;MyHeader,MyFooter,MyList&#125;,\t\tdata()&#123;\t\t\treturn&#123;\t\t\t\ttodos:[\t\t\t\t\t&#123;id:&#x27;0001&#x27;,title:&#x27;吃饭&#x27;,done:true&#125;,\t\t\t\t\t&#123;id:&#x27;0002&#x27;,title:&#x27;喝酒&#x27;,done:false&#125;,\t\t\t\t\t&#123;id:&#x27;0003&#x27;,title:&#x27;开车&#x27;,done:true&#125;,\t\t\t\t]\t\t\t&#125;\t\t&#125;,\t\tmethods:&#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter((todo) =&gt;&#123;\t\t\t\t\treturn todo.id !== id\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,\t\tmounted()&#123;\t\t\tthis.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo)\t\t\tthis.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo)\t\t&#125;,\t\tbeforeDestroy()&#123;\t\t\tthis.$bus.$off(&#x27;checkTodo&#x27;)\t\t\tthis.$bus.$off(&#x27;deleteTodo&#x27;)\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;  ……&lt;/style&gt;\n\nsrc/components/MyList.vue 删除给MyItem绑定的事件，删除props中接收的事件数据\nsrc/components/MyItem.vue 删除props中接收的事件数据，利用this.$bus.$emit触发事件\n&lt;template&gt;  &lt;li&gt;\t\t&lt;label&gt;\t\t\t&lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;\t\t\t&lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;\t\t\t&lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;\t\t\t&lt;span&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;\t\t&lt;/label&gt;\t\t&lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;\t&lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;MyItem&#x27;,\tprops:[&#x27;todo&#x27;],\tmethods:&#123;\t\t//勾选or取消勾选\t\thandleCheck(id)&#123;\t\t\t//通知App组件将对应的todo对象的done值取反\t\t\t// this.checkTodo(id)\t\t\tthis.$bus.$emit(&#x27;checkTodo&#x27;,id)\t\t&#125;,\t\t//删除\t\thandleDelete(id)&#123;\t\t\tif(confirm(&#x27;确定删除吗？&#x27;))&#123;\t\t\t\t//通知App组件将对应的todo对象删除\t\t\t\t// this.deleteTodo(id)\t\t\t\tthis.$bus.$emit(&#x27;deleteTodo&#x27;,id)\t\t\t&#125;\t\t&#125;\t&#125;,\tmounted()&#123;\t\t\t&#125;&#125;&lt;/script&gt;&lt;style&gt;    ……&lt;/style&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","全局事件总线"]},{"title":"Vue（二）：模板语法与数据绑定","url":"/2022/04/01/Vue%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","content":"模板语法插值语法\n功能：用于解析标签体内容\n写法：，xxx 是 js 表达式，可以直接读取到 data 中的所有区域\n\n指令语法\n功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）\n举例：&lt;a v-bind:href=&quot;xxx&quot;&gt;或简写为&lt;a :href=&quot;xxx&quot;&gt;，xxx 同样要写 js 表达式，可以直接读取到 data 中的所有属性\n备注：Vue中有很多的指令，且形式都是 v-xxx，此处只是拿v-bind举例\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;插值语法&lt;/h2&gt;      &lt;h4&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h4&gt;      &lt;hr /&gt;      &lt;h2&gt;指令语法&lt;/h2&gt;      &lt;a v-bind:href=&quot;tencent.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去看&#123;&#123; tencent.name &#125;&#125;1&lt;/a&gt;      &lt;a :href=&quot;tencent.url&quot; x=&quot;hello&quot;&gt;点我去看&#123;&#123; tencent.name &#125;&#125;2&lt;/a&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    new Vue(&#123;      el: &#x27;#root&#x27;,      data: &#123;        name: &#x27;jack&#x27;,        tencent: &#123;          name: &#x27;开端&#x27;,          url: &#x27;https://v.qq.com/x/cover/mzc00200mp8vo9b/n0041aa087e.html&#x27;,        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/html&gt;\n\n数据绑定单向绑定\nv-bind数据只能从 data 流向页面\n\n双向绑定\nv-model数据不仅能从 data 流向页面，还可以从页面流向 data\n备注\n双向绑定一般都应用在表单类元素上，如 &lt;input&gt; &lt;select&gt; &lt;textarea&gt;等\nv-model:value可以简写为v-model，因为v-model默认收集的就是value值\n\n\n\n&lt;div id=&quot;root&quot;&gt;    &lt;!-- 普通写法 --&gt;    &lt;!-- 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;    &lt;!-- 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;    &lt;!-- 简写 --&gt;    单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;    双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;    &lt;!-- 如下代码是错误的，因为 v-model 只能应用在表单类元素（输入类元素）上 --&gt;    &lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false // 阻止 vue 在启动时生成生产提示。    new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;        &#125;    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["模板语法","数据绑定"]},{"title":"Vue（五）：事件处理","url":"/2022/04/01/Vue%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","content":"事件的基本用法\n使用v-on:xxx或@xxx绑定事件，其中 xxx 是事件名\n事件的回调需要配置在methods对象中，最终会在vm上\nmethods中配置的函数，不要用箭头函数，否则 this 就不是vm了\nmethods中配置的函数，都是被 Vue所管理的函数，this 的指向是vm 或 组件实例对象\n@click=&quot;demo&quot;和@click=&quot;demo($event)&quot;效果一致，但后者可以传参\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来看&#123;&#123;name&#125;&#125;的笔记&lt;/h2&gt;    &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;    &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1（不传参）&lt;/button&gt;    &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。    const vm = new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;,        &#125;,        methods: &#123;            showInfo1(event) &#123;                console.log(event.target.innerText)                // console.log(this) // 此处的this是vm                alert(&#x27;同学你好！&#x27;)            &#125;,            showInfo2(event, number) &#123;                console.log(event, number)                console.log(event.target.innerText)                // console.log(this) // 此处的this是vm                alert(&#x27;同学你好！！&#x27;)            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n事件修饰符Vue中的事件修饰符\n\nprevent 阻止默认事件（常用）\nstop 阻止事件冒泡（常用）\nonce 事件只触发一次（常用）\ncapture 使用事件的捕获模式\nself 只有event.target是当前操作的元素时才触发事件\npassive 事件的默认行为立即执行，无需等待事件回调执行完毕\n修饰符可以连续写，比如可以这么用：@click.prevent.stop=&quot;showInfo&quot;\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来到&#123;&#123; name &#125;&#125;学习&lt;/h2&gt;&lt;!-- 阻止默认事件（常用） --&gt;&lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;&lt;!-- 阻止事件冒泡（常用） --&gt;&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;    &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;!-- 修饰符可以连续写 --&gt;&lt;!-- &lt;a href=&quot;http://www.qq.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示&lt;/a&gt; --&gt;&lt;/div&gt;&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;!-- 使用事件的捕获模式： 在捕获阶段就触发，而不是在冒泡阶段触发--&gt;&lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;    div1    &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;        div2    &lt;/div&gt;&lt;/div&gt;&lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt;&lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;    &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;&lt;/div&gt;    &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt;    &lt;!-- scroll是滚动条滚动，passive没有影响 --&gt;    &lt;!-- wheel是鼠标滚轮滚动，passive有影响 --&gt;    &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = falsenew Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;        name: &#x27;尚硅谷&#x27;    &#125;,    methods: &#123;        showInfo(e) &#123;            alert(&#x27;同学你好！&#x27;)            // console.log(e.target)        &#125;,        showMsg(msg) &#123;            console.log(msg)        &#125;,        demo() &#123;            for (let i = 0; i &lt; 100000; i++) &#123;                console.log(&#x27;#&#x27;)            &#125;            console.log(&#x27;累坏了&#x27;)        &#125;    &#125;&#125;)&lt;/script&gt;\n\n键盘事件\n键盘上的每个按键都有自己的名称和编码，例如：Enter（13）。而Vue还对一些常用按键起了别名方便使用\n\n\nVue中常用的按键别名回车enter删除delete（捕获“删除”和“退格”键）退出esc空格space换行tab（特殊，必须配合keydown去使用）keydown.tab上up下down左left右right\nVue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（多单词小写短横线写法）\n系统修饰键（用法特殊）ctrl alt shift meta（meta就是win键）\n配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发指定 ctr+y 使用 @keyup.ctr.y\n配合keydown使用：正常触发事件\n\n\n也可以使用keyCode去指定具体的按键（不推荐）\nVue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎打开&#123;&#123;name&#125;&#125;笔记&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.enter=&quot;showInfo&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下tab提示输入&quot; @keydown.tab=&quot;showInfo&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot;&gt;&lt;br/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false\t// 阻止 vue 在启动时生成生产提示。    Vue.config.keyCodes.huiche = 13\t\t// 定义了一个别名按键    new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name: &#x27;cess&#x27;        &#125;,        methods: &#123;            showInfo(e) &#123;                // console.log(e.key,e.keyCode)                console.log(e.target.value)            &#125;        &#125;,    &#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["事件处理"]},{"title":"Vue（八）：列表渲染","url":"/2022/04/01/Vue%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/","content":"基本列表v-for指令\n用于展示列表数据\n语法：&lt;li v-for=&quot;(item,index) of items&quot; :key=&quot;index&quot;&gt;,这里key可以是index，更好的是遍历对象的唯一标识:key=&quot;item.id&quot;\n可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\n\n&lt;title&gt;基本列表&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 遍历数组 --&gt;  &lt;h3&gt;人员列表（遍历数组）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;&#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历对象 --&gt;  &lt;h3&gt;汽车信息（遍历对象）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;&#123;&#123; k &#125;&#125;-&#123;&#123; value &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历字符串 --&gt;  &lt;h3&gt;测试遍历字符串（用得少）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;&#123;&#123; char &#125;&#125;-&#123;&#123; index &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 遍历指定次数 --&gt;  &lt;h3&gt;测试遍历指定次数（用得少）&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;&#123;&#123; index &#125;&#125;-&#123;&#123; number &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;张三&#x27;, age: 18 &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;李四&#x27;, age: 19 &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;王五&#x27;, age: 20 &#125;      ],      car: &#123;        name: &#x27;奥迪A8&#x27;,        price: &#x27;70万&#x27;,        color: &#x27;黑色&#x27;      &#125;,      str: &#x27;hello&#x27;    &#125;  &#125;)&lt;/script&gt;\n\n\nkey的作用与原理\n\n面试题：react、vue中的key有什么作用？（key的内部原理）\n虚拟DOM中key的作用：key是虚拟DOM中对象的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后Vue进行新虚拟DOM与旧虚拟DOM的差异比较(diff算法），比较规则如下\n对比规则\n旧虚拟DOM中找到了与新虚拟DOM相同的key\n若虚拟DOM中内容没变, 直接使用之前的真实DOM\n若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM\n\n\n旧虚拟DOM中未找到与新虚拟DOM相同的key\n创建新的真实DOM，随后渲染到到页面\n\n\n\n\n用index作为key可能会引发的问题\n若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题，但效率低\n若结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题\n\n\n开发中如何选择key？\n最好使用每条数据的唯一标识作为key，比如 id、手机号、身份证号、学号等唯一值\n如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;  &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;张三&#x27;, age: 18 &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;李四&#x27;, age: 19 &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;王五&#x27;, age: 20 &#125;      ]    &#125;,    methods: &#123;      add() &#123;        const p = &#123; id: &#x27;004&#x27;, name: &#x27;老刘&#x27;, age: 40 &#125;        this.persons.unshift(p)      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\n\n列表过滤&lt;title&gt;列表过滤&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123; p.name &#125;&#125;-&#123;&#123; p.age &#125;&#125;-&#123;&#123; p.sex &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 用 watch 实现  // #region   /* new Vue(&#123;\t\t\tel: &#x27;#root&#x27;,\t\t\tdata: &#123;\t\t\t\tkeyWord: &#x27;&#x27;,\t\t\t\tpersons: [\t\t\t\t\t&#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;,\t\t\t\t\t&#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125;\t\t\t\t],\t\t\t\tfilPersons: []\t\t\t&#125;,\t\t\twatch: &#123;\t\t\t\tkeyWord: &#123;\t\t\t\t\timmediate: true,\t\t\t\t\thandler(val) &#123;\t\t\t\t\t\tthis.filPersons = this.persons.filter((p) =&gt; &#123;\t\t\t\t\t\t\treturn p.name.indexOf(val) !== -1\t\t\t\t\t\t&#125;)\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;) */  //#endregion  // 用 computed 实现  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      keyWord: &#x27;&#x27;,      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 19, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 20, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 21, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 22, sex: &#x27;男&#x27; &#125;      ]    &#125;,    computed: &#123;      filPersons() &#123;        return this.persons.filter((p) =&gt; &#123;          return p.name.indexOf(this.keyWord) !== -1        &#125;)      &#125;    &#125;  &#125;) &lt;/script&gt;\n\n\n列表排序&lt;title&gt;列表排序&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;人员列表&lt;/h2&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;  &lt;button @click=&quot;sortType = 2&quot;&gt;年龄升序&lt;/button&gt;  &lt;button @click=&quot;sortType = 1&quot;&gt;年龄降序&lt;/button&gt;  &lt;button @click=&quot;sortType = 0&quot;&gt;原顺序&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;      &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      keyWord: &#x27;&#x27;,      sortType: 0, // 0原顺序 1降序 2升序      persons: [        &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 30, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 31, sex: &#x27;女&#x27; &#125;,        &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 18, sex: &#x27;男&#x27; &#125;,        &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 19, sex: &#x27;男&#x27; &#125;      ]    &#125;,    computed: &#123;      filPersons() &#123;        const arr = this.persons.filter((p) =&gt; &#123;          return p.name.indexOf(this.keyWord) !== -1        &#125;)        //判断一下是否需要排序        if (this.sortType) &#123;          arr.sort((p1, p2) =&gt; &#123;            return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age          &#125;)        &#125;        return arr      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["列表渲染"]},{"title":"Vue（六）：计算属性与监视属性","url":"/2022/04/01/Vue%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/","content":"计算属性：computed姓名案例\n插值语法实现&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;  全名：&lt;span&gt;&#123;&#123; firstName &#125;&#125;-&#123;&#123; lastName &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      firstName:&#x27;张&#x27;,      lastName:&#x27;三&#x27;    &#125;  &#125;)&lt;/script&gt;\n\nmethod实现数据发生变化，模板就会被重新解析\n&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt;  全名：&lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      firstName: &#x27;张&#x27;,      lastName: &#x27;三&#x27;    &#125;,    methods: &#123;      fullName() &#123;        return this.firstName + &#x27;-&#x27; + this.lastName      &#125;    &#125;,  &#125;)&lt;/script&gt;\n\ncomputed计算属性实现\n定义：要用的属性不存在，需要通过已有属性（不是已有变量）计算得来\n原理：底层借助了Objcet.defineproperty()方法提供的getter和setter\nget函数什么时候执行？\n初次读取时会执行一次\n当依赖的数据发生改变时会被再次调用\n\n\n优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n备注\n计算属性最终会出现在vm上，直接读取使用即可\n如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变\n如果计算属性确定不考虑修改，可以使用计算属性的简写形式\n\n\n\n&lt;div id=&quot;root&quot;&gt;  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;  测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br/&gt;\t// 这里修改 不会调 fullName的get方法  全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;  &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;  &lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      firstName:&#x27;张&#x27;,      lastName:&#x27;三&#x27;,      x:&#x27;你好&#x27;    &#125;,    computed: &#123;      //完整写法      // fullName: &#123;      // \tget() &#123;      // \t\tconsole.log(&#x27;get被调用了&#x27;)      // \t\treturn this.firstName + &#x27;-&#x27; + this.lastName      // \t&#125;,      // \tset(value) &#123;      // \t\tconsole.log(&#x27;set&#x27;, value)      // \t\tconst arr = value.split(&#x27;-&#x27;)      // \t\tthis.firstName = arr[0]      // \t\tthis.lastName = arr[1]      // \t&#125;      // &#125;      // 简写（只读不改 ）      fullName() &#123;        console.log(&#x27;get被调用了&#x27;)        return this.firstName + &#x27;-&#x27; + this.lastName      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n面试题：method和computed的区别？\n\n监视（侦听）属性：watch天气案例\n&lt;title&gt;天气案例&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h3&gt;  &lt;!-- 绑定事件的时候：@xxx=&quot;yyy&quot; yyy可以写一些简单的语句 --&gt;  &lt;!-- &lt;button @click=&quot;isHot = !isHot&quot;&gt;切换天气&lt;/button&gt; --&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      isHot:true,    &#125;,    computed:&#123;      info()&#123;        return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;      &#125;    &#125;,    methods: &#123;      changeWeather()&#123;        this.isHot = !this.isHot      &#125;    &#125;  &#125;)&lt;/script&gt;\n\nwatch监视属性基本用法\n当被监视的属性变化时，回调函数自动调用，进行相关操作\n监视的属性必须存在，才能进行监视，既可以监视data，也可以监视计算属性\n配置项属性immediate:false，改为 true，则初始化时调用一次 handler(newValue,oldValue)\n监视有两种写法\n创建Vue时传入watch: &#123;&#125;配置\n通过vm.$watch()监视\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      isHot: true,    &#125;,    computed: &#123;      info() &#123;        return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;      &#125;    &#125;,    methods: &#123;      changeWeather() &#123;        this.isHot = !this.isHot      &#125;    &#125;,    // 方式一    /* watch:&#123;\t\t\t\t\tisHot:&#123;\t\t\t\timmediate:true,\t\t\t\thandler(newValue,oldValue)&#123;\t\t\t\t\tconsole.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; */  &#125;)  // 方式二  vm.$watch(&#x27;isHot&#x27;, &#123;\t\t    immediate: true, // 初始化时让handler调用一下    //handler什么时候调用？当isHot发生改变时    handler(newValue, oldValue) &#123;      console.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)    &#125;  &#125;)&lt;/script&gt;\n\n深度监视\nVue中的watch默认不监测对象内部值的改变（一层）\n在watch中配置deep:true可以监测对象内部值的改变（多层）\n注意\nVue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\n使用watch时根据监视数据的具体结构，决定是否采用深度监视\n\n\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;a的值是:&#123;&#123; numbers.a &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;  &lt;h3&gt;b的值是:&#123;&#123; numbers.b &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;  &lt;button @click=&quot;numbers = &#123;a:666,b:888&#125;&quot;&gt;彻底替换掉numbers&lt;/button&gt;  &#123;&#123;numbers.c.d.e&#125;&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      isHot: true,      numbers: &#123;        a: 1,        b: 1,        c: &#123;          d: &#123;            e: 100          &#125;        &#125;      &#125;    &#125;,    watch: &#123;      // 监视多级结构中某个属性的变化      /* &#x27;numbers.a&#x27;:&#123;\t\t\t\thandler()&#123;\t\t\t\t\tconsole.log(&#x27;a被改变了&#x27;)\t\t\t\t&#125;\t\t\t&#125; */      // 监视多级结构中所有属性的变化      numbers: &#123;        deep: true,        handler() &#123;          console.log(&#x27;numbers改变了&#x27;)        &#125;      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n监视属性简写\n如果监视属性除了handler没有其他配置项的话，可以进行简写\n\n&lt;div id=&quot;root&quot;&gt;  &lt;h3&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;isHot: true,&#125;,    computed: &#123;info() &#123;return this.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;&#125;,    methods: &#123;changeWeather() &#123;this.isHot = !this.isHot&#125;&#125;,    watch: &#123;      // 正常写法      // isHot: &#123;      // \t// immediate:true, //初始化时让handler调用一下      // \t// deep:true,\t//深度监视      // \thandler(newValue, oldValue) &#123;      // \t\tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)      // \t&#125;      // &#125;,      //简写      isHot(newValue, oldValue) &#123;        console.log(&#x27;isHot被修改了&#x27;, newValue, oldValue, this)      &#125;    &#125;  &#125;)  //正常写法  // vm.$watch(&#x27;isHot&#x27;, &#123;  // \timmediate: true, //初始化时让handler调用一下  // \tdeep: true,//深度监视  // \thandler(newValue, oldValue) &#123;  // \t\tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)  // \t&#125;  // &#125;)l  //简写  // vm.$watch(&#x27;isHot&#x27;, function(newValue, oldValue)&#123;  // \tconsole.log(&#x27;isHot被修改了&#x27;, newValue, oldValue)  // &#125;)&lt;/script&gt;\n\n计算属性VS监视属性\ncomputed和watch之间的区别\ncomputed能完成的功能，watch都可以完成\nwatch能完成的功能，computed不一定能完成，例如watch可以进行异步操作\n\n\n\n使用计算属性new Vue(&#123;    el:&#x27;#root&#x27;,     data:&#123;         firstName:&#x27;张&#x27;,        lastName:&#x27;三&#x27;    &#125;,    computed:&#123;    \tfullName()&#123;\t\t    return this.firstName + &#x27;-&#x27; + this.lastName    \t&#125;    &#125;&#125;)\n\n使用监听属性new Vue(&#123;  el:&#x27;#root&#x27;,  data:&#123;    firstName:&#x27;张&#x27;,    lastName:&#x27;三&#x27;,    fullName:&#x27;张-三&#x27;  &#125;,  watch:&#123;    firstName(val)&#123;      setTimeout(()=&gt;&#123;        this.fullName = val + &#x27;-&#x27; + this.lastName      &#125;,1000);    &#125;,    lastName(val)&#123;      this.fullName = this.firstName + &#x27;-&#x27; + val    &#125;  &#125;&#125;)\n\n\n两个重要的小原则\n所有被Vue管理的函数，最好写成普通函数，这样 this 的指向才是vm或组件实例对象\n所有不被Vue所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是vm或组件实例对象\n\n\n\n","categories":["Vue"],"tags":["计算属性","监视属性"]},{"title":"Vue（十一）：过滤器（Vue3中已经移除）","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Vue3%E4%B8%AD%E5%B7%B2%E7%BB%8F%E7%A7%BB%E9%99%A4%EF%BC%89/","content":"过滤器（Vue3中已经移除）\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\n注册过滤器：\nVue.filter(name, callback)全局过滤器\nnew Vue &#123;filters: &#123;&#125;&#125; 局部过滤器\n\n\n使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot;\n备注：\n过滤器可以接收额外参数，多个过滤器也可以串联\n并没有改变原本的数据，而是产生新的对应的数据\n\n\n处理时间的库：moment体积较大 、dayjs轻量级\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\t\t&lt;title&gt;过滤器&lt;/title&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t\t&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js&quot;&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;root&quot;&gt;\t\t\t&lt;h2&gt;时间&lt;/h2&gt;            &lt;h3&gt;当前时间戳：&#123;&#123;time&#125;&#125;&lt;/h3&gt;            &lt;h3&gt;转换后时间：&#123;&#123;time | timeFormater()&#125;&#125;&lt;/h3&gt;\t\t\t&lt;h3&gt;转换后时间：&#123;&#123;time | timeFormater(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)&#125;&#125;&lt;/h3&gt;\t\t\t&lt;h3&gt;截取年月日：&#123;&#123;time | timeFormater() | mySlice&#125;&#125;&lt;/h3&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tVue.config.productionTip = false\t\t// 全局过滤器\t\tVue.filter(&#x27;mySlice&#x27;,function(value)&#123;\t\t\treturn value.slice(0,11)\t\t&#125;)\t\tnew Vue(&#123;            el:&#x27;#root&#x27;,            data:&#123;                time:1626750147900,            &#125;,\t\t\t// 局部过滤器            filters:&#123;                timeFormater(value, str=&quot;YYYY年MM月DD日 HH:mm:ss&quot;)&#123;                    return dayjs(value).format(str)                &#125;            &#125;        &#125;)\t&lt;/script&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["过滤器"]},{"title":"Vue（十七）：Vue脚手架之ref、props、mixin、plugin、scoped","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8Bref%E3%80%81props%E3%80%81mixin%E3%80%81plugin%E3%80%81scoped/","content":"ref属性ref被用来给元素或子组件注册引用信息（id的替代者）\n\n应用在html标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象vc\n使用方式\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;&lt;/h1&gt;或&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;    &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;    &lt;School ref=&quot;sch&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import School from &#x27;./components/School&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; School &#125;,    data() &#123;      return &#123;        msg:&#x27;欢迎学习Vue！&#x27;      &#125;    &#125;,    methods: &#123;      showDOM()&#123;        console.log(this.$refs.title)\t// 真实DOM元素        console.log(this.$refs.btn)\t\t// 真实DOM元素        console.log(this.$refs.sch)\t\t// School组件的实例对象（vc）      &#125;    &#125;,  &#125;&lt;/script&gt;\n\n\nprops配置项props：让组件接收外部传过来的数据\n\n传递数据&lt;Demo name=&quot;xxx&quot; :age=&quot;18&quot;/&gt;这里age前加:，表示通过v-bind使得里面的18是数字\n\n接收数据\n\n第一种方式（只接收）props:[&#39;name&#39;, &#39;age&#39;]\n\n第二种方式（限制类型）props:&#123;name:String, age:Number&#125;\n\n第三种方式（限制类型、限制必要性、指定默认值）如下\nprops: &#123;    name: &#123;        type: String,\t // 类型        required: true,// 必要性        default: &#x27;cess&#x27;// 默认值    &#125;&#125;\n\n\n\n\n备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中，然后去修改data中的数据。\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot;/&gt;    &lt;Student name=&quot;王五&quot; sex=&quot;男&quot; :age=&quot;18&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Student from &#x27;./components/Student&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123; Student &#125;  &#125;&lt;/script&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生年龄：&#123;&#123; myAge + 1 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Student&quot;,  data() &#123;    console.log(this);    return &#123;      msg: &quot;我是一个UESTC大学的学生&quot;,      myAge: this.age,    &#125;;  &#125;,  methods: &#123; updateAge() &#123; this.myAge++; &#125;, &#125;,  // 简单声明接收  // props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;]  // 接收的同时对数据进行类型限制  //   props: &#123;  //     name: String,  //     age: Number,  //     sex: String,  //   &#125;  // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制  props: &#123;    name: &#123;      type: String, \t//name的类型是字符串      required: true, //name是必要的    &#125;,    age: &#123;      type: Number,      default: 99, //默认值    &#125;,    sex: &#123;      type: String,      required: true,    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n\nmixin(混入)配置项\n功能：可以把多个组件共用的配置提取成一个混入对象\n\n使用方式\n\n定义混入\nconst mixin = &#123;    data() &#123;....&#125;,    methods: &#123;....&#125;    ....&#125;\n\n使用混入\n\n全局混入Vue.mixin(xxx)\n局部混入mixins:[&#39;xxx&#39;]\n\n\n\n\n备注\n\n组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先\nvar mixin = &#123;\tdata: function () &#123;\t\treturn &#123;    \t\tmessage: &#x27;hello&#x27;,            foo: &#x27;abc&#x27;    \t&#125;  \t&#125;&#125;new Vue(&#123;  \tmixins: [mixin],  \tdata () &#123;    \treturn &#123;      \t\tmessage: &#x27;goodbye&#x27;,            \tbar: &#x27;def&#x27;    \t&#125;    &#125;,  \tcreated () &#123;    \tconsole.log(this.$data)    \t// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;  \t&#125;&#125;)\n\n同名生命周期钩子将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用\nvar mixin = &#123;  \tcreated () &#123;    \tconsole.log(&#x27;混入对象的钩子被调用&#x27;)  \t&#125;&#125;new Vue(&#123;  \tmixins: [mixin],  \tcreated () &#123;    \tconsole.log(&#x27;组件钩子被调用&#x27;)  \t&#125;&#125;)// =&gt; &quot;混入对象的钩子被调用&quot;// =&gt; &quot;组件钩子被调用&quot;\n\n\n代码示例：\nsrc/mixin.js\nexport const hunhe = &#123;\tmethods: &#123;\t\tshowName()&#123;\t\t\talert(this.name)\t\t&#125;\t&#125;,\tmounted() &#123;\t\tconsole.log(&#x27;你好啊！&#x27;)\t&#125;,&#125;export const hunhe2 = &#123;\tdata() &#123;\t\treturn &#123;\t\t\tx:100,\t\t\ty:200\t\t&#125;\t&#125;,&#125;\n\nsrc/components.School.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2 @click=&quot;showName&quot;&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  //引入一个hunhe  import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷&#x27;,        address:&#x27;北京&#x27;,        x:666      &#125;    &#125;,    mixins:[hunhe,hunhe2]\t// 局部混入  &#125;&lt;/script&gt;\n\nsrc/components.Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2 @click=&quot;showName&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,    mixins:[hunhe,hunhe2]\t// 局部混入  &#125;&lt;/script&gt;\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;School/&gt;    &lt;hr&gt;    &lt;Student/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import School from &#x27;./components/School&#x27;  import Student from &#x27;./components/Student&#x27;  export default &#123;    name:&#x27;App&#x27;,    components:&#123;School,Student&#125;  &#125;&lt;/script&gt;\n\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// import &#123;hunhe,hunhe2&#125; from &#x27;./mixin&#x27;Vue.config.productionTip = false// Vue.mixin(hunhe)\t\t// 全局混合引入// Vue.mixin(hunhe2)\t// 全局混合new Vue(&#123;    el:&quot;#app&quot;,    render: h =&gt; h(App)&#125;)\n\n\n\n\nplugin插件\n功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据\n定义插件（见下 src&#x2F;plugin.js）\n使用插件：Vue.use()\n\nsrc/plugin.js\nexport default &#123;  install(Vue,x,y,z)&#123;    console.log(x,y,z)    //全局过滤器    Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;return value.slice(0,4)&#125;)    //定义全局指令    Vue.directive(&#x27;fbind&#x27;,&#123;      //指令与元素成功绑定时（一上来）      bind(element,binding)&#123;element.value = binding.value&#125;,      //指令所在元素被插入页面时      inserted(element,binding)&#123;element.focus()&#125;,      //指令所在的模板被重新解析时      update(element,binding)&#123;element.value = binding.value&#125;    &#125;)    //定义混入    Vue.mixin(&#123;      data() &#123;return &#123;x:100,y:200&#125;&#125;,    &#125;)    //给Vue原型上添加一个方法（vm和vc就都能用了）    Vue.prototype.hello = ()=&gt;&#123;alert(&#x27;你好啊&#x27;)&#125;  &#125;&#125;\n\n\n代码示例：\nsrc/main.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import plugins from &#x27;./plugins&#x27;\t// 引入插件Vue.config.productionTip = falseVue.use(plugins,1,2,3)\t// 应用（使用）插件new Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App)&#125;)\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学校名称：&#123;&#123; name | mySlice &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;test&quot;&gt;点我测试一个hello方法&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷atguigu&#x27;,        address:&#x27;北京&#x27;,      &#125;    &#125;,    methods: &#123;      test()&#123;        this.hello()      &#125;    &#125;,  &#125;&lt;/script&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;    &lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;Student&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        sex:&#x27;男&#x27;      &#125;    &#125;,  &#125;&lt;/script&gt;\n\n\n\n\nscoped样式\n作用：让样式在局部生效，防止冲突\n写法：&lt;style scoped&gt;\n\n\nVue中的webpack并没有安装最新版，导致有些插件也不能默认安装最新版，如 npm i less-loader@7，而不是最新版\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;School&#x27;,    data() &#123;      return &#123;        name:&#x27;尚硅谷atguigu&#x27;,        address:&#x27;北京&#x27;,      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .demo&#123;    background-color: skyblue;  &#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2 class=&quot;atguigu&quot;&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;Student&#x27;,    data() &#123;      return &#123;        name: &#x27;张三&#x27;,        sex: &#x27;男&#x27;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;  .demo &#123;    background-color: pink;    .atguigu &#123;      font-size: 40px;    &#125;  &#125;&lt;/style&gt;\n\nsrc/App.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1 class=&quot;title&quot;&gt;你好啊&lt;/h1&gt;    &lt;School/&gt;    &lt;Student/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Student from &#x27;./components/Student&#x27;  import School from &#x27;./components/School&#x27;  export default &#123;    name: &#x27;App&#x27;,    components: &#123; School, Student &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .title &#123;    color: red;  &#125;&lt;/style&gt;\n\n\n","categories":["Vue"],"tags":["Vue CLI","ref","props","mixin","plugin","scoped"]},{"title":"Vue（十三）：自定义指令","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","content":"自定义指令\n回顾一个DOM操作\n&lt;style&gt;.demo&#123;background-color: orange;&#125;&lt;/style&gt;&lt;body&gt;  &lt;button id=&quot;btn&quot;&gt;点我创建一个输入框&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; &gt;  const btn = document.getElementById(&#x27;btn&#x27;)  btn.onclick = ()=&gt;&#123;    const input = document.createElement(&#x27;input&#x27;)    input.className = &#x27;demo&#x27;    input.value = 99    input.onclick = ()=&gt;&#123;alert(1)&#125;    document.body.appendChild(input)    input.focus()    input.parentElement.style.backgroundColor = &#x27;skyblue&#x27;  &#125;&lt;/script&gt;\n\n&lt;title&gt;自定义指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;  &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;  &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;  &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;  &lt;hr /&gt;  &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 定义全局指令  /* Vue.directive(&#x27;fbind&#x27;,&#123;\t\t// 指令与元素成功绑定时（一上来）\t\tbind(element,binding)&#123;\t\t\telement.value = binding.value\t\t&#125;,\t\t// 指令所在元素被插入页面时\t\tinserted(element,binding)&#123;\t\t\telement.focus()\t\t&#125;,\t\t// 指令所在的模板被重新解析时\t\tupdate(element,binding)&#123;\t\t\telement.value = binding.value\t\t&#125;\t&#125;) */  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      name: &#x27;尚硅谷&#x27;,      n: 1    &#125;,    directives: &#123;      // big函数何时会被调用？      // 1.指令与元素成功绑定时（一上来） 2.指令所在的模板被重新解析时      /* &#x27;big-number&#x27;(element,binding)&#123;\t\t\t\t// console.log(&#x27;big&#x27;)\t\t\t\telement.innerText = binding.value * 10\t\t\t&#125;, */      big(element, binding) &#123;        console.log(&#x27;big&#x27;, this) // 🔴注意此处的 this 是 window        // console.log(&#x27;big&#x27;)        element.innerText = binding.value * 10      &#125;,      fbind: &#123;        // 指令与元素成功绑定时（一上来）        bind(element, binding) &#123;          element.value = binding.value        &#125;,        // 指令所在元素被插入页面时        inserted(element, binding) &#123;          element.focus()        &#125;,        // 指令所在的模板被重新解析时        update(element, binding) &#123;          element.value = binding.value        &#125;      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n\ndirectives\n\n定义语法\n\n局部指令\nnew Vue(&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  directives:&#123;     指令名:配置对象   &#125;   &#125;)new Vue(&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  directives:&#123;     指令名:回调函数   &#125;   &#125;)\n\n全局指令\nVue.directive(指令名, 配置对象)或Vue.directive(指令名, 回调函数)\nVue.directive(&#x27;fbind&#x27;, &#123;    // 指令与元素成功绑定时（一上来）    bind(element, binding) &#123;\t// element就是DOM元素，binding就是要绑定的      element.value = binding.value    &#125;,    // 指令所在元素被插入页面时    inserted(element, binding) &#123;      element.focus()    &#125;,    // 指令所在的模板被重新解析时    update(element, binding) &#123;      element.value = binding.value    &#125;&#125;)\n\n\nbind、inserted、update称为钩子，在vue3已被修复\n\n配置对象中常用的3个回调函数\n\nbind(element, binding) 指令与元素成功绑定时调用\n\ninserted(element, binding)指令所在元素被插入页面时调用\n\nupdate(element, binding) 指令所在模板结构被重新解析时调用\n\n\nelement就是DOM元素，binding就是要绑定的对象，它包含以下属性：name value old Value expression arg modifiers\n备注\n\n指令定义时不加v-，但使用时要加v-\n\n指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名\nnew Vue(&#123;\tel: &#x27;#root&#x27;,\tdata: &#123;\t\tn:1\t&#125;,\tdirectives: &#123;\t\t&#x27;big-number&#x27;(element,binding) &#123;\t\t\telement.innerText = binding.value * 10\t\t&#125;\t&#125;&#125;)\n\n\n\n\n\n","categories":["Vue"],"tags":["自定义指令"]},{"title":"Vue（十九）：Vue脚手架之组件的自定义事件","url":"/2022/04/08/Vue%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/","content":"组件的自定义事件\n一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件\n\n使用场景\nA是父组件，B是子组件，子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件（事件的回调在A中)\n\n绑定自定义事件\n\n第一种方式，在父组件中&lt;Demo @事件名=&quot;回调函数&quot;/&gt;或&lt;Demo v-on:事件名=&quot;回调函数&quot;/&gt;\n\n第二种方式，在父组件中,示例如下：\n&lt;Demo @atguigu=&quot;test&quot; ref=&quot;demo&quot;/&gt;......mounted()&#123;   this.$refs.demo.$on(&#x27;atguigu&#x27;,this.test)&#125;\n\n若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法\n\n\n\n触发自定义事件\n在子组件中this.$emit(&#39;事件名&#39;,数据)\n\n解绑自定义事件\n在子组件中this.$off(&#39;事件名&#39;)\n\n组件上也可以绑定原生 DOM事件，需要使用native修饰符，例如@click.native=&quot;show&quot;\n上面绑定自定义事件，即使绑定的是原生事件也会被认为是自定义的，需要加native，加了后就将此事件给组件的根元素\n\n注意:\n通过this.$refs.demo.$on(&#39;事件名&#39;,回调函数)绑定自定义事件时，回调函数要么配置在methods中，要么用箭头函数，否则this指向会出问题\n\n\n使用自定义事件优化Todo-Listsrc/App.vue\n&lt;template&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot;                   @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyList from &#x27;./components/MyList&#x27;\timport MyFooter from &#x27;./components/MyFooter.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;MyHeader,MyList,MyFooter&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\t//由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）\t\t\t\ttodos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter( todo =&gt; todo.id !== id )\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,\t\twatch: &#123;\t\t\ttodos:&#123;\t\t\t\tdeep:true,\t\t\t\thandler(value)&#123;\t\t\t\t\tlocalStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/MyHeader.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-header&quot;&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot;            v-model=&quot;title&quot; @keyup.enter=&quot;add&quot;/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname:&#x27;MyHeader&#x27;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttitle:&#x27;&#x27;\t// 收集用户输入的title\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\t//校验数据\t\t\t\tif(!this.title.trim()) return alert(&#x27;输入不能为空&#x27;)\t\t\t\t//将用户的输入包装成一个todo对象\t\t\t\tconst todoObj = &#123;id:nanoid(),title:this.title,done:false&#125;\t\t\t\t//通知App组件去添加一个todo对象\t\t\t\tthis.$emit(&#x27;addTodo&#x27;,todoObj)\t\t\t\t//清空输入\t\t\t\tthis.title = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\nsrc/components/MyFooter.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt;\t\t&lt;label&gt;\t\t\t&lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;\t\t\t&lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;\t\t&lt;/label&gt;\t\t&lt;span&gt;\t\t\t&lt;span&gt;已完成&#123;&#123; doneTotal &#125;&#125;&lt;/span&gt; / 全部&#123;&#123; total &#125;&#125;\t\t&lt;/span&gt;\t\t&lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearAll&quot;&gt;清除已完成任务&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tname:&#x27;MyFooter&#x27;,\t\tprops:[&#x27;todos&#x27;],\t\tcomputed: &#123;\t\t\t//总数\t\t\ttotal()&#123;\t\t\t\treturn this.todos.length\t\t\t&#125;,\t\t\t//已完成数\t\t\tdoneTotal()&#123;\t\t\t\treturn this.todos.reduce((pre,todo)=&gt; pre + (todo.done ? 1 : 0) ,0)\t\t\t&#125;,\t\t\t//控制全选框\t\t\tisAll:&#123;\t\t\t\t//全选框是否勾选\t\t\t\tget()&#123;\t\t\t\t\treturn this.doneTotal === this.total &amp;&amp; this.total &gt; 0\t\t\t\t&#125;,\t\t\t\t//isAll被修改时set被调用\t\t\t\tset(value)&#123;\t\t\t\t\t// this.checkAllTodo(value)\t\t\t\t\tthis.$emit(&#x27;checkAllTodo&#x27;,value)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//清空所有已完成\t\t\tclearAll()&#123;\t\t\t\t// this.clearAllTodo()\t\t\t\tthis.$emit(&#x27;clearAllTodo&#x27;)\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","自定义事件"]},{"title":"Vue（十二）：常用内置指令","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","content":"之前学过的指令\nv-bind 单向绑定解析表达式，可简写为:\nv-model 双向数据绑定\nv-for 遍历数组 &#x2F; 对象 &#x2F; 字符串\nv-on 绑定事件监听，可简写为@\nv-show 条件渲染 (动态控制节点是否展示)\nv-if 条件渲染（动态控制节点是否存存在）\nv-else-if 条件渲染（动态控制节点是否存存在）\nv-else 条件渲染（动态控制节点是否存存在）\n\nv-text\n作用：向其所在的节点中渲染文本内容\n\n与插值语法的区别：v-text会替换掉节点中的所有内容，&#123;&#123;xxx&#125;&#125;则不会，更灵活，更多情况下用插值语法\n&lt;title&gt;v-text指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt;  &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;  &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      name:&#x27;cess&#x27;,      str:&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;    &#125;  &#125;)&lt;/script&gt;\n\n\n\n\nv-html\n作用：向指定节点中渲染包含html结构的内容\n与插值语法的区别：\nv-html会替换掉节点中所有的内容，&#123;&#123;xxx&#125;&#125;则不会\nv-html可以识别html结构\n\n\n严重注意v-html有安全性问题！！！\n在网站上动态渲染任意html是非常危险的，容易导致 XSS 攻击\n一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上！！！\n\n\n\n&lt;title&gt;v-html指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div&gt;你好，&#123;&#123; name &#125;&#125;&lt;/div&gt;  &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;  &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = FontFaceSetLoadEvent  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;      name:&#x27;cess&#x27;,      str:&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;,      str2:&#x27;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;&#x27;,    &#125;  &#125;)&lt;/script&gt;\n\n\nv-cloak\nv-cloak指令（没有值）\n本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性\n使用css配合v-cloak可以解决网速慢时页面展示出的问题\n\n\n\n&lt;title&gt;v-cloak指令&lt;/title&gt;&lt;style&gt;  [v-cloak] &#123;    display:none;  &#125;&lt;/style&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-cloak&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;&lt;/div&gt;// 够延迟5秒收到vue.js&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/resource/5s/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  console.log(1)  Vue.config.productionTip = false  new Vue(&#123;    el:&#x27;#root&#x27;,    data:&#123;name:&#x27;cess&#x27;&#125;  &#125;)&lt;/script&gt;\n\nv-once\nv-once指令（没有值）\nv-once所在节点在初次动态渲染后，就视为静态内容了\n以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n\n&lt;title&gt;v-once指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-once&gt;初始化的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;h2&gt;当前的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123; el: &#x27;#root&#x27;, data: &#123;n:1&#125; &#125;)&lt;/script&gt;\n\n\nv-pre\n跳过v-pre所在节点的编译过程\n可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n&lt;title&gt;v-pre指令&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt;  &lt;h2 &gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123; el:&#x27;#root&#x27;, data:&#123;n:1&#125; &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["内置指令"]},{"title":"Vue（十五）：组件化编程","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/","content":"模块与组件、模块化与组件化\n\n\n模块\n理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\n为什么：js 文件很多很复杂\n作用：复用、简化 js 的编写，提高 js 运行效率\n\n\n组件\n定义：用来实现局部（特定）功能的代码和资源的集合（html&#x2F;css&#x2F;js&#x2F;image…）\n为什么：一个界面的功能很复杂\n作用：复用编码，简化项目编码，提高运行效率\n\n\n模块化\n当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\n\n\n组件化\n当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\n\n\n\n非单文件组件\n非单文件组件：一个文件(a.html)中包含有 n 个组件\n单文件组件：一个文件(a.vue)中只包含有 1 个组件\n\n基本使用Vue中使用组件的三大步骤\n定义组件\n使用Vue.extend(options)创建，其中options（配置项）和new Vue(options)时传入的options几乎一样，但也有点区别\n\nel不要写，因为最终所有的组件都要经过一个vm的管理，由vm中的el才决定服务哪个容器\n\ndata必须写成函数，避免组件被复用时，数据存在引用关系\n\n\n备注：使用template可以配置组件结构\n\n\n注册组件\n局部注册：new Vue()的时候options传入components选项\n\n全局注册：Vue.component(&#39;组件名&#39;,组件)\n\n\n使用组件\n编写组件标签，如 \n\n&lt;title&gt;基本使用&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;hr&gt;  &lt;!-- 第三步：编写组件标签 --&gt;  &lt;school&gt;&lt;/school&gt;&lt;hr&gt;  &lt;student&gt;&lt;/student&gt;&lt;hr&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;hr&gt;&lt;/div&gt;&lt;div id=&quot;root2&quot;&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  //第一步：创建school组件  const school = Vue.extend(&#123;    // el:&#x27;#root&#x27;, //组件定义时，一定不要写el配置项，    // 因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器    template: `\t\t\t\t&lt;div class=&quot;demo&quot;&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        schoolName: &#x27;尚硅谷&#x27;,        address: &#x27;北京昌平&#x27;      &#125;    &#125;,    methods: &#123;      showName() &#123;        alert(this.schoolName)      &#125;    &#125;,  &#125;)  //第一步：创建student组件  const student = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;h3&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h3&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        studentName: &#x27;张三&#x27;,        age: 18      &#125;    &#125;  &#125;)  //第一步：创建hello组件  const hello = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t\t&lt;h3&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h3&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;      return &#123;        name: &#x27;cess&#x27;      &#125;    &#125;  &#125;)  //第二步：全局注册组件  Vue.component(&#x27;hello&#x27;, hello)  //创建vm  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      msg: &#x27;你好啊！&#x27;    &#125;,    //第二步：注册组件（局部注册）    components: &#123;      school,      student    &#125;  &#125;)  new Vue(&#123;    el: &#x27;#root2&#x27;,  &#125;)&lt;/script&gt;\n\n\n组件注意事项关于组件名\n一个单词组成\n\n第一种写法（首字母小写）：school\n\n第二种写法（首字母大写）：School\n\n\n\n多个单词组成\n\n第一种写法（kebab-case 命名）：my-school\n\n第二种写法（CamelCase 命名）：MySchool（需要Vue脚手架支持）\n\n\n\n备注\n\n组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行\n可以使用name配置项指定组件在开发者工具中呈现的名字（可用于使用第三方组件库时起一个别名）\n\n\n\n关于组件标签\n第一种写法：&lt;school&gt;&lt;/school&gt;\n第二种写法：&lt;school/&gt;（需要Vue脚手架支持）\n备注：不使用脚手架时，会导致后续组件不能渲染\n\n一个简写方式：const school = Vue.extend(options)可简写为const school = options，因为父组件components引入的时候会自动创建\n&lt;title&gt;几个注意点&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;\t\t&lt;school&gt;&lt;/school&gt;\t&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\tVue.config.productionTip = false\t//定义组件\tconst school = Vue.extend(&#123;\t\tname: &#x27;atguigu&#x27;, // 组件给自己起个名字，用于在浏览器开发工具上显示\t\ttemplate: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t`,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tname: &#x27;电子科技大学&#x27;,\t\t\t\taddress: &#x27;成都&#x27;\t\t\t&#125;\t\t&#125;\t&#125;)\tnew Vue(&#123;\t\tel: &#x27;#root&#x27;,\t\tdata: &#123;\t\t\tmsg: &#x27;欢迎学习Vue!&#x27;\t\t&#125;,\t\tcomponents: &#123;\t\t\tschool\t\t&#125;\t&#125;)&lt;/script&gt;\n\n\n组件的嵌套\n&lt;title&gt;组件的嵌套&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  //定义student组件  const student = Vue.extend(&#123;    name: &#x27;student&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h4&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h4&gt;\t\t\t\t\t\t&lt;h4&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h4&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,age: 18&#125;&#125;  &#125;)  //定义school组件  const school = Vue.extend(&#123;    name: &#x27;school&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h3&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;h3&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h3&gt;\t\t\t\t\t\t&lt;student&gt;&lt;/student&gt; \t\t\t  &lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,address: &#x27;北京&#x27;&#125;&#125;,    //注册组件（局部）    components: &#123; student &#125;  &#125;)  //定义hello组件  const hello = Vue.extend(&#123;    template: `&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;`,    data() &#123;return &#123;msg: &#x27;欢迎来到尚硅谷学习！&#x27;&#125;&#125;  &#125;)  //定义app组件  const app = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t\t&lt;hello&gt;&lt;/hello&gt;\t\t\t\t\t&lt;school&gt;&lt;/school&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    components: &#123; school, hello &#125;  &#125;)  //创建vm  new Vue(&#123;    el: &#x27;#root&#x27;,    template: &#x27;&lt;app&gt;&lt;/app&gt;&#x27;,    //注册组件（局部）    components: &#123; app &#125;  &#125;)&lt;/script&gt;\n\n\nVueComponent关于 VueComponent\n\nschool 组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，而是 Vue.extend() 生成的\n\n我们只需要写 &lt;school/&gt; 或 &lt;school&gt;&lt;/school&gt;，Vue 解析时会帮我们创建 school 组件的实例对象，即Vue帮我们执行的new VueComponent(options)\n\n特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent，即不同组件是不同的对象\n\n关于 this 指向\n\n组件配置中data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 VueComponent实例对象（vc）\nnew Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 Vue实例对象（vm）\n\n\nVueComponent的实例对象，以后简称vc（组件实例对象）\nVue的实例对象，以后简称vm\n\n\n&lt;title&gt;VueComponent&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;school&gt;&lt;/school&gt;  &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  // 定义school组件  const school = Vue.extend(&#123;    name: &#x27;school&#x27;,    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;\t\t\t\t\t\t&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;\t\t\t\t\t\t&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;name: &#x27;尚硅谷&#x27;,address: &#x27;北京&#x27;&#125;&#125;,    methods: &#123;showName() &#123;console.log(&#x27;showName&#x27;, this)&#125;&#125;,  &#125;)  const test = Vue.extend(&#123;    template: `&lt;span&gt;atguigu&lt;/span&gt;`  &#125;)  // 定义hello组件  const hello = Vue.extend(&#123;    template: `\t\t\t\t&lt;div&gt;\t\t\t\t\t&lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;\t\t\t\t\t&lt;test&gt;&lt;/test&gt;\t  \t\t\t&lt;/div&gt;\t\t\t`,    data() &#123;return &#123;msg: &#x27;你好啊！&#x27;&#125;&#125;,    components: &#123; test &#125;  &#125;)  // console.log(&#x27;@&#x27;,school)  // console.log(&#x27;#&#x27;,hello)  // 创建vm  const vm = new Vue(&#123;    el: &#x27;#root&#x27;,    components: &#123; school, hello &#125;  &#125;)&lt;/script&gt;\n\n一个重要的内置关系\n\n一个重要的内置关系：VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype\n\n为什么要有这个关系：让组件实例对象vc可以访问到 Vue原型上的属性、方法\n\n\n单文件组件\nSchool.vue\n&lt;template&gt;    &lt;div id=&#x27;Demo&#x27;&gt;        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;School&#x27;,        data() &#123;            return &#123;                name:&#x27;UESTC&#x27;,                address:&#x27;成都&#x27;            &#125;        &#125;,        methods: &#123;            showName()&#123;                alert(this.name)            &#125;        &#125;,    &#125;&lt;/script&gt;&lt;style&gt;    #Demo&#123;        background: orange;    &#125;&lt;/style&gt;\n\nStudent.vue\n&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;Student&#x27;,        data() &#123;            return &#123;                name:&#x27;cess&#x27;,                age:20            &#125;        &#125;,    &#125;&lt;/script&gt;\n\nApp.vue\n&lt;template&gt;    &lt;div&gt;        &lt;School&gt;&lt;/School&gt;        &lt;Student&gt;&lt;/Student&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import School from &#x27;./School.vue&#x27;    import Student from &#x27;./Student.vue&#x27;    export default &#123;        name:&#x27;App&#x27;,        components:&#123;            School,            Student        &#125;    &#125;&lt;/script&gt;\n\nmain.js\nimport App from &#x27;./App.vue&#x27;new Vue(&#123;    template:`&lt;App&gt;&lt;/App&gt;`,    el:&#x27;#root&#x27;,    components:&#123;App&#125;&#125;)\n\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;单文件组件练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Vue"],"tags":["组件"]},{"title":"Vue（十八）：Vue脚手架之Todo-List案例","url":"/2022/04/08/Vue%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8BTodo-List%E6%A1%88%E4%BE%8B/","content":"组件化编码流程\n拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突\n实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件再用\n一个组件在用：放在组件自身即可\n一些组件在用：放在他们共同的父组件上**(状态提升)**\n\n\n实现交互：从绑定事件开始\n\nprops适用于\n\n父组件 &#x3D;&#x3D;&gt; 子组件通信\n\n子组件 &#x3D;&#x3D;&gt; 父组件通信（要求父组件先给子组件一个函数)\n\n注意：\n\n使用v-model时要切记：v-model 绑定的值不能是props传过来的值，因为props是不可以修改的\n\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做\n\n\n\n代码：\nsrc/App.vue\n&lt;template&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;div class=&quot;todo-container&quot;&gt;      &lt;div class=&quot;todo-wrap&quot;&gt;        &lt;MyHeader :addTodo=&quot;addTodo&quot;/&gt;        &lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;        &lt;MyFooter :todos=&quot;todos&quot;                   :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot;/&gt;    \t&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import MyHeader from &#x27;./components/MyHeader&#x27;  import MyList from &#x27;./components/MyList&#x27;  import MyFooter from &#x27;./components/MyFooter.vue&#x27;  export default &#123;    name: &#x27;App&#x27;,    components: &#123; MyHeader, MyList, MyFooter &#125;,    data() &#123;      return &#123;        // 由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）        todos:[          &#123;id:&#x27;001&#x27;,title:&#x27;抽烟&#x27;,done:true&#125;,          &#123;id:&#x27;002&#x27;,title:&#x27;喝酒&#x27;,done:false&#125;,          &#123;id:&#x27;003&#x27;,title:&#x27;开车&#x27;,done:true&#125;        ]      &#125;    &#125;,    methods: &#123;      //添加一个todo      addTodo(todoObj)&#123;        this.todos.unshift(todoObj)      &#125;,      //勾选or取消勾选一个todo      checkTodo(id)&#123;        this.todos.forEach((todo)=&gt;&#123;          if(todo.id === id) todo.done = !todo.done        &#125;)      &#125;,      //删除一个todo      deleteTodo(id)&#123;        this.todos = this.todos.filter( todo =&gt; todo.id !== id )      &#125;,      //全选or取消全选      checkAllTodo(done)&#123;        this.todos.forEach((todo)=&gt;&#123;          todo.done = done        &#125;)      &#125;,      //清除所有已经完成的todo      clearAllTodo()&#123;        this.todos = this.todos.filter((todo)=&gt;&#123;          return !todo.done        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  /*base*/  body &#123;background: #fff;&#125;  .btn &#123;display: inline-block;padding: 4px 12px;margin-bottom: 0;font-size: 14px;    line-height: 20px;text-align: center;vertical-align: middle;cursor: pointer;    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);    border-radius: 4px;&#125;  .btn-danger &#123;color: #fff;background-color: #da4f49;border: 1px solid #bd362f;&#125;  .btn-danger:hover &#123;color: #fff;background-color: #bd362f;&#125;  .btn:focus &#123;outline: none;&#125;  .todo-container &#123;width: 600px;margin: 0 auto;&#125;  .todo-container .todo-wrap &#123;padding: 10px;border: 1px solid #ddd;border-radius: 5px;&#125;&lt;/style&gt;\n\nsrc/components/MyHeader.vue\n&lt;template&gt;\t&lt;div class=&quot;todo-header&quot;&gt;\t\t&lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot;            v-model=&quot;title&quot; @keyup.enter=&quot;add&quot;/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;nanoid&#125; from &#x27;nanoid&#x27;\texport default &#123;\t\tname:&#x27;MyHeader&#x27;,\t\tprops:[&#x27;addTodo&#x27;],\t// 接收从App传递过来的addTodo\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttitle:&#x27;&#x27;\t\t\t\t// 收集用户输入的title\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tadd()&#123;\t\t\t\t// 校验数据\t\t\t\tif(!this.title.trim()) return alert(&#x27;输入不能为空&#x27;)\t\t\t\t// 将用户的输入包装成一个todo对象\t\t\t\tconst todoObj = &#123; id:nanoid(), title:this.title, done:false &#125;\t\t\t\t// 通知App组件去添加一个todo对象\t\t\t\tthis.addTodo(todoObj)\t\t\t\t// 清空输入\t\t\t\tthis.title = &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style scoped&gt;\t/*header*/\t.todo-header input &#123;width: 560px;height: 28px;font-size: 14px;    border: 1px solid #ccc;border-radius: 4px;padding: 4px 7px;&#125;\t.todo-header input:focus &#123;outline: none;border-color: rgba(82, 168, 236, 0.8);\t\tbox-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);&#125;&lt;/style&gt;\n\nsrc/components/MyList.vue\n&lt;template&gt;  &lt;ul class=&quot;todo-main&quot;&gt;    &lt;MyItem v-for=&quot;todoObj in todos&quot;:key=&quot;todoObj.id&quot;             :todo=&quot;todoObj&quot; :checkTodo=&quot;checkTodo&quot;:deleteTodo=&quot;deleteTodo&quot;/&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MyItem from &#x27;./MyItem&#x27;  export default &#123;    name:&#x27;MyList&#x27;,    components:&#123;MyItem&#125;,    // 声明接收App传递的数据，其中todos是自己用的，checkTodo和deleteTodo是给子组件MyItem用的    props:[&#x27;todos&#x27;,&#x27;checkTodo&#x27;,&#x27;deleteTodo&#x27;]  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*main*/  .todo-main &#123;margin-left: 0px;border: 1px solid #ddd;border-radius: 2px;padding: 0px;&#125;  .todo-empty &#123;height: 40px;line-height: 40px;border: 1px solid #ddd;    border-radius: 2px;padding-left: 5px;margin-top: 10px;&#125;&lt;/style&gt;\n\nsrc/components/MyItem.vue\n&lt;template&gt;  &lt;li&gt;    &lt;label&gt;      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;      &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot;/&gt;        &lt;span&gt;&#123;&#123; todo.title &#125;&#125;&lt;/span&gt;    &lt;/label&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;  &lt;/li&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;MyItem&#x27;,    //声明接收todo、checkTodo、deleteTodo    props:[&#x27;todo&#x27;,&#x27;checkTodo&#x27;,&#x27;deleteTodo&#x27;],    methods: &#123;      // 勾选or取消勾选      handleCheck(id)&#123;        this.checkTodo(id)\t// 通知App组件将对应的todo对象的done值取反      &#125;,      // 删除      handleDelete(id)&#123;        if(confirm(&#x27;确定删除吗？&#x27;))&#123;          this.deleteTodo(id)\t// 通知App组件将对应的todo对象删除        &#125;      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*item*/  li &#123;list-style: none;height: 36px;line-height: 36px;padding: 0 5px;    border-bottom: 1px solid #ddd;&#125;  li label &#123;float: left;cursor: pointer;&#125;  li label li input &#123;vertical-align:middle; margin-right:6px; position:relative;top: -1px;&#125;  li button &#123;float: right;display: none;margin-top: 3px;&#125;  li:before &#123;content: initial;&#125;  li:last-child &#123;border-bottom: none;&#125;  li:hover&#123;background-color: #ddd;&#125;  li:hover button&#123;display: block;&#125;&lt;/style&gt;\n\nsrc/components/MyFooter.vue\n&lt;template&gt;  &lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt;    &lt;label&gt;      &lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;      &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;    &lt;/label&gt;    &lt;span&gt;      &lt;span&gt;已完成&#123;&#123; doneTotal &#125;&#125;&lt;/span&gt; / 全部&#123;&#123; total &#125;&#125;    &lt;/span&gt;    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearAll&quot;&gt;清除已完成任务&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;MyFooter&#x27;,    props:[&#x27;todos&#x27;,&#x27;checkAllTodo&#x27;,&#x27;clearAllTodo&#x27;],    computed: &#123;      // 总数      total()&#123;        return this.todos.length      &#125;,      // 已完成数      doneTotal()&#123;        //此处使用reduce方法做条件统计        return this.todos.reduce((pre,todo)=&gt; pre + (todo.done ? 1 : 0) ,0)      &#125;,      // 控制全选框      isAll:&#123;        //全选框是否勾选        get()&#123;          return this.doneTotal === this.total &amp;&amp; this.total &gt; 0        &#125;,        //isAll被修改时set被调用        set(value)&#123;          this.checkAllTodo(value)        &#125;      &#125;    &#125;,    methods: &#123;      /* checkAll(e)&#123;\t\t\t\tthis.checkAllTodo(e.target.checked)\t\t\t&#125; */      //清空所有已完成      clearAll()&#123;        this.clearAllTodo()      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;  /*footer*/  .todo-footer &#123;height: 40px;line-height: 40px;padding-left: 6px;margin-top: 5px;&#125;  .todo-footer label &#123;display: inline-block;margin-right: 20px;cursor: pointer;&#125;  .todo-footer label input &#123;position: relative;top: -1px;vertical-align: middle;    margin-right: 5px;&#125;  .todo-footer button &#123;float: right;margin-top: 5px;&#125;&lt;/style&gt;\n\n\n\n\n使用本地存储优化Todo-List本地存储：《JS提升（一）：浏览器本地存储（WebStorage）》\nscr/App.vue\n&lt;template&gt;\t&lt;div id=&quot;root&quot;&gt;\t\t&lt;div class=&quot;todo-container&quot;&gt;\t\t\t&lt;div class=&quot;todo-wrap&quot;&gt;\t\t\t\t&lt;MyHeader :addTodo=&quot;addTodo&quot;/&gt;\t\t\t\t&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot;/&gt;\t\t\t\t&lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot;/&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\timport MyHeader from &#x27;./components/MyHeader&#x27;\timport MyList from &#x27;./components/MyList&#x27;\timport MyFooter from &#x27;./components/MyFooter.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123;MyHeader,MyList,MyFooter&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\t// 🔴从本地存储中获得数据，null就创建空数组[]\t\t\t\ttodos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t//添加一个todo\t\t\taddTodo(todoObj)&#123;\t\t\t\tthis.todos.unshift(todoObj)\t\t\t&#125;,\t\t\t//勾选or取消勾选一个todo\t\t\tcheckTodo(id)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\tif(todo.id === id) todo.done = !todo.done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//删除一个todo\t\t\tdeleteTodo(id)&#123;\t\t\t\tthis.todos = this.todos.filter( todo =&gt; todo.id !== id )\t\t\t&#125;,\t\t\t//全选or取消全选\t\t\tcheckAllTodo(done)&#123;\t\t\t\tthis.todos.forEach((todo)=&gt;&#123;\t\t\t\t\ttodo.done = done\t\t\t\t&#125;)\t\t\t&#125;,\t\t\t//清除所有已经完成的todo\t\t\tclearAllTodo()&#123;\t\t\t\tthis.todos = this.todos.filter((todo)=&gt;&#123;\t\t\t\t\treturn !todo.done\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;,    // 🔴数据发生改变就放到本地存储中，注意深度侦听，以及JSON转化为字符串\t\twatch: &#123;\t\t\ttodos:&#123;\t\t\t\tdeep:true, //开启深度监视，可以监视对象中的属性，done改变了它也可以检测出来\t\t\t\thandler(value)&#123;\t\t\t\t\tlocalStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;\n\n","categories":["Vue"],"tags":["Vue CLI","组件通信","案例"]},{"title":"Vue（十六）：Vue脚手架之初始化","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9AVue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"说明\nVue CLI (Command Line Interface)\n\n\nVue脚手架是Vue官方提供的标准化开发工具（开发平台）\n最新的版本是 4.x\n文档 Vue CLI\n\n具体步骤\n如果下载缓慢请配置npm淘宝镜像：npm config set registry http://registry.npm.taobao.org\n全局安装 @vue&#x2F;cli：npm install -g @vue/cli\n切换到创建项目的目录，使用命令创建项目vue create xxx\n选择使用vue的版本\n启动项目npm run serve\n打包项目npm run build\n暂停项目 Ctrl+C\n\n\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行vue inspect &gt; output.js\n\n脚手架文件结构.文件目录├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   └── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件└── package-lock.json: 包版本控制文件\n\nsrc/components/School.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;School&quot;,    data() &#123;      return &#123;        name: &quot;UESTC&quot;,        address: &quot;成都&quot;,      &#125;;    &#125;,    methods: &#123;showName() &#123;alert(this.name);&#125;,&#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  .demo &#123;background-color: orange;&#125;&lt;/style&gt;\n\nsrc/components/Student.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生年龄：&#123;&#123; age &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;Student&quot;,    data() &#123;      return &#123;        name: &quot;cess&quot;,        age: 18,      &#125;;    &#125;,  &#125;;&lt;/script&gt;\n\nsrc/App.vue\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;img src=&quot;./assets/logo.png&quot; alt=&quot;&quot;&gt;\t\t&lt;School&gt;&lt;/School&gt;\t\t&lt;Student&gt;&lt;/Student&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;\t// 引入组件\timport School from &#x27;./components/School.vue&#x27;\timport Student from &#x27;./components/Student.vue&#x27;\texport default &#123;\t\tname:&#x27;App&#x27;,\t\tcomponents:&#123; School, Student &#125;\t&#125;&lt;/script&gt;\n\nsrc/main.js\n// 该文件是整个项目的入口文件import Vue from &#x27;vue&#x27;\t\t\t\t// 引入Vueimport App from &#x27;./App.vue&#x27;\t// 引入App组件，它是所有组件的父组件Vue.config.productionTip = falsenew Vue(&#123;\tel:&#x27;#app&#x27;,  render: h =&gt; h(App),\t\t\t// render函数完成了这个功能：将App组件放入容器中&#125;)// .$mount(&#x27;#app&#x27;)\n\npublic/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;              &lt;!-- 针对IE浏览器的特殊配置，含义是让IE浏览器以最高渲染级别渲染页面 --&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;              &lt;!-- 开启移动端的理想端口 --&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;              &lt;!-- 配置页签图标 &lt;%= BASE_URL %&gt;是public所在路径，使用绝对路径 --&gt;        &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;              &lt;!-- 配置网页标题 --&gt;        &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            \t&lt;!-- 当浏览器不支持js时，noscript中的元素就会被渲染 --&gt;      \t&lt;noscript&gt;      \t\t&lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    \t\t&lt;/noscript&gt;                  &lt;!-- 容器 --&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\nrender函数import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123;  el:&#x27;#app&#x27;,  // render函数功能：将App组件放入容器中  // 简写形式  render: h =&gt; h(App),  // 完整形式  // render(createElement)&#123;  //   return createElement(App)  // &#125;&#125;)\n\n关于不同版本的Vue\nvue.js与vue.runtime.xxx.js的区别\nvue.js 是完整版的Vue，包含：核心功能+模板解析器\nvue.runtime.xxx.js 是运行版的Vue，只包含核心功能，没有模板解析器esm 就是 ES6 module\n\n\n因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容\n\nvue.config.js 配置文件\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行vue inspect &gt; output.js\n\n使用vue.config.js可以对脚手架进行个性化定制，和package.json同级目录，详见 配置参考 | Vue CLI\nmodule.exports = &#123;  pages: &#123;    index: &#123;      entry: &#x27;src/index/main.js&#x27; // 入口    &#125;  &#125;,  lineOnSave: false\t// 关闭语法检查&#125;\n\n","categories":["Vue"],"tags":["Vue CLI","脚手架"]},{"title":"Vue（十四）：生命周期","url":"/2022/04/07/Vue%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"引出生命周期\n生命周期\n\n又名生命周期回调函数、生命周期函数、生命周期钩子\n\n是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数\n\n生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n\n生命周期函数中的 this 指向是vm或组件实例对象\n\n\n\n\n&lt;title&gt;引出生命周期&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 v-if=&quot;a&quot;&gt;你好啊&lt;/h2&gt;  &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;看笔记学Vue&lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      a: false,      opacity: 1    &#125;,    methods: &#123;    &#125;,    // 🔴Vue 完成模板的解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted    mounted() &#123;      console.log(&#x27;mounted&#x27;, this)      setInterval(() =&gt; &#123;        this.opacity -= 0.01        if(this.opacity &lt;= 0) this.opacity = 1      &#125;, 16)    &#125;,  &#125;)  // 通过外部的定时器实现（不推荐）  // setInterval(() =&gt; &#123;  // \t\tvm.opacity -= 0.01  // \t\tif(vm.opacity &lt;= 0) vm.opacity = 1  // &#125;,16)&lt;/script&gt;\n\n\n分析生命周期\n&lt;title&gt;分析生命周期&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\t&lt;div id=&quot;root&quot; :x=&quot;n&quot;&gt;\t\t&lt;h2 v-text=&quot;n&quot;&gt;&lt;/h2&gt;\t\t&lt;h2&gt;当前的n值是：&#123;&#123; n &#125;&#125;&lt;/h2&gt;\t\t&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;\t\t&lt;button @click=&quot;bye&quot;&gt;点我销毁vm&lt;/button&gt;\t&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\tVue.config.productionTip = false\tnew Vue(&#123;\t\tel: &#x27;#root&#x27;,\t\t// template:`\t\t// \t&lt;div&gt;\t\t// \t\t&lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;\t\t// \t\t&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;\t\t// \t&lt;/div&gt;\t\t// `,\t\tdata: &#123;\t\t\tn: 1\t\t&#125;,\t\tmethods: &#123;\t\t\tadd() &#123; console.log(&#x27;add&#x27;)\t\t\t\tthis.n++\t\t\t&#125;,\t\t\tbye() &#123;\t\t\t\tconsole.log(&#x27;bye&#x27;)\t\t\t\tthis.$destroy()\t\t\t&#125;\t\t&#125;,\t\twatch: &#123;\t\t\tn() &#123;\t\t\t\tconsole.log(&#x27;n变了&#x27;)\t\t\t&#125;\t\t&#125;,\t\tbeforeCreate() &#123;console.log(&#x27;beforeCreate&#x27;)&#125;,\t\tcreated() &#123;console.log(&#x27;created&#x27;)&#125;,\t\tbeforeMount() &#123;console.log(&#x27;beforeMount&#x27;)&#125;,\t\tmounted() &#123;console.log(&#x27;mounted&#x27;)&#125;,\t\tbeforeUpdate() &#123;console.log(&#x27;beforeUpdate&#x27;)&#125;,\t\tupdated() &#123;console.log(&#x27;updated&#x27;)&#125;,\t\tbeforeDestroy() &#123;console.log(&#x27;beforeDestroy&#x27;)&#125;,\t\tdestroyed() &#123;console.log(&#x27;destroyed&#x27;)&#125;,\t&#125;)&lt;/script&gt;\n\nvm的一生（vm的生命周期）：4对（8个）钩子\n将要创建 &#x3D;&#x3D;&#x3D;》调用beforeCreate函数\n创建完毕 &#x3D;&#x3D;&#x3D;》调用created函数\n\n将要挂载 &#x3D;&#x3D;&#x3D;》调用beforeMount函数【重要】\n挂载完毕 &#x3D;&#x3D;&#x3D;》调用mounted函数\n\n将要更新 &#x3D;&#x3D;&#x3D;》调用beforeUpdate函数\n更新完毕 &#x3D;&#x3D;&#x3D;》调用updated函数\n\n将要销毁 &#x3D;&#x3D;&#x3D;》调用beforeDestroy函数【重要】\n销毁完毕 &#x3D;&#x3D;&#x3D;》调用destroyed函数\n另外3个生命周期钩子nextTick\navtivated和deactivated\n\n\n总结生命周期\n常用的生命周期钩子\nmounted发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\nbeforeDestroy清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n\n\n关于销毁Vue实例\n销毁后借助Vue开发者工具看不到任何信息\n销毁后自定义事件会失效，但原生DOM事件依然有效\n一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了\n\n\n\n&lt;title&gt;引出生命周期&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt;  &lt;button @click=&quot;opacity = 1&quot;&gt;透明度设置为1&lt;/button&gt;  &lt;button @click=&quot;stop&quot;&gt;点我停止变换&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      opacity: 1    &#125;,    methods: &#123;      stop() &#123;        this.$destroy()      &#125;    &#125;,    // Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted    mounted() &#123;      console.log(&#x27;mounted&#x27;, this)      this.timer = setInterval(() =&gt; &#123;        console.log(&#x27;setInterval&#x27;)        this.opacity -= 0.01        if (this.opacity &lt;= 0) this.opacity = 1      &#125;, 16)    &#125;,    beforeDestroy() &#123;      clearInterval(this.timer)      console.log(&#x27;vm即将驾鹤西游了&#x27;)    &#125;,  &#125;)&lt;/script&gt;\n\n\n","categories":["Vue"],"tags":["生命周期"]},{"title":"Vue（四）：MVVM模型与数据代理","url":"/2022/04/01/Vue%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AMVVM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","content":"MVVM模型\nMVVM模型\nM：模型 Model，data中的数据\nV：视图 View，模板代码\nVM：视图模型 ViewModel，Vue实例（相当于一个链接纽带——\n\n\n观察发现\ndata中所有的属性，最后都出现在了vm身上\nvm身上所有的属性 及Vue原型身上所有的属性，在 Vue模板中都可以直接使用\n\nVue中的数据代理Object.defineproperty方法\nlet number = 18let person = &#123;  name: &#x27;张三&#x27;,  sex: &#x27;男&#x27;,&#125;Object.defineProperty(person, &#x27;age&#x27;, &#123;  // value:18,  // enumerable:true,\t\t// 控制属性是否可以枚举，默认值是false  // writable:true,\t\t\t// 控制属性是否可以被修改，默认值是false  // configurable:true\t// 控制属性是否可以被删除，默认值是false  // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值  get() &#123;    console.log(&#x27;有人读取age属性了&#x27;)    return number  &#125;,  // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值  set(value) &#123;    console.log(&#x27;有人修改了age属性，且值是&#x27;, value)    number = value  &#125;&#125;)// console.log(Object.keys(person))console.log(person)\n\n\n数据代理：通过一个对象代理对另一个对象中属性的操作（读&#x2F;写）\n\nlet obj = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123;  get() &#123;    return obj.x  &#125;,  set(value) &#123;    obj.x = value  &#125;&#125;)\n\n\nVue中的数据代理通过vm对象来代理data对象中属性的操作（读&#x2F;写）\nVue中数据代理的好处：更加方便的操作data中的数据\n基本原理\n通过object.defineProperty()把data对象中所有属性添加到vm上\n为每一个添加到vm上的属性，都指定一个 getter setter\n在getter setter内部去操作（读&#x2F;写）data中对应的属性\n\n\n\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;&lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = falseconst vm = new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;        name: &#x27;电子科技大学&#x27;,        address: &#x27;成都&#x27;    &#125;&#125;)&lt;/script&gt;\n\n","categories":["Vue"],"tags":["MVVM模型","数据代理"]},{"title":"Vue（十）：收集表单数据","url":"/2022/04/06/Vue%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","content":"收集表单数据&lt;title&gt;收集表单数据&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;  &lt;form @submit.prevent=&quot;demo&quot;&gt;    账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br /&gt;&lt;br /&gt;    密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br /&gt;&lt;br /&gt;    年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br /&gt;&lt;br /&gt;    性别：    男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;    女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br /&gt;&lt;br /&gt;    爱好：    学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;    打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;    吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;    &lt;br /&gt;&lt;br /&gt;    所属校区    &lt;select v-model=&quot;userInfo.city&quot;&gt;      &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;      &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;      &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;      &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;      &lt;option value=&quot;wuhan&quot;&gt;成都&lt;/option&gt;    &lt;/select&gt;    &lt;br/&gt;&lt;br/&gt;    其他信息：    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受    &lt;a href=&quot;https://www.yuque.com/cessstudy&quot;&gt;《用户协议》&lt;/a&gt;    &lt;button&gt;提交&lt;/button&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;  Vue.config.productionTip = false  new Vue(&#123;    el: &#x27;#root&#x27;,    data: &#123;      userInfo: &#123;        account: &#x27;&#x27;,        password: &#x27;&#x27;,        age: 18,        sex: &#x27;female&#x27;,        hobby: [],        city: &#x27;beijing&#x27;,        other: &#x27;&#x27;,        agree: &#x27;&#x27;      &#125;    &#125;,    methods: &#123;      demo() &#123;        console.log(JSON.stringify(this.userInfo))      &#125;    &#125;  &#125;)&lt;/script&gt;\n\n\n\n若&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的内容就是value值\n若&lt;input type=&quot;radio&quot;/&gt;单选框，则v-model收集的是value值，且要给标签配置value属性\n若&lt;input type=&quot;checkbox&quot;/&gt;多选框\n没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）\n配置了value属性\nv-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\nv-model的初始值是数组，那么收集的就是value组成的数组\n\n\n\n\nv-model的三个修饰符\nlazy 失去焦点后再收集数据\nnumber输入字符串转为有效的数字\ntrim 输入首尾空格过滤\n\n\n\n","categories":["Vue"],"tags":["表单"]},{"title":"将Hexo博客同时部署至GitHub与Gitee","url":"/2022/03/24/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E8%87%B3GitHub%E4%B8%8EGitee/","content":"前言半个多月前在Github上部署了Hexo个人博客：Wu Shihan’Blog。考虑到GitHub经常出现访问不上的情况，如果没有科学上网的话，不够稳定容易翻车，所以打算在国内的Gitee上也部署一份，双重保险！\n前提：已经在Github上成功部署过Hexo博客了，具体的配置过程可以参照此博文：基于Hexo + Github &amp; Gitee 搭建个人Blog\n如何实现将博客同时部署到两个托管平台呢？\n在查阅资料之前，我能想到的解决方案是在本地创建两份一模一样的博客文件，每次更新后分别向Github和Gitee提交两次博文。但我觉得肯定有更简单的解决方案，实现“一键“即可同时更新Github和Gitee上的blog，以下将介绍实现将Hexo博客从单一部署（Github）到多部署（Github+Gitee）的方法。\n第一步：配置ssh文件起初在配置GitHub的时，没有使用config文件，因为只需要将id_rsa.pub文件中的公钥拷贝到个人GitHub的settings下新建ssh就好了。\n但由于部署到两个不同平台时，可能会出现需要用两个不同的邮箱账号的情况，因此就需要用到config。\n\n生成另外一个账号（注册gitee的邮箱）的rsa，因为我是要部署到gitee，所以以gitee_id_rsa命名以区分。\n$ ssh-keygen -t rsa -C &#x27;邮箱名@qq.com&#x27; -f ~/.ssh/gitee_id_rsa\n\n把公钥放到gitee的设置下的ssh中。\n\n\n配置config，在 C:\\Users\\你的账户的名字.ssh 目录下新建一个config文件（没有后缀的），添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）\n# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa  # gitee的ssh路径# githubHost github.com HostName github.com PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa # github的ssh路径\n\n在命令行测试一下\n$ ssh -T git@gitee.com$ ssh -T git@github.com\n\n出现以下则说明测试成功！\n\n\n\n\n第二步：在Gitee中创建一个仓库\n仓库名称要与用户名相同。\n\n\n注：用户名指的是gitee域名里你的名字，而不是你在gitee设置里个性化设置的姓名。\n\n\n\n创建完成后打开当前仓库的gitee pages服务，并勾选”强制使用HTTPS“。\n\n\n注：新建的仓库如果没有任何文件，是没有入口打开Gitee pages服务的，此时可以先自动生成readme文档，使其开启该服务接口。\n\n\n\n第三步：配置博客的_config.yml更新完~&#x2F;.ssh&#x2F;config后，博客的config.yml也要修改（注：不是修改主题的config.yml）\n\n打开博客的_config.yml，找到deployment栏，如下所示：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo:     git@github.com:Milky53/Milky53.github.io.git #这是已经配置的github的repo  branch: master\n\n现在需要加入一个新的repo，保证仓库名称和路径一致。\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo:     github: git@github.com:Milky53/Milky53.github.io.git    gitee: git@gitee.com:wu_shi_han/wu_shi_han.git #新增的gitee的repo  branch: master\n\n第四步：部署博客执行博客提交三件套：\nhexo cleanhexo ghexo d\n\n\n不成功的话\n若提示cannot find repository之类的话，那么是上面前三个步骤中的某一步做错了。\n若是提示邮箱要公开的问题，复制报错提示的网址去邮箱界面把邮箱设置成公开即可。\n\n对于Gitee，它不会自动帮你更新，所以每次部署完之后都要进入gitee pages服务中点一次“更新”。\n","categories":["Blog"],"tags":["博客"]},{"title":"数据结构与算法（一）：栈","url":"/2022/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A0%88/","content":"js中栈的实现方式\n基于数组实现\n基于链表实现\n\n栈的实现（基于数组）// 栈的封装function Stack() &#123;    // 栈中的属性    var items = []    // 栈相关的方法    // 压栈操作    this.push = function (element) &#123;        items.push(element)    &#125;    // 出栈操作    this.pop = function () &#123;        return items.pop()    &#125;    // peek操作    this.peek = function () &#123;        return items[items.length - 1]    &#125;    // 判断栈中的元素是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 获取栈中元素的个数    this.size = function () &#123;        return items.length    &#125;        //toString方法    this.toString = function() &#123;        var resultString = &#x27;&#x27;        for(var i=0;i&lt;this.items.length;i++)&#123;            resultString += this.items[i]+&#x27;&#x27;        &#125;        return resultString    &#125;&#125;//栈的使用var s = new Stack()\n\n栈的相关方法（需自己实现）\npush() 入栈\npop() 出栈\npeek() 返回栈顶元素\nisEmpty() 判断栈是否为空\nsize() 栈中元素个数\ntoString() 将栈结构的内容以字符形式返回\n\n栈实现十进制转二进制// 封装十进制转二进制的函数function dec2bin(decNumer) &#123;    // 定义变量    var stack = new Stack()    var remainder;    // 循环除法    while (decNumer &gt; 0) &#123;        remainder = decNumer % 2        decNumer = Math.floor(decNumer / 2) //向下取整        stack.push(remainder)    &#125;    // 将数据取出    var binayriStrng = &quot;&quot;    while (!stack.isEmpty()) &#123;        binayriStrng += stack.pop()    &#125;    return binayriStrng&#125;// 测试函数alert(dec2bin(10))alert(dec2bin(233))alert(dec2bin(1000))\n\n","categories":["数据结构与算法"],"tags":["栈"]},{"title":"数据结构与算法（七）：树","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%A0%91/","content":"相关概念\n\n所有的树本质上够可以使用二叉树模拟出来（儿子-兄弟表示法旋转）\n\n二叉树二叉树的特性\n一个二叉树第i层的最大节点数为：\n深度为k的二叉树的最大节点总数为：\n对任何非空二叉树T，若表示叶节点的个数、是度为2的非叶节点个数，那么两者满足关系\n\n\n\n完美二叉树（满二叉树）\n除最后一层的叶子节点外，每层节点都有2个子节点\n\n完全二叉树\n除了最后一层外，其它各层的节点都达到最大个数\n且最后一层从左向右的叶节点连续存在，只缺右侧若干节点\n完美二叉树是特殊的完全二叉树\n\n\n二叉搜索树（BST,Binary Search Tree)\n又称二叉排序树或二叉查找树\n\n如果不为空，满足以下性质：\n\n非空左子树的所有键值小于其根节点的键值\n非空右子树的所有键值大于其根节点的键值\n左右子树本身也是都是二叉搜索树\n\n\n优点：\n\n查找效率高 （与深度有关）\n插入、删除效率高\n\n\n缺点：\n\n当插入数据有序时，二叉搜索树深度很大，导致查找效率变低\n\n\n\n二叉搜索树的封装// 创建BinarySearchTreefunction BinarySerachTree() {    // 创建节点构造函数    function Node(key) {        this.key = key        this.left = null        this.right = null    }    // 保存根的属性    this.root = null    // 二叉搜索树相关的操作方法    // 向树中插入数据    BinarySerachTree.prototype.insert = function (key) {        // 1.根据key创建对应的node        var newNode = new Node(key)        // 2.判断根节点是否有值        if (this.root === null) {            this.root = newNode        } else {            this.insertNode(this.root, newNode)        }    }    //递归操作    BinarySerachTree.prototype.insertNode = function (node, newNode) {        if (newNode.key &lt; node.key) { // 1.准备向左子树插入数据            if (node.left === null) { // 1.1.node的左子树上没有内容                node.left = newNode            } else { // 1.2.node的左子树上已经有了内容                this.insertNode(node.left, newNode)            }        } else { // 2.准备向右子树插入数据            if (node.right === null) { // 2.1.node的右子树上没有内容                node.right = newNode            } else { // 2.2.node的右子树上有内容                this.insertNode(node.right, newNode)            }        }    }    // 获取最大值和最小值    BinarySerachTree.prototype.min = function () {        var node = this.root        while (node.left !== null) {            node = node.left        }        return node.key    }    BinarySerachTree.prototype.max = function () {        var node = this.root        while (node.right !== null) {            node = node.right        }        return node.key    }    // 搜索特定的值（递归）    /*        BinarySerachTree.prototype.search = function (key) {            return this.searchNode(this.root, key)        }        BinarySerachTree.prototype.searchNode = function (node, key) {            // 1.如果传入的node为null那么, 那么就退出递归            if (node === null) {                return false            }            // 2.判断node节点的值和传入的key大小            if (node.key &gt; key) { // 2.1.传入的key较小, 向左边继续查找                return this.searchNode(node.left, key)            } else if (node.key &lt; key) { // 2.2.传入的key较大, 向右边继续查找                return this.searchNode(node.right, key)            } else { // 2.3.相同, 说明找到了key                return true            }        }        */    //搜索特定的值（循环）    BinarySerachTree.prototype.search = function (key) {        var node = this.root        while (node !== null) {            if (node.key &gt; key) {                node = node.left            } else if (node.key &lt; key) {                node = node.right            } else {                return true            }        }        return false    }    // 删除节点    BinarySerachTree.prototype.remove = function (key) {        // 1.获取当前的node        var node = this.root        var parent = null        // 2.循环遍历node        while (node) {            if (node.key &gt; key) {                parent = node                node = node.left            } else if (node.key &lt; key) {                parent = node                node = node.right            } else {                if (node.left == null &amp;&amp; node.right == null) {                }            }        }    }    BinarySerachTree.prototype.removeNode = function (node, key) {        // 1.如果传入的node为null, 直接退出递归.        if (node === null) return null        // 2.判断key和对应node.key的大小        if (node.key &gt; key) {            node.left = this.removeNode(node.left, key)        }    }    // 删除结点    BinarySerachTree.prototype.remove = function (key) {        // 1.定义临时保存的变量        var current = this.root        var parent = this.root        var isLeftChild = true //标记当前节点在父节点的左还是右        // 2.开始查找节点        while (current.key !== key) {            parent = current            if (key &lt; current.key) {                isLeftChild = true                current = current.left            } else {                isLeftChild = false                current = current.right            }            // 如果发现current已经指向null, 那么说明没有找到要删除的数据            if (current === null) return false        }        // 3.删除的结点是叶结点        if (current.left === null &amp;&amp; current.right === null) {            if (current == this.root) {                this.root == null            } else if (isLeftChild) {                parent.left = null            } else {                parent.right = null            }        }        // 4.删除有一个子节点的节点        else if (current.right === null) {            if (current == this.root) {                this.root = current.left            } else if (isLeftChild) {                parent.left = current.left            } else {                parent.right = current.left            }        } else if (current.left === null) {            if (current == this.root) {                this.root = current.right            } else if (isLeftChild) {                parent.left = current.right            } else {                parent.right = current.right            }        }        // 5.删除有两个节点的节点        else {            // 1.获取后继节点            var successor = this.getSuccessor(current)            // 2.判断是否是根节点            if (current == this.root) {                this.root = successor            } else if (isLeftChild) {                parent.left = successor            } else {                parent.right = successor            }            // 3.将删除节点的左子树赋值给successor            successor.left = current.left        }        return true    }    // 找后继的方法    BinarySerachTree.prototype.getSuccessor = function (delNode) {        // 1.使用变量保存临时的节点        var successorParent = delNode        var successor = delNode        var current = delNode.right // 要从右子树开始找        // 2.寻找节点        while (current != null) {            successorParent = successor            successor = current            current = current.left        }        // 3.如果是删除图中15的情况, 还需要如下代码        if (successor != delNode.right) {            successorParent.left = successorParent.right            successor.right = delNode.right        }    }    // 遍历方法    // 先序遍历    BinarySerachTree.prototype.preOrderTraversal = function (handler) {        this.preOrderTranversalNode(this.root, handler)    }    BinarySerachTree.prototype.preOrderTranversalNode = function (node, handler) {        if (node !== null) {            handler(node.key)            this.preOrderTranversalNode(node.left, handler)            this.preOrderTranversalNode(node.right, handler)        }    }    // 中序遍历    BinarySerachTree.prototype.inOrderTraversal = function (handler) {        this.inOrderTraversalNode(this.root, handler)    }    BinarySerachTree.prototype.inOrderTraversalNode = function (node, handler) {        if (node !== null) {            this.inOrderTraversalNode(node.left, handler)            handler(node.key)            this.inOrderTraversalNode(node.right, handler)        }    }    // 后续遍历    BinarySerachTree.prototype.postOrderTraversal = function (handler) {        this.postOrderTraversalNode(this.root, handler)    }    BinarySerachTree.prototype.postOrderTraversalNode = function (node, handler) {        if (node !== null) {            this.postOrderTraversalNode(node.left, handler)            this.postOrderTraversalNode(node.right, handler)            handler(node.key)        }    }}\n\n常见操作\ninsert(key)\nsearch(key)\ninOrderTraverse()中序遍历\npreOrderTraverse() 先序遍历\npostOrderTraverse() 后序遍历\nmin 返回树中最小的值/键\nmax 返回树中最大的值/键\nremove(key) 移除某个键\n\n二叉搜索树的删除\n搜索需要删除的节点，如果没有找到，则不需要删除\n\n找到要删除的节点\n\n删除叶子节点\n\n删除只有一个子节点的节点\n\n删除有两个子节点的节点\n\n\n\n\n\n平衡树\n比较好的二叉搜索树数据应该时左右分布均匀的\n但当插入连续树后，分布不均匀，称这种树为非平衡树\n对于一颗平衡二叉树来说，插入/查找的效率时O(logN)\n对于一颗非平衡二叉树，相当于一个链表，效率为O(N)\n\n\n平衡树：树种每个节点左边的子孙节点个数，尽可能的等于右边的子孙节点个数\n常见的平衡树\nAVL树：每个节点多存储了一个额外数据，保持树的平衡。整体效率不如红黑树，实际开发中应用较少。\n红黑树：通过一些特性来保持树的平衡。实际应用基本是红黑树。\n\n\n\n红黑树（数据结构中的难点）\n红黑树的规则\n包含二叉搜索树的规则，另外还添加了以下性质：\n\n节点是红色或黑色。\n\n根节点是黑色。\n\n每个叶子节点都是黑色的空节点（NIL）。\n\n\n​     （即任何包含数据的项都不会作为叶子节点）\n\n每个红色节点的两个子节点都是黑色。\n\n​      （从每个叶子到跟的路径上不能有两个连续的红色节点）\n\n从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n\n\n红黑树的相对平衡\n以上约束确保了红黑树的关键特性：\n\n从根到叶子的最长可能路径，不会超过最短可能路径的两倍长\nwhy？\n性质4 决定了路径不能又两个相连的红色节点\n最短的可能路径都是黑色节点（4个），最长的可能路径是红色黑色交替（7个）\n性质5 所有路径都有相同数目的黑色节点\n表明了没有路径能多余任何其它路径的两倍长\n\n基本是平衡的\n\n虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是最高效的\n\n\n\n还可通过2-3树、2-3-4树对红黑树的平衡进行解释\n\n\n红黑树的变换（变色、旋转）\n插入一个新节点后，有可能树不再平衡，可以通过三种方式发变换，让树保持平衡：变色、左旋转、右旋转\n不符合规则才需要变换\n\n变色\n为了重新符合红黑树的规则，尝试把红色节点变为黑色，或把黑色节点变为红色\n\n\n首先，新插入的节点通常是红色节点。（创建时默认为红色）\n因为插入红色节点时，有可能插入一次时不违反红黑树任何规则的（即不需要牵一发而动全身）\n而插入黑色节点时，必然会导致有一条路径上多了黑色节点，这是很难调整的\n插入红色节点可能导致出现红红相连的情况，但这种情况可以通过变色和旋转来调整\n\n\n\n左旋转\n逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子\n\n\n右旋转\n顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子\n\n\n变换规则\n以下讨论插入的情况：\n设要插入的节点为N，其父节点为P\n其祖父节点为G，其父亲的兄弟节点为U（即P和U同是G的子节点）\n\n\n\n情况一：\n\n新节点N位于树的根上，没有父节点（即第一个插入的元素）\n这种情况下，直接将红色变换成黑色即可，满足性质2\n\n\n情况二：\n\n\n新节点的父节点P是黑色\n性质4没有失效（新节点是红色的），性质5也没有任何问题\n尽管新节点N右两个黑色的叶子节点NIL，但是新节点N是红色的，所以通过它的路径中黑色节点的个数依然相同，满足性质5\n\n\n情况三：\n\nP为红色，U也是红色，此时G一定为黑（父红叔红祖黑）\n\n父红叔红祖黑 —&gt; 父黑叔黑祖红\n\n\n操作方案：\n\n将P和U变换为黑色，并且将G变换为红色。\n（父红叔红祖黑 —&gt; 父黑叔黑祖红）\n\n现在新节点N有了一个黑色的父节点P，所以每条路径上黑色节点的数目没有改变\n\n而从更高的路径上，必然都会经过G节点，所以那些路径的黑色节点数也是不变的，符合性质5\n\n\n\n可能出现的问题：\n\nN的祖父节点G的父节点可能也是红色，这就违反了性质3，可以递归的调整颜色（把G当成新插入的节点看待）\n如果递归调整颜色到了根节点，则需要进行旋转\n\n\n\n\n情况四：\n\nP为红色，U为黑色，N为左子节点，此时G一定为黑（父红叔黑祖黑+N是左儿子）\n—–&gt;父黑祖红\n—–&gt;以G为根右旋转\n\n\n\n操作方案：\n将P变为黑色，G变为红色\n对G进行依次右旋转\n\n\n\n\n情况五：\n\nP为红色，U为黑色，N为右子节点，此时G一定为黑（父红叔黑祖黑+N是右儿子）\n\n—–&gt;以P为根左旋转\n\n—–&gt;将P作为新插入的红色节点考虑即可（即情况四）\n\n—–&gt;父黑祖红\n—–&gt;以G为根右旋转\n\n\n\n操作方案：\n\n对P依次左旋转，形成情况四\n改变颜色\nG进行依次右旋转\n\n\n\n\n\n","categories":["数据结构与算法"],"tags":["树","红黑树"]},{"title":"数据结构与算法（三）：链表","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8/","content":"链表的实现// 封装链表的构造函数function LinkedList() &#123;    // 内部类，封装一个Node类, 用于保存每个节点信息    function Node(element) &#123;        this.element = element        this.next = null    &#125;    // 链表中的属性    this.length = 0    this.head = null    // 链表尾部追加元素方法    LinkedList.prototype.append = function (element) &#123;        // 1.根据新元素创建节点        var newNode = new Node(element)        // 2.判断原来链表是否为空        if (this.head === null) &#123; // 链表尾空            this.head = newNode        &#125; else &#123; // 链表不为空            // 2.1.定义变量, 保存当前找到的节点            var current = this.head            while (current.next) &#123;                current = current.next            &#125;            // 2.2.找到最后一项, 将其next赋值为node            current.next = newNode        &#125;        // 3.链表长度增加1        this.length += 1    &#125;    // 链表的toString方法    LinkedList.prototype.toString = function () &#123;        // 1.定义两个变量        var current = this.head        var listString = &quot;&quot;        // 2.循环获取链表中所有的元素        while (current) &#123;            listString += &quot;,&quot; + current.element            current = current.next        &#125;        // 3.返回最终结果        return listString.slice(1)    &#125;    // 根据下标删除元素    LinkedList.prototype.insert = function (position, element) &#123;        // 1.检测越界问题: 越界插入失败        if (position &lt; 0 || position &gt; this.length) return false        // 2.定义变量, 保存信息        var newNode = new Node(element)        var current = this.head        var previous = null        index = 0        // 3.判断是否列表是否在第一个位置插入        if (position == 0) &#123;            newNode.next = current            this.head = newNode        &#125; else &#123;            while (index++ &lt; position) &#123;                previous = current                current = current.next            &#125;            newNode.next = current            previous.next = newNode        &#125;        // 4.length+1        this.length+=1        return true    &#125;    //get方法    LinkedList.prototype.get = function(positon)&#123;        if (position &lt; 0 || position &gt;= this.length) return null        var current  = this.head        var index = 0        while(index++&lt;position)&#123;            current = current.next        &#125;        return current.data    &#125;    //update方法    LinkedList.prototype.update = function(positon,newData)&#123;        if (position &lt; 0 || position &gt;= this.length) return null        var current  = this.head        var index = 0        while(index++&lt;position)&#123;            current = current.next        &#125;        current.data = newData        return true    &#125;    // 根据位置移除节点    LinkedList.prototype.removeAt = function (position) &#123;        // 1.检测越界问题: 越界移除失败, 返回null        if (position &lt; 0 || position &gt;= this.length) return null        // 2.定义变量, 保 存信息        var current = this.head        var previous = null        var index = 0        // 3.判断是否是移除第一项        if (position === 0) &#123;            this.head = current.next        &#125; else &#123;            while (index++ &lt; position) &#123;                previous = current                current = current.next            &#125;            previous.next = current.next        &#125;        // 4.length-1        this.length--        // 5.返回移除的数据        return current.element    &#125;    // 根据元素获取链表中的位置    LinkedList.prototype.indexOf = function (element) &#123;        // 1.定义变量, 保存信息        var current = this.head        index = 0        // 2.找到元素所在的位置        while (current) &#123;            if (current.element === element) &#123;                return index            &#125;            index++            current = current.next        &#125;        // 3.来到这个位置, 说明没有找到, 则返回-1        return -1    &#125;    // 根据元素删除信息    LinkedList.prototype.remove = function (element) &#123;        var index = this.indexOf(element)        return this.removeAt(index)    &#125;    // 判断链表是否为空    LinkedList.prototype.isEmpty = function () &#123;        return this.length == 0    &#125;    // 获取链表的长度    LinkedList.prototype.size = function () &#123;        return this.length    &#125;    // 获取第一个节点    LinkedList.prototype.getFirst = function () &#123;        return this.head.element    &#125;&#125;// 测试链表// 1.创建链表var list = new LinkedList()// 2.追加元素list.append(15)list.append(10)list.append(20)// 3.打印链表的结果alert(list) // 15,10,20// 4.测试insert方法list.insert(0, 100)list.insert(4, 200)list.insert(2, 300)alert(list) // 100,15,300,10,20,200// 5.测试removeAt方法list.removeAt(0)list.removeAt(1)list.removeAt(3)alert(list)// 6.测试indexOf方法//    alert(list.indexOf(15))//    alert(list.indexOf(10))//    alert(list.indexOf(20))//    alert(list.indexOf(100))// 7.测试remove方法list.remove(15)alert(list)// 8.测试其他方法alert(list.isEmpty())alert(list.size())alert(list.getFirst())document.write(&#x27;\\u66f4\\u591a\\u6559\\u7a0b\\u8bf7\\u8bbf\\u95ee\\u0020\\u0069\\u0074\\u006a\\u0063\\u0038\\u002e\\u0063\\u006f\\u006d&#x27;);\n\n链表的相关方法（增删改查）\nappend(element) 向链表尾部添加一个新的项\ninsert(position,element) 向链表的特定位置插入一个新的项\nget(position) 获取对应位置元素\nindexOf(element) 返回元素在链表中的索引，没有则返回-1\nupdate(position) 修改某个位置的元素\nremoveAt(position) 从链表的特定位置移除一项\nremove(element) 从链表中移除一项\nisEmpty() 判断链表是否为空\nsize() 链表中元素个数\ntoString() 将链表结构的内容以字符形式返回，重写js的toString方法\n\n双向链表\n便于访问前一个节点，可以从头遍历到尾，也可以从尾遍历到头\n\n// 创建双向链表的构造函数    function DoublyLinkedList() &#123;        // 创建节点构造函数        function Node(element) &#123;            this.element = element            this.next = null            this.prev = null // 新添加的        &#125;        // 定义属性        this.length = 0        this.head = null        this.tail = null // 新添加的        // 定义相关操作方法        // 在尾部追加数据        DoublyLinkedList.prototype.append = function (element) &#123;            // 1.根据元素创建节点            var newNode = new Node(element)            // 2.判断列表是否为空列表            if (this.head == null) &#123;                this.head = newNode                this.tail = newNode            &#125; else &#123;                this.tail.next = newNode                newNode.prev = this.tail                this.tail = newNode            &#125;            // 3.length+1            this.length++        &#125;        // 在任意位置插入数据        DoublyLinkedList.prototype.insert = function (position, element) &#123;            // 1.判断越界的问题            if (position &lt; 0 || position &gt; this.length) return false            // 2.创建新的节点            var newNode = new Node(element)            // 3.判断插入的位置            if (position === 0) &#123; // 在第一个位置插入数据                // 判断链表是否为空                if (this.head == null) &#123;                    this.head = newNode                    this.tail = newNode                &#125; else &#123;                    this.head.prev = newNode                    newNode.next = this.head                    this.head = newNode                &#125;            &#125; else if (position === this.length) &#123; // 插入到最后的情况                // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?                this.tail.next = newNode                newNode.prev = this.tail                this.tail = newNode            &#125; else &#123; // 在中间位置插入数据                // 定义属性                var index = 0                var current = this.head                var previous = null                // 查找正确的位置                while (index++ &lt; position) &#123;                    previous = current                    current = current.next                &#125;                // 交换节点的指向顺序                newNode.next = current                newNode.prev = previous                current.prev = newNode                previous.next = newNode            &#125;            // 4.length+1            this.length++            return true        &#125;        // 根据位置删除对应的元素        DoublyLinkedList.prototype.removeAt = function (position) &#123;            // 1.判断越界的问题            if (position &lt; 0 || position &gt;= this.length) return null            // 2.判断移除的位置            var current = this.head            if (position === 0) &#123;                if (this.length == 1) &#123;                    this.head = null                    this.tail = null                &#125; else &#123;                    this.head = this.head.next                    this.head.prev = null                &#125;            &#125; else if (position === this.length -1) &#123;                this.tail = this.tail.prev                this.tail.next = null            &#125; else &#123;                var index = 0                var previous = null                while (index++ &lt; position) &#123;                    previous = current                    current = current.next                &#125;                previous.next = current.next                current.next.prev = previous            &#125;            // 3.length-1            this.length--            return current.element        &#125;        // 根据元素获取在链表中的位置        DoublyLinkedList.prototype.indexOf = function (element) &#123;            // 1.定义变量保存信息            var current = this.head            var index = 0            // 2.查找正确的信息            while (current) &#123;                if (current.element === element) &#123;                    return index                &#125;                index++                current = current.next            &#125;            // 3.来到这个位置, 说明没有找到, 则返回-1            return -1        &#125;        // 根据元素删除        DoublyLinkedList.prototype.remove = function (element) &#123;            var index = this.indexOf(element)            return this.removeAt(index)        &#125;        // 判断是否为空        DoublyLinkedList.prototype.isEmpty = function () &#123;            return this.length === 0        &#125;        // 获取链表长度        DoublyLinkedList.prototype.size = function () &#123;            return this.length        &#125;        //get        DoublyLinkedList.prototype.get = function(positon)&#123;            if (position &lt; 0 || position &gt;= this.length) return null            //this.length / 2 &gt;= positon: 从头向后遍历            if(this.length/2 &gt;= positon)&#123;                var current  = this.head                var index = 0                while(index++&lt;position)&#123;                    current = current.next                &#125;            &#125;            //this.length / 2 &lt; positon: 从后向前遍历            else&#123;                var current  = this.tail                var index = this.length-1                while(index--&gt;position)&#123;                    current = current.prev                &#125;            &#125;            return current.data        &#125;        //update方法        DoublyLinkedList.prototype.update = function(positon,newData)&#123;            if (position &lt; 0 || position &gt;= this.length) return null            //this.length / 2 &gt;= positon: 从头向后遍历            if(this.length/2 &gt;= positon)&#123;                var current  = this.head                var index = 0                while(index++&lt;position)&#123;                    current = current.next                &#125;            &#125;            //this.length / 2 &lt; positon: 从后向前遍历            else&#123;                var current  = this.tail                var index = this.length-1                while(index--&gt;position)&#123;                    current = current.prev                &#125;            &#125;            current.data = newData            return true        &#125;        // 获取第一个元素        DoublyLinkedList.prototype.getHead = function () &#123;            return this.head.element        &#125;        // 获取最后一个元素        DoublyLinkedList.prototype.getTail = function () &#123;            return this.tail.element        &#125;        // 遍历方法的实现        // 正向遍历的方法        DoublyLinkedList.prototype.forwardString = function () &#123;            var current = this.head            var forwardStr = &quot;&quot;            while (current) &#123;                forwardStr += &quot;,&quot; + current.element                current = current.next            &#125;            return forwardStr.slice(1)        &#125;        // 反向遍历的方法        DoublyLinkedList.prototype.reverseString = function () &#123;            var current = this.tail            var reverseStr = &quot;&quot;            while (current) &#123;                reverseStr += &quot;,&quot; + current.element                current = current.prev            &#125;            return reverseStr.slice(1)        &#125;        // 实现toString方法        DoublyLinkedList.prototype.toString = function () &#123;            return this.forwardString()        &#125;    &#125;\n\n双向链表的相关方法（增删改查）\nappend(element) 向链表尾部添加一个新的项\ninsert(position,element) 向链表的特定位置插入一个新的项\nget(position) 获取对应位置元素\nindexOf(element) 返回元素在链表中的索引，没有则返回-1\nupdate(position) 修改某个位置的元素\nremoveAt(position) 从链表的特定位置移除一项\nremove(element) 从链表中移除一项\nisEmpty() 判断链表是否为空\nsize() 链表中元素个数\ntoString() 将链表结构的内容以字符形式返回，重写js的toString方法\nforwardString() 返回正向遍历的节点字符串形式\nreverseString() 返回反向遍历的节点字符串形式\n\n","categories":["数据结构与算法"],"tags":["链表"]},{"title":"数据结构与算法（九）：排序","url":"/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%8E%92%E5%BA%8F/","content":"大O表示法\n\n排序算法：冒泡排序、选择排序、插入排序、归并排序、计数排序（counting sort)、基数排序(radix sort)、希尔排序、堆排序、桶排序\n\n简单排序// 封装ArrayListfunction ArrayList() {    this.array = []    ArrayList.prototype.insert = function (item) {        this.array.push(item)    }    ArrayList.prototype.toString = function () {        return this.array.join('-')    }}\n\n冒泡排序\n时间复杂度：\n比较次数：\n交换次数：\n\n\n\n//交换两个位置的数据ArrayList.prototype.swap = function (m, n) {    var temp = this.array[m]    this.array[m] = this.array[n]    this.array[n] = temp}//冒泡排序ArrayList.prototype.bubbleSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.反向循环, 因此次数越来越少    for (var i = length - 1; i &gt;= 0; i--) {        // 3.根据i的次数, 比较循环到i位置        for (var j = 0; j &lt; i; j++) {            // 4.如果j位置比j+1位置的数据大, 那么就交换            if (this.array[j] &gt; this.array[j+1]) {                // 交换                this.swap(j, j+1)            }        }    }}\n\n\n\n选择排序\n时间复杂度：\n比较次数：\n交换次数：\n选择排序同在认为在执行效率上高于冒泡排序\n\n\nArrayList.prototype.selectionSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.外层循环: 从0位置开始取出数据, 直到length-2位置    for (var i = 0; i &lt; length - 1; i++) {        // 3.内层循环: 从i+1位置开始, 和后面的内容比较        var min = i        for (var j = min + 1; j &lt; length; j++) {            // 4.如果i位置的数据大于j位置的数据, 记录最小的位置            if (this.array[min] &gt; this.array[j]) {                min = j            }        }        this.swap(min, i)    }}\n\n\n\n插入排序\n时间复杂度：\n比较次数：\n复制次数：\n插入排序是简单排序中效率最好的\n对于基本有序的数据来说，插入排序要好很多\n\n\nArrayList.prototype.insertionSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后    for (var i = 1; i &lt; length; i++) {        // 3.记录选出的元素, 放在变量temp中        var j = i        var temp = this.array[i]        // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环        while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) {            this.array[j] = this.array[j-1]            j--        }        // 5.将选出的j位置, 放入temp元素        this.array[j] = temp    }}\n\n高级排序希尔排序\n\n最快情况下时间复杂度：，通常情况下都好于\n希尔排序是插入排序的一种高效的改进版，其效率比插入排序更快\n\n\n\n数据按间隔分组，组内插入排序。下一次分组间隔减小，直到间隔为1时，进行插入排序。\n\n如何选择间隔？\n\n\n希尔排序大多数情况下效率高于简单排序\n\n在合适的增量和某些数量N的情况下，甚至好于快速排序\n\n\nArrayList.prototype.shellSort = function () {    // 1.获取数组的长度    var length = this.array.length    // 2.根据长度计算增量    var gap = Math.floor(length / 2)    // 3.增量不断变量小, 大于0就继续排序    while (gap &gt; 0) {        // 4.以gap为间隔进行分组，对组内进行插入排序        for (var i = gap; i &lt; length; i++) {            // 4.1.保存临时变量            var j = i            var temp = this.array[i]            // 4.2.插入排序的内层循环            while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) {                this.array[j] = this.array[j - gap]                j -= gap            }            // 4.3.将选出的j位置设置为temp            this.array[j] = temp        }        // 5.重新计算新的间隔        gap = Math.floor(gap / 2)    }}\n\n\n\n快速排序\n平均时间复杂度：\n\n快速排序几乎时目前所有排序算法中最快的排序算法\n\n应用于C++的STL、Java等\n\n快速排序可以看作时最慢的冒泡排序的升级版：在一次循环中（其实时递归调用），找出某个元素的正确位置，并且该元素之后不需要任何移动。\n\n快排思想：分而治之\n\n\n如何选择快速排序的枢纽？\n\n\n\n// 选择枢纽ArrayList.prototype.median = function (left, right) {    // 1.求出中间的位置    var center = Math.floor((left + right) / 2)    // 2.判断并且进行交换 （相当于一个冒泡）    if (this.array[left] &gt; this.array[center]) {        this.swap(left, center)    }    if (this.array[center] &gt; this.array[right]) {        this.swap(center, right)    }    if (this.array[left] &gt; this.array[center]) {        this.swap(left, center)    }    // 3.巧妙的操作: 将center移动到right - 1的位置.    this.swap(center, right - 1)    // 4.返回pivot    return this.array[right - 1]}// 快速排序实现ArrayList.prototype.quickSort = function () {    this.quickSortRec(0, this.array.length - 1)}ArrayList.prototype.quickSortRec = function (left, right) {    // 0.递归结束条件    if (left &gt;= right) return    // 1.获取枢纽    var pivot = this.median(left, right)    // 2.开始进行交换    var i = left    var j = right - 1 //枢纽位置    while (i!=j) {        while (this.array[++i] &lt; pivot) { }        while (this.array[--j] &gt; pivot) { }        if (i &lt; j) {            this.swap(i, j)        }    }    // 3.将枢纽放在正确的位置    this.swap(i, right - 1)    // 4.递归调用左边    this.quickSortRec(left, i - 1)    this.quickSortRec(i + 1, right)}\n\n","categories":["数据结构与算法"],"tags":["排序"]},{"title":"数据结构与算法（二）：队列","url":"/2022/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%98%9F%E5%88%97/","content":"js中队列的实现方式\n基于数组实现：队列基于数组元素性能不高\n基于链表实现\n\n队列的实现（基于数组）// 自定义队列function Queue() &#123;    var items = []    // 队列操作的方法    // enter queue方法    this.enqueue = function (element) &#123;        items.push(element)    &#125;    // delete queue方法    this.dequeue = function () &#123;        return items.shift()    &#125;    // 查看前端的元素    this.front = function () &#123;        return items[0]    &#125;    // 查看队列是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 查看队列中元素的个数    this.size = function () &#123;        return items.length    &#125;        //toString方法    this.toString = function() &#123;        var resultString = &#x27;&#x27;        for(var i=0;i&lt;this.items.length;i++)&#123;            resultString += this.items[i]+&#x27;&#x27;        &#125;        return resultString    &#125;&#125;// 创建队列对象var queue = new Queue()\n\n队列的相关方法（需自己实现）\nenqueue() 入队\ndequeue() 出队\nfront() 返回队列中第一个元素\nisEmpty() 判断队列是否为空\nsize() 队列中元素个数\ntoString() 将队列结构的内容以字符形式返回\n\n队列实现击鼓传花// 实现击鼓传花的函数function passGame(nameList, num) &#123;    // 1.创建一个队列, 并且将所有的人放在队列中    // 1.1.创建队列    var queue = new Queue()    // 1.2.通过for循环, 将nameList中的人放在队列中    for (var i = 0; i &lt; nameList.length; i++) &#123;        queue.enqueue(nameList[i])    &#125;    // 2.寻找最后剩下的人    while (queue.size() &gt; 1) &#123;        // 将前num-1中的人, 都从队列的前端取出放在队列的后端        for (var i = 0; i &lt; num-1; i++) &#123;            queue.enqueue(queue.dequeue())        &#125;        // 将第num个人, 从队列中移除        queue.dequeue()    &#125;    // 3.获取剩下的一个人    alert(queue.size())    var endName = queue.dequeue()    alert(&quot;最终留下来的人:&quot; + endName)    // 4.获取该人在队列中的位置    return nameList.indexOf(endName)&#125;// 验证结果var names = [&#x27;John&#x27;,&#x27;Jack&#x27;,&#x27;Camila&#x27;,&#x27;Ingrid&#x27;,&#x27;Carl&#x27;];var index = passGame(names, 7)alert(&quot;最终位置:&quot; + index)\n\n优先级队列\n优先级队列，在插入一个元素的时候会考虑该数据的优先级，和其它数据优先级进行比较，比较完成后，可以得出这个元素在。\n应用：计算机中线程处理的任务重要性不同\n\n// 封装优先级队列function PriorityQueue() &#123;    var items = []    // 内部类，封装一个新的构造函数, 用于保存元素和元素的优先级    function QueueElement(element, priority) &#123;        this.element = element        this.priority = priority    &#125;    // 添加元素的方法    this.enqueue = function (element, priority) &#123;        // 1.根据传入的元素, 创建新的QueueElement        var queueElement = new QueueElement(element, priority)        // 2.获取传入元素应该在正确的位置        if (this.isEmpty()) &#123;            items.push(queueElement)        &#125; else &#123;            var added = false            for (var i = 0; i &lt; items.length; i++) &#123;                // 注意: 我们这里是数字越小, 优先级越高                if (queueElement.priority &lt; items[i].priority) &#123;                    //第二个参数为0时，为插入函数                    items.splice(i, 0, queueElement)                    added = true                    break                &#125;            &#125;            // 遍历完所有的元素, 优先级都大于新插入的元素时, 就插入到最后            if (!added) &#123;                items.push(queueElement)            &#125;        &#125;    &#125;    // 删除元素的方法    this.dequeue = function () &#123;        return items.shift()    &#125;    // 获取前端的元素    this.front = function () &#123;        return items[0]    &#125;    // 查看元素是否为空    this.isEmpty = function () &#123;        return items.length == 0    &#125;    // 获取元素的个数    this.size = function () &#123;        return items.length    &#125;&#125;// 创建优先级队列对象var pQueue = new PriorityQueue()// 添加元素    pQueue.enqueue(&quot;abc&quot;, 10)    pQueue.enqueue(&quot;cba&quot;, 5)    pQueue.enqueue(&quot;nba&quot;, 12)    pQueue.enqueue(&quot;mba&quot;, 3)    document.write(&#x27;\\u66f4\\u591a\\u6559\\u7a0b\\u8bf7\\u8bbf\\u95ee\\u0020\\u0069\\u0074\\u006a\\u0063\\u0038\\u002e\\u0063\\u006f\\u006d&#x27;);    // 遍历所有的元素    var size = pQueue.size()    for (var i = 0; i &lt; size; i++) &#123;        var item = pQueue.dequeue()        alert(item.element + &quot;-&quot; + item.priority)    &#125;\n\n","categories":["数据结构与算法"],"tags":["队列"]},{"title":"数据结构与算法（五）：字典","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AD%97%E5%85%B8/","content":"\n字典中的ke不可以重复，value可以重复\nkey是无序的\nES6中包含了字典，可以直接使用\n\n字典的实现（基于对象）// 创建字典的构造函数function Dictionay() &#123;    // 字典属性    this.items = &#123;&#125;    // 字典操作方法    // 在字典中添加键值对    Dictionay.prototype.set = function (key, value) &#123;        this.items[key] = value    &#125;    // 判断字典中是否有某个key    Dictionay.prototype.has = function (key) &#123;        return this.items.hasOwnProperty(key)    &#125;    // 从字典中移除元素    Dictionay.prototype.remove = function (key) &#123;        // 1.判断字典中是否有这个key        if (!this.has(key)) return false        // 2.从字典中删除key        delete this.items[key]        return true    &#125;    // 根据key去获取value    Dictionay.prototype.get = function (key) &#123;        return this.has(key) ? this.items[key] : undefined    &#125;    // 获取所有的keys    Dictionay.prototype.keys = function () &#123;        return Object.keys(this.items)    &#125;    // 获取所有的value    Dictionay.prototype.values = function () &#123;        return Object.values(this.items)    &#125;    // size方法    Dictionay.prototype.size = function () &#123;        return this.keys().length    &#125;    // clear方法    Dictionay.prototype.clear = function () &#123;        this.items = &#123;&#125;    &#125;&#125;\n\n","categories":["数据结构与算法"],"tags":["字典"]},{"title":"数据结构与算法（八）：图论","url":"/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BE%E8%AE%BA/","content":"相关概念\n\n\n图的表示邻接矩阵\n二维数组\n邻接矩阵让每个节点和一个整数相关联，该整数作为数组的下标值\n\n\n\n优点：\n方便表示有向图、带权图\n\n\n缺点：\n如果图是一个稀疏图，则矩阵中会存在大量的0，浪费存储空间\n\n\n\n邻接表\n邻接表由图中每个顶点以及和顶点相邻的顶点列表组成\n这个列表有多种存储方式：数组、链表、字典（哈希表）等\n\n\n\n优点：\n计算出度简单\n\n\n缺点：\n计算入度麻烦，必须构造逆邻接表才能有效计算入度（开发中出度相对用的比较少）\n\n\n\n图的实现（基于邻接表）function Graph() &#123;    // 属性    this.vertexes = [] // 存储顶点    this.adjList = new Dictionay() // 存储边，字典由自己封装dict.js    // 添加方法    Graph.prototype.addVertex = function (v) &#123;        this.vertexes.push(v)        this.adjList.set(v, [])    &#125;    Graph.prototype.addEdge = function (v, w) &#123;        this.adjList.get(v).push(w)        this.adjList.get(w).push(v)    &#125;    Graph.prototype.toString = function () &#123;        var resultStr = &quot;&quot;        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            resultStr += this.vertexes[i] + &quot;-&gt;&quot;            var adj = this.adjList.get(this.vertexes[i])            for (var j = 0; j &lt; adj.length; j++) &#123;                resultStr += adj[j] + &quot; &quot;            &#125;            resultStr += &quot;\\n&quot;        &#125;        return resultStr    &#125;    // 初始化颜色    Graph.prototype.initializeColor = function () &#123;        var colors = []        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            colors[this.vertexes[i]] = &quot;white&quot;        &#125;        return colors    &#125;    // 广度优先算法    Graph.prototype.bfs = function (v, handler) &#123;        // 1.初始化颜色        var color = this.initializeColor()        // 2.创建队列        var queue = new Queue()   //队列由自己封装queue.js        // 3.将传入的顶点放入队列中        queue.enqueue(v)        // 4.从队列中依次取出和放入数据        while (!queue.isEmpty()) &#123;            // 4.1.从队列中取出数据            var qv = queue.dequeue()            // 4.2.获取qv相邻的所有顶点            var qAdj = this.adjList.get(qv)            // 4.3.将qv的颜色设置成灰色（为            color[qv] = &quot;gray&quot;            // 4.4.将qAdj的所有顶点依次压入队列中            for (var i = 0; i &lt; qAdj.length; i++) &#123;                var a = qAdj[i]                if (color[a] === &quot;white&quot;) &#123;                    color[a] = &quot;gray&quot;                    queue.enqueue(a)                &#125;            &#125;            // 4.5.因为qv已经探测完毕, 将qv设置成黑色            color[qv] = &quot;black&quot;            // 4.6.处理qv            if (handler) &#123;                handler(qv)            &#125;        &#125;    &#125;    // 深度优先搜索    Graph.prototype.dfs = function (handler) &#123;        // 1.初始化颜色        var color = this.initializeColor()        // 2.遍历所有的顶点, 开始访问        for (var i = 0; i &lt; this.vertexes.length; i++) &#123;            if (color[this.vertexes[i]] === &quot;white&quot;) &#123;                this.dfsVisit(this.vertexes[i], color, handler)            &#125;        &#125;    &#125;    // dfs的递归调用方法    Graph.prototype.dfsVisit = function (u, color, handler) &#123;        // 1.将u的颜色设置为灰色        color[u] = &quot;gray&quot;        // 2.处理u顶点        if (handler) &#123;            handler(u)        &#125;        // 3.u的所有邻接顶点的访问        var uAdj = this.adjList.get(u)        for (var i = 0; i &lt; uAdj.length; i++) &#123;            var w = uAdj[i]            if (color[w] === &quot;white&quot;) &#123;                this.dfsVisit(w, color, handler)            &#125;        &#125;        // 4.将u设置为黑色        color[u] = &quot;black&quot;    &#125;&#125;\n\n图的遍历\n广度优先搜索（BFS,Breadth-First Search)\n基于队列：入队列的顶点先被搜索\n从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层（类似树中的层序遍历）\n\n\nBFS的实现\n深度优先搜索（DFS,Depth-First Search)\n基于栈或使用递归：通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问\n从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问完毕，接着原路回退并探索下一条路径（类似树中的先序遍历）\n\nDFS的实现\n","categories":["数据结构与算法"],"tags":["图"]},{"title":"数据结构与算法（十）：动态规划","url":"/2022/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"链接：https://leetcode-cn.com/problems/maximum-subarray/solution/dai-ma-sui-xiang-lu-53-zui-da-zi-xu-he-b-xqus/来源：力扣（LeetCode）\n\n","categories":["数据结构与算法"],"tags":["动态规划"]},{"title":"数据结构与算法（六）：哈希表","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"\n数组进行插入、删除、修改操作，效率较低\n数组查找操作：\n\n基于索引查找，效率高\n基于内容查找，效率低\n\n哈希表是基于数组实现的，但是它相对于数组有很多优势：\n\n非常快速插入、删除、查找\n速度比树还要快，瞬间查找\n相对于树来说更容易编码\n\n哈希表缺点：\n\n数据无序，不能以固定方式（比如从小到大）来遍历其中的元素\nkey不允许重复\n\n哈希表的结构是数组，它通过哈希函数对下标值进行变换，通过哈希函数可以获取HashCode\n\n相关概念哈希化将大数字转化成数组范围内下标的过程（如取余），称为哈希化\n哈希函数通常我们会将单词（key）转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数称为哈希函数\n哈希表最终将数据插入到的这个数组，对整个结构的封装，称之为一个哈希表\n装填因子（loadFactor）表示当前哈希表中已经包含的数据项和整个哈希表长度的比值\n装填因子&#x3D;总数据项&#x2F;哈希表长度\n哈希表的冲突\n两个大数字哈希化后得到的下标相同，称为冲突，冲突不可避免\n\n解决冲突\n链地址法（拉链法）\n\n每个数组单元中存储的不再是单个数据，而是一个链条（数组或链表）\n比如是链表，一旦发现重复，则将重复的元素插入到链表的首端或末端即可\n查询时，根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找寻找的数据\n数组or链表？\n效率上差不多，因为在对应位置查找时，使用线性查找\n在某些实现中，会将新插入的数据放在链条的最前面，因为认为新插入的数据用于取出的可能性更大，这个时候最好采用链表（插入效率高）\n根据业务需求选择数据结构，不见得新数据访问次数会更多：比如微信新添加的好友没有老朋友联系频繁\n\n\n\n\n开放地址法\n\n寻找空白的位置来放置冲突的数据项，探测这个位置有三种方法：\n\n线性探测\n线性查找空白的单元\n插入：从index位置+1开始一点点找合适的位置（空的位置就是合适的位置）\n查找：与插入相似，注意如果查找的元素之前没有插入哈希表，不需要查询整个表，而是查询到空位置就停止\n删除：与插入相似，注意删除一个数据项时，不可以将这个位置的内容设置为空null，因为如果设置为null可能会影响之后查找其它数据，因此通常将它进行特殊处理（比如设置为-1）。当之后看到-1的数据项时，就知道查询时要继续查询，但插入的时候这个位置可以放置数据。\n问题：聚集会影响性能\n\n二次探测\n在线性探测的基础上进行优化，优化探测时的步长\n比如从下标值x开始，$$x+1^2,x+2^2,x+3^2$$,这样可以一次探测较长的距离，避免聚集带来的影响\n问题：连续插入的是哈希化后相同的数据想，造成步长不一的一种聚集\n\n再哈希法\n依赖于关键字的探测序列，不同关键字即使映射到相同的数组下标，也可以使用不同的探测序列\n第二次哈希化：把关键字用另外一个哈希函数在做一次哈希化，用这次哈希化的结果作为步长\n对于指定关键字，步长在整个探测中是不变的，不过不同关键字使用不同的步长\n\n第二次哈希化的特点：与第一个哈希函数不同，且不能输出为0\nstepSize &#x3D; constant - （key % constant）\n其中constant是质数，且小于数组的容量\n\n\n\n\n\n\n\n\n哈希化的效率\n如果没有产生冲突，那么效率会更高\n\n如果发生冲突，存取时间就依赖后来的探测长度\n\n平均探测长度及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长\n装填因子&#x3D;总数据项&#x2F;哈希表长度\n开放地址法装填因子：最大是1，因为它必须找到空白的单元才能将元素放入\n链地址法的装填因子：可以大于1，因为它可以无限的延伸下去\n\n\n线性探测的性能\n\n\n二次探测和再哈希法的性能\n\n\n\n\n链地址法的性能\n\n\n真实开发中，使用链地址法的情况较多\n\n因为它不会因为添加了某元素后性能急剧下降\n比如在Java中的HashMap中使用的就是链地址法\n\n\n\n哈希函数好的哈希函数应该具备的特点\n快速的计算\n哈希函数中尽量少有乘法和除法，因为它们性能较低\n\n均匀的分布\n\n\n快速计算：霍纳法则\n均匀分布\n\n再哈希表中的质数很重要\n链地址法中的质数不重要\n\n哈希函数的实现//设计哈希函数//1&gt; 将字符串转成比较大的数字：hashCode//2&gt; 将大的数字hashCode压缩到数组范围（大小）之内function hashFunc(str, size) &#123;    // 1.初始化hashCode的值    var hashCode = 0    // 2.霍纳算法, 来计算hashCode的数值    for (var i = 0; i &lt; str.length; i++) &#123;        //charCodeAt()可以获取Unicode编码，质数常用37        hashCode = 37 * hashCode + str.charCodeAt(i)    &#125;    // 3.取模运算    hashCode = hashCode % size    return hashCode&#125;alert(hashFunc(&quot;abc&quot;, 7)) // 4    alert(hashFunc(&quot;cba&quot;, 7)) // 3    alert(hashFunc(&quot;nba&quot;, 7)) // 5    alert(hashFunc(&quot;mba&quot;, 7)) // 1\n\n哈希表的实现（链地址法）// 创建HashTable构造函数function HashTable() &#123;    // 定义属性    this.storage = []    this.count = 0   //记录数组里已经存放的元素数    this.limit = 8   //数组的长度    // 定义相关方法    // 判断是否是质数    HashTable.prototype.isPrime = function (num) &#123;        var temp = parseInt(Math.sqrt(num))        // 2.循环判断        for (var i = 2; i &lt;= temp; i++) &#123;            if (num % i == 0) &#123;                return false            &#125;        &#125;        return true    &#125;    // 获取质数    HashTable.prototype.getPrime = function (num) &#123;        while (!isPrime(num)) &#123;            num++        &#125;        return num    &#125;    // 哈希函数    HashTable.prototype.hashFunc = function(str, max) &#123;        // 1.初始化hashCode的值        var hashCode = 0        // 2.霍纳算法, 来计算hashCode的数值        for (var i = 0; i &lt; str.length; i++) &#123;            hashCode = 37 * hashCode + str.charCodeAt(i)        &#125;        // 3.取模运算        hashCode = hashCode % max        return hashCode    &#125;    // 插入&amp;修改数据方法    HashTable.prototype.put = function (key, value) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.取出数组(也可以使用链表)        // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]        var bucket = this.storage[index]        // 3.判断这个数组是否存在        if (bucket === undefined) &#123;            // 3.1创建桶            bucket = []            this.storage[index] = bucket        &#125;        // 4.判断是新增还是修改原来的值.        var override = false        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]    //tuple = [k,v]            if (tuple[0] === key) &#123;                tuple[1] = value                override = true            &#125;        &#125;        // 5.如果是新增, 前一步没有覆盖        if (!override) &#123;            bucket.push([key, value])            this.count++            if (this.count &gt; this.limit * 0.75) &#123;                var primeNum = this.getPrime(this.limit * 2)                this.resize(primeNum)            &#125;        &#125;    &#125;    // 获取存放的数据    HashTable.prototype.get = function (key) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.获取对应的bucket        var bucket = this.storage[index]        // 3.如果bucket为null, 那么说明这个位置没有数据        if (bucket == null) &#123;            return null        &#125;        // 4.有bucket, 判断是否有对应的key  线性查找        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            if (tuple[0] === key) &#123;                return tuple[1]            &#125;        &#125;        // 5.没有找到, return null        return null    &#125;    // 删除数据    HashTable.prototype.remove = function (key) &#123;        // 1.获取key对应的index        var index = this.hashFunc(key, this.limit)        // 2.获取对应的bucket        var bucket = this.storage[index]        // 3.判断同是否为null, 为null则说明没有对应的数据        if (bucket == null) &#123;            return null        &#125;        // 4.遍历bucket, 寻找对应的数据        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            if (tuple[0] === key) &#123;                //从下标值为i的地方删除1个元素                bucket.splice(i, 1)                this.count--                // 缩小数组的容量                if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;                    var primeNum = this.getPrime(Math.floor(this.limit / 2))                    this.resize(primeNum)                &#125;            &#125;            return tuple[1]        &#125;        // 5.来到该位置, 说明没有对应的数据, 那么返回null        return null    &#125;    // isEmpty方法    HashTable.prototype.isEmpty = function () &#123;        return this.count == 0    &#125;    // size方法    HashTable.prototype.size = function () &#123;        return this.count    &#125;    // 哈希表扩容    HashTable.prototype.resize = function (newLimit) &#123;        // 1.保存旧的数组内容        var oldStorage = this.storage        // 2.重置属性        this.limit = newLimit        this.count = 0        this.storage = []        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中        oldStorage.forEach(function (bucket) &#123;            // 1.bucket为null, 说明这里面没有数据            if (bucket == null) &#123;                return            &#125;            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入            for (var i = 0; i &lt; bucket.length; i++) &#123;                var tuple = bucket[i]                this.put(tuple[0], tuple[1])            &#125;        &#125;).bind(this)    &#125;&#125;\n\n哈希表的扩容思想\n链地址法的装填因子可以大于1，可以无限制的插入新数据\n但随着数据量的增多，每个index对于的bucket会越来越长，造成效率的降低\n因此需要在合适的情况对数组进行扩容\n扩容时所有的数据项一定要同时进行修改（重新调用哈希函数，来获取到不同的位置）\n\n\n什么情况下进行扩容？\n常见情况是loadFactor &gt; 0.75时，进行扩容\n比如java的哈希表就是再装填因子大于0.75时进行扩容的\n缩容：loadFactor &lt; 0.25\n\n\n// 哈希表扩容HashTable.prototype.resize = function (newLimit) &#123;    // 1.保存旧的数组内容    var oldStorage = this.storage    // 2.重置属性    this.limit = newLimit    this.count = 0    this.storage = []    // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中    oldStorage.forEach(function (bucket) &#123;        // 1.bucket为null, 说明这里面没有数据        if (bucket == null) &#123;            return        &#125;        // 2.bucket中有数据, 那么将里面的数据重新哈希化插入        for (var i = 0; i &lt; bucket.length; i++) &#123;            var tuple = bucket[i]            this.put(tuple[0], tuple[1])        &#125;    &#125;).bind(this)&#125;\n\n","categories":["数据结构与算法"],"tags":["哈希表"]},{"url":"/2022/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/","content":""},{"title":"数据结构与算法（四）：集合","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/","content":"\n无序、不重复\n不能通过下标值访问元素\nES6中包含了Array类和Set类，可以直接使用\n但为了学习其内部机制，这里自己封装\n\n集合的实现（基于对象） // 封装集合的构造函数function Set() &#123;    // 使用一个对象来保存集合的元素    this.items = &#123;&#125;    // 集合的操作方法    // 判断集合中是否有某个元素    Set.prototype.has = function (value) &#123;        return this.items.hasOwnProperty(value)    &#125;    // 向集合中添加元素    Set.prototype.add = function (value) &#123;        // 1.判断集合中是否已经包含了该元素        if (this.has(value)) return false        // 2.将元素添加到集合中(键值都为value)        this.items[value] = value        return true    &#125;    // 从集合中删除某个元素    Set.prototype.remove = function (value) &#123;        // 1.判断集合中是否包含该元素        if (!this.has(value)) return false        // 2.包含该元素, 那么将元素删除        delete this.items[value]        return true    &#125;    // 清空集合中所有的元素    Set.prototype.clear = function () &#123;        this.items = &#123;&#125;    &#125;    // 获取集合的大小    Set.prototype.size = function () &#123;        return Object.keys(this.items).length        /*            考虑兼容性问题, 使用下面的代码            var count = 0            for (var value in this.items) &#123;                if (this.items.hasOwnProperty(value)) &#123;                    count++                &#125;            &#125;            return count            */    &#125;    // 获取集合中所有的值    Set.prototype.values = function () &#123;        return Object.keys(this.items)        /*            考虑兼容性问题, 使用下面的代码            var keys = []            for (var value in this.items) &#123;                keys.push(value)            &#125;            return keys            */    &#125;        //集合间的操作    //并集    Set.prototype.union = function (otherSet)&#123;        var unionSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            unionSet.add(values[i])        &#125;                values = otherSet.values()        for(var i = 0;i&lt;values.length;i++)&#123;            unionSet.add(values[i])        &#125;                return unionSet    &#125;    //交集    Set.prototype.intersection = function (otherSet)&#123;        var intersectionSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(otherSet.has(item))&#123;                intersectionSet.add(item)            &#125;        &#125;        return intersectionSet    &#125;    //差集    Set.prototype.difference = function (otherSet)&#123;        var differenceSet = new Set()                var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(!otherSet.has(item))&#123;                differenceSet.add(item)            &#125;        &#125;        return differenceSet    &#125;    //子集    Set.prototype.subset = function (otherSet)&#123;        var values = this.values()        for(var i = 0;i&lt;values.length;i++)&#123;            var item = value[i]            if(!otherSet.has(item))&#123;                return false            &#125;        &#125;        return true    &#125;&#125;\n\n集合的相关方法（增删改查）\nadd(value) \nremove(value)\nhas(value)\nclear()\nsize()\nvalue()\n集合间的操作\n并集 union\n交集 intersection\n差集 difference\n子集 subset\n\n\n\n","categories":["数据结构与算法"],"tags":["集合"]},{"title":"项目搭建相关Tips","url":"/2022/03/05/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3Tips/","content":"CSS文件分类\nindex.css：当前页面样式\n\nreset.css：重置样式\n\nbase.css：公共样式\n.clearfix::before,.clearfix::after&#123;    content:&#x27;&#x27;;    display:table;    clear:both;&#125;body&#123;    font:...;    color:#333;    /*保证浏览器缩小时，中间容器布局不混乱*/    min-width:1226px;&#125;/*中间容器*/.w&#123;    width:1226px;    margin:0 auto;&#125;\n\n生成小三角（利用边框）\n创建一个大小为0的盒子，只保留一边的边框颜色，其余边全设置为透明。\n示例：\n\n.box1&#123;\twidth:0px;    height:0px;    border:10px red solid;    border-top:none;    border-color:trasparent trasparent blue trasparent;&#125;\n\n\n效果：\n\n\n\n网站发布时的压缩\n加载时速度变快\n\n将css和js中的注释、空行去除：\nindex.css -&gt; index.min.css\n工具：\n\nJS &amp; CSS Minifier\n\n\n\n","categories":["项目"],"tags":["CSS","HTML","实战演练"]},{"title":"项目搭建（一）：学业分析系统优化","url":"/2022/05/02/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%A6%E4%B8%9A%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/","content":"\n该项目原来没有用模块化，使用bootstrap框架，代码\n\n\n优化前：没有使用模块化，使用bootstrap框架，代码耦合度高\n优化后：使用vue+elementUi框架\n\n问题及解决方案跨域问题使用代理服务器\nVue（二十四）：Vue脚手架之配置代理\n父子组件通信问题：父组件传值给子组件虽然最后页面可以正常显示。传过来的数据也在，但是会报:”TypeError: Cannot read property ‘xxx’ of undefined”\n原因：父组件传值给子组件但是页面已经开始渲染里但是数据还没传过来\n解决方案：加一个判断如果传给子组件的值还没过来的话先不去加载————————————————原文链接：https://blog.csdn.net/peepeeman/article/details/107387949\nvue父组件异步传递prop到子组件echarts画图问题踩坑总结 - 古兰精 - 博客园 (cnblogs.com)\n4、考虑到父组件传递prop就是渲染时传递。\n　　那么我就可以给子组件加个判断 v-if 条件，当父组件从后台异步取到数据后，并且赋值给prop后，让flag &#x3D; true再去渲染子组件，那么此时传递给子组件的prop就是异步获取到数据之后的值，图形就正常展示出来了。\nElement-UI table的高度动态自适应(16条消息) Element-UI table的高度动态自适应 !_Masics丶的博客-CSDN博客_element table 动态高度\n","categories":["项目"],"tags":["项目"]}]