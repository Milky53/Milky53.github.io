<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Wu Shihan">
    
    <title>
        
            Java基础（二）：面向对象 |
        
        Wu Shihan&#39;Blog
    </title>
    
<link rel="stylesheet" href="../css/style.css">

    <link rel="shortcut icon" href="../../../../images/photo.JPG">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"wu_shi_han.gitee.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#99CC99","avatar":"/images/photo.JPG","favicon":"/images/photo.JPG","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"无论终点在哪儿，过程一定很精彩。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            $logo-title-font-size = 2rem;
$pc-search-icon-font-size = 1.5rem;
$menu-bar-line-height = 2.5px;
$logo-image-box-width = 46px;

.header-wrapper {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--background-color);
  padding-top: $scroll-progress-bar-height;

  hover-style(false, 0, 0);

  .header-content {
    position: relative;
    height: 100%;
    width: $main-content-width;
    max-width: $content-max-width;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    z-index: $z-index-5;


    &.has-first-screen {
      max-width: $content-max-width * 1.2;
    }

    +keep-tablet() {
      width: $main-content-width-tablet;
    }

    +keep-mobile() {
      width: $main-content-width-mobile;
    }

    .left {
      display: flex;
      align-items: center;
      transition-t("transform", "0", "0.2", "linear");

      .header-shrink & {
        transform: scale(0.72);
        transform-origin: left;
      }


      if (hexo-config('base_info.logo_img') && hexo-config('base_info.logo_img') != '') {
        .logo-image {
          width: $logo-image-box-width;
          height: $logo-image-box-width;
          margin-right: 8px;


          +keep-tablet() {
            width: $logo-image-box-width * 0.9;
            height: $logo-image-box-width * 0.9;
          }

          +keep-mobile() {
            width: $logo-image-box-width * 0.8;
            height: $logo-image-box-width * 0.8;
          }

          img {
            border-radius: 6px;
            width: 100%;
          }
        }

      }

      .logo-title {
        font-size: $logo-title-font-size;
        font-weight: bold;
        letter-spacing: 1px;
        line-height: 1;
        color: var(--first-text-color);

        +keep-tablet() {
          font-size: $logo-title-font-size * 0.9;
        }

        +keep-mobile() {
          font-size: $logo-title-font-size * 0.8;
        }
      }

    }


    .right {

      .pc {

        .menu-list {
          display: flex;
          align-items: center;

          +keep-tablet() {
            display: none;
          }


          .menu-item {
            float: left;
            position: relative;
            margin-left: 30px;
            font-size: 1rem;
            cursor: pointer;
            color: var(--default-text-color);

            &:first-child {
              margin-left: 0;
            }


            a:hover, .active {

              &::after {
                content: '';
                position: absolute;
                bottom: -10px;
                left: 50%;
                width: 100%;
                height: 2px;
                transform: translateX(-50%);
                background: var(--primary-color);
                transition-t("transform, bottom", "0, 0", "0.2, 0.2", "linear, linear");

                .header-shrink & {
                  bottom: -($header-shrink-height / 2 - 12);
                }
              }
            }

            &.search {
              font-size: $pc-search-icon-font-size;
              margin-left: 26px;

              i {
                color: var(--default-text-color);
              }

            }
          }


        }

      }


      .mobile {
        display: flex;
        justify-content: space-between;
        align-items: center;

        .icon-item {
          display: none;
          position: relative;
          cursor: pointer;
          font-size: 18px;
          margin-left: 12px;
          width: 20px;
          height: 20px;
          color: var(--default-text-color);

          i {
            color: var(--default-text-color);
          }

          &:first-child {
            margin-left: 0;
          }

          +keep-tablet() {
            display: flex;
            justify-content: center;
            align-items: center;
          }
        }

        .menu-bar {

          .menu-bar-middle {
            width: 18px;
            height: $menu-bar-line-height;
            position: relative;
            background: var(--default-text-color);

            .header-drawer-show & {
              background: transparent;
            }


            &::before, &::after {
              content: '';
              position: absolute;
              left: 0;
              width: 100%;
              height: $menu-bar-line-height;
              background: var(--default-text-color);
              transition-t("transform", "0", "0.38", "ease");
            }


            &::before {
              top: -6px;

              .header-drawer-show & {
                transform: translateY(6px) rotate(45deg);
              }
            }


            &::after {
              bottom: -6px;

              .header-drawer-show & {
                transform: translateY(-6px) rotate(-45deg);
              }
            }
          }
        }
      }
    }
  }


  .header-drawer {
    width: 100%;
    padding: $header-height 0 20px 0;
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleY(0);
    transform-origin: top;
    z-index: $z-index-2;
    background: var(--background-color);
    transition-t("transform", "0", "0.38", "ease");

    .header-drawer-show & {
      transform: scaleY(1);
    }

    .drawer-menu-list {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;

      .drawer-menu-item {
        font-size: 1rem;
        margin: 6px 0;
        height: 38px;

        a {
          padding: 6px 20px;
          border-radius: 20px;
          color: var(--default-text-color);

          &:hover {
            color: var(--second-text-color);
            border: 1px solid var(--default-text-color);
          }


          &.active {
            border: 1px solid var(--default-text-color);
            color: var(--second-text-color);
          }
        }


      }
    }
  }


  .window-mask {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0, 0, 0, 0.4);
    z-index: $z-index-1;
    visibility: hidden;
    opacity: 0;
    transition-t("transform, opacity", "0, 0", "0.38, 0.38", "ease, ease");

    .header-drawer-show & {
      visibility: visible;
      opacity: 1;
    }
  }

}

.header-drawer-show {
  overflow: hidden;
}

        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java基础（二）：面向对象</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="../../../../images/photo.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Wu Shihan</span>
                        
                            <span class="author-label">Lv6</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-01-16 10:55:10</span>
        <span class="mobile">2023-01-16 10:55</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="../../../../categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="../../../../tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Java面向对象学习的三条主线"><a href="#Java面向对象学习的三条主线" class="headerlink" title="Java面向对象学习的三条主线"></a>Java面向对象学习的三条主线</h1><ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的三大特征：封装性、继承性、多态性、（抽象性）</li>
<li>其它关键字：<code>this、super、static、final、abstract、interface、package、import</code></li>
</ol>
<h1 id="属性（成员变量）vs局部变量"><a href="#属性（成员变量）vs局部变量" class="headerlink" title="属性（成员变量）vs局部变量"></a>属性（成员变量）vs局部变量</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li>定义变量的格式：数据类型 变量名 &#x3D; 变量值</li>
<li>先声明 后使用</li>
<li>变量都有其对应的作用域</li>
</ul>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li><p>在类中声明的位置不同</p>
<ul>
<li>属性：直接定义在类的一对{}内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器内部的变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//属性（或成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//局部变量：方法形参（language）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">(String language)</span>&#123; </span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//局部变量：方法内（food）</span></span><br><span class="line">    pubic <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">food</span> <span class="operator">=</span> <span class="string">&quot;烙饼&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于权限修饰符的不同</p>
<ul>
<li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符</p>
<p>常用权限修饰符：private、public、缺省、protected  –&gt;封装性</p>
</li>
<li><p>局部变量：不可以使用权限修饰符</p>
</li>
</ul>
</li>
<li><p>默认初始化值的情况</p>
<ul>
<li><p>属性：类的属性，根据其类型，都有默认初始化值</p>
</li>
<li><p>局部变量：没有默认初始化值</p>
<p>意味着，在调用局部变量之前，一定要显示赋值。</p>
<p>特别地，形参在调用时赋值即可。</p>
</li>
</ul>
</li>
<li><p><strong>在内存中加载的位置</strong></p>
<ul>
<li>属性：加载到<strong>堆空间</strong>中（非static）</li>
<li>局部变量：加载到<strong>栈空间</strong>中</li>
</ul>
<h1 id="JVM内存解析"><a href="#JVM内存解析" class="headerlink" title="JVM内存解析"></a>JVM内存解析</h1></li>
<li><p>引用类型的变量，只可能存储两类值：null 或 地址值</p>
</li>
</ul>
<h1 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h1><ul>
<li>匿名对象：创建的对象没有显式的赋给一个变量名</li>
<li>特征：匿名对象只能调用一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();</span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br></pre></td></tr></table></figure>

<h1 id="方法的重载-overload"><a href="#方法的重载-overload" class="headerlink" title="方法的重载(overload)"></a>方法的重载(overload)</h1><ul>
<li>重载：在同一个类中，允许存在一个以上的同名方法，只要它们的<strong>参数个数</strong>、或<strong>参数类型</strong>、或<strong>参数顺序</strong>不同即可。</li>
<li>判断是否重载：与方法的权限修饰符、返回值类型、形参变量名、方法体都无关，只看参数列表。（只有返回值不同不能算重载）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(String[] arr)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变个数形参的方法"><a href="#可变个数形参的方法" class="headerlink" title="可变个数形参的方法"></a>可变个数形参的方法</h1><ul>
<li>jdk 5.0新增的内容，用更简单的方式传递个数可变的实参</li>
<li>具体使用<ol>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个 … 多个</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组的方法之间不构成重载</li>
<li>可变个数形参在方法的形参中，<strong>必须声明在末尾，且最多只能声明一个可变形参</strong></li>
</ol>
</li>
<li>应用：sql中不定个数的查询条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">MethodArgsTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodArgsTest</span>();</span><br><span class="line">    test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    test.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public void show(String s)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下报错，不构成重载</span></span><br><span class="line">pubic <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i,String ... strs)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h1><h2 id="关于变量的赋值"><a href="#关于变量的赋值" class="headerlink" title="关于变量的赋值"></a>关于变量的赋值</h2><ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的<strong>地址值。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;</span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//此时m=10,n=20</span></span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line"><span class="type">Order</span> <span class="variable">o2</span> <span class="operator">=</span> o1; <span class="comment">//赋值以后，o1和o2地址值相同，都指向了堆空间中同一个对象实体</span></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line"><span class="comment">//此时o1.orderId=1002,o2.orderId=1002</span></span><br></pre></td></tr></table></figure>

<h2 id="方法的形参的传递机制：值传递"><a href="#方法的形参的传递机制：值传递" class="headerlink" title="方法的形参的传递机制：值传递"></a>方法的形参的传递机制：值传递</h2><ol>
<li><p>形参：方法定义时，声明的小括号内的参数</p>
<p>实参：方法调用时，实际传递给形参的数据</p>
</li>
<li><p>值传递机制：</p>
<ul>
<li>如果参数是<strong>基本数据类型</strong>，此时实参赋给形参的是，实参真实存储的数据值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">test.swap(m,n);</span><br><span class="line"><span class="comment">//此时m=10,n=20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果参数是<strong>引用数据类型</strong>，此时实参赋给形参的是，实参存储数据的地址值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>()</span><br><span class="line">data.m = <span class="number">10</span>;</span><br><span class="line">data.n = <span class="number">20</span>;</span><br><span class="line">test.swap(data);</span><br><span class="line"><span class="comment">//此时data.m=20,data.n=10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Data data)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data.m;</span><br><span class="line">    data.m = data.n;</span><br><span class="line">    data.n = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h1><ul>
<li>将类的某个属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。</li>
<li>将类的某个方法私有化（private）</li>
<li>单例模式（构造器私有化）</li>
</ul>
<h1 id="4种权限修饰符"><a href="#4种权限修饰符" class="headerlink" title="4种权限修饰符"></a>4种权限修饰符</h1><blockquote>
<p>封装性的体现，需要权限修饰符来配合。</p>
</blockquote>
<ol>
<li><p>Java规定的4种权限（从小到大排列）：private、缺省、protected、public</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
<li><p>这4种权限可以用来修饰类，及类的内部结构：属性、方法、构造器、内部类</p>
</li>
<li><p>修饰类的内部结构（属性、方法、构造器、内部类）:private、缺省、protected、public</p>
<p>修饰类：缺省、public</p>
</li>
</ol>
<blockquote>
<p>总结<strong>封装性</strong>：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。</p>
</blockquote>
<h1 id="属性赋值的先后顺序"><a href="#属性赋值的先后顺序" class="headerlink" title="属性赋值的先后顺序"></a>属性赋值的先后顺序</h1><ol>
<li>默认初始化</li>
<li>显示初始化</li>
<li>构造器中赋值</li>
<li>通过”对象.方法” 或 “对象.属性” 的方式赋值</li>
</ol>
<p>以上操作的先后顺序：1 - 2 - 3 - 4</p>
<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><ul>
<li>JavaBean时一种Java语言写成的可重用组件（在JavaWeb中会用到，对应数据库中的一张表）</li>
<li>是指符合如下标准的Java类：<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h1><ul>
<li><p>this可用用来修饰：属性、方法、构造器</p>
</li>
<li><p>this修饰属性和方法：</p>
<ul>
<li><p>this理解为：当前对象 或 当前正在创建的对象</p>
</li>
<li><p>在类的方法中，可用使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前对象属性或方法。但是通常情况下，选择忽略this，特殊情况下，如果方法的形参和类的属性同名时，必须显式使用<code>this.属性</code>，表明此时属性而非形参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的构造器中，可用使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前正在创建的对象属性或方法。但是通常情况下，选择忽略this，特殊情况下，如果构造器的形参和类的属性同名时，必须显式使用<code>this.属性</code>，表明此时属性而非形参。</p>
</li>
</ul>
</li>
<li><p>this调用构造器：</p>
<ul>
<li>在类的构造器中，可用显式的使用<code>this(形参列表)</code>方式，调用本类中指定的其他构造器</li>
<li>构造器不能调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1个构造器中使用了<code>this(形参列表)</code></li>
<li><code>this(形参列表)</code>必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个<code>this(形参列表)</code></li>
</ul>
</li>
</ul>
<h1 id="package关键字的使用"><a href="#package关键字的使用" class="headerlink" title="package关键字的使用"></a>package关键字的使用</h1><ul>
<li><p>为了更好的实现项目中类的管理，提供包的概念</p>
</li>
<li><p>使用<code>package</code>声明类或接口所属的包，声明在源文件的首行</p>
</li>
<li><p>package属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）“见名知意”</p>
</li>
<li><p>每<code>.</code>一次，就代表一层文件目录</p>
</li>
<li><p>同一个包下，不能命名同名的接口、类</p>
<p>不同包下，可用命名同名的接口、类</p>
</li>
</ul>
<h1 id="import关键字的使用"><a href="#import关键字的使用" class="headerlink" title="import关键字的使用"></a>import关键字的使用</h1><ul>
<li><p>作用：在源文件中显式的使用import结构导入指定包下的类、接口</p>
</li>
<li><p>import声明在包的声明和类的声明之间</p>
</li>
<li><p>可使用<code>xxx.*</code>的方式，表示可以导入xxx包下的所有结构。（但如果使用的是xxx子包下的结构，则仍需显式import）</p>
</li>
<li><p>若使用的类或接口是java.lang包下定义的，则可以省略import</p>
</li>
<li><p>若使用的类或接口是本包下定义的，则可以省略import</p>
</li>
<li><p>若在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示</p>
</li>
<li><p><code>import static</code>：导入<strong>指定类或接口中的静态结构</strong>。(导入的是结构，不是类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line">out.println(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h1><ul>
<li>MVC<ul>
<li>模型层（model）：主要处理数据<ul>
<li>数据对象封装 model.bean&#x2F;domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li>视图层（view）：显式数据<ul>
<li>相关工具类 view.utils</li>
<li>自定义 view.ui</li>
</ul>
</li>
<li>控制层（controller）：处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="继承性的使用"><a href="#继承性的使用" class="headerlink" title="继承性的使用"></a>继承性的使用</h1><ul>
<li><p>好处：</p>
<ul>
<li>减少代码冗余，提高代码复用性</li>
<li>便于功能的扩展</li>
<li>为之后多态性的使用，提供了前提</li>
</ul>
</li>
<li><p>继承性的格式： <code>class A extends B&#123;&#125;</code></p>
<ul>
<li>A：子类、派生类、subclass</li>
<li>B：父类、超类、基类、superclass</li>
</ul>
</li>
<li><p>一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有属性、方法</p>
<ul>
<li><p>特别地，父类中声明为<code>private</code>的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。<strong>只有因为封装性的影响，使得子类不能直接调用相应的结构而已。</strong></p>
</li>
<li><p>继承性：负责结构</p>
<p>封装性：负责能不能调用</p>
</li>
</ul>
</li>
<li><p>子类继承父类后，还可声明自己特有的属性和方法</p>
</li>
<li><p>子类和父类的关系，不同于子集和集合的关系。</p>
</li>
<li><p>java中对于继承性的规定</p>
<ul>
<li>一个类可用被多个子类继承</li>
<li>Java的单继承性：一个类只能有一个父类（c++中有多继承）</li>
<li>允许多层继承（直接父类、间接父类）</li>
</ul>
</li>
<li><p>如果没有显式的声明一个类的父类的话，则此类继承于<strong>java.lang.Object</strong>类（所有的java类都直接或间接地继承于Object类）</p>
</li>
<li><p>所有的Java类都具有java.lang.Object类声明的功能</p>
</li>
</ul>
<h1 id="方法的重写（override-x2F-overwrite）"><a href="#方法的重写（override-x2F-overwrite）" class="headerlink" title="方法的重写（override&#x2F;overwrite）"></a>方法的重写（override&#x2F;overwrite）</h1><ul>
<li><p>重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作。</p>
</li>
<li><p>重写的规定：</p>
<blockquote>
<p>方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{</p>
<p>​                  &#x2F;&#x2F;方法体</p>
<p>​                    }</p>
</blockquote>
<ul>
<li><p>子类重写的方法的<strong>方法名和形参列表</strong>与父类被重写的方法的方法名和形参列表<strong>相同</strong></p>
</li>
<li><p>子类重写的方法的<strong>权限修饰符不小于</strong>父类被重写的方法的权限修饰符</p>
<p>特殊情况：子类不能重写父类中声明为private权限的方法（不认为是重写）</p>
</li>
<li><p>返回值类型：</p>
<ul>
<li><p>父类被重写方法的返回值是void，则子类重写方法的放回置只能是void</p>
</li>
<li><p>父类被重写方法的返回值类型是A类型，则子类重写方法的返回值类型可以是A类或A类的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类中被重写方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类中重写的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类被重写方法的返回值类型是基本数据类型（如double），则子类重写方法的返回值类型必须是相同的基本数据类型（如double）</p>
</li>
</ul>
</li>
<li><p>子类重写的方法<strong>抛出的异常类型不大于</strong>父类被重写的方法抛出的异常类型</p>
</li>
<li><p>子类和父类中同名同参数的方法要么都声明为非static（考虑重写），要么都声明为static（不认为是重写）。</p>
</li>
</ul>
</li>
<li><p>面试题：区分方法的重载和重写</p>
<ul>
<li>二者的定义</li>
<li>从编译和运行的角度看：<ul>
<li>重载：在方法调用之前，编译器就已经确定了所要调用的方法（早绑定、静态绑定）</li>
<li>重写（对于多态来说）：只有等到方法调用的那个一刻，编译器才会确定所要调用的具体方法（晚绑定、动态绑定）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h1><ul>
<li>super理解为：父类的</li>
<li>super可以用来调用：属性、方法、构造器</li>
<li>super的使用：调用属性和方法<ul>
<li>可以在子类的方法或构造器种使用<code>super.属性</code>或<code>super.方法</code>显式的调用父类中声明的属性或方法。但是通常情况下，习惯省略<code>super.</code></li>
<li>特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用<code>super.属性</code>的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，想在子类的方法中调用父类中被重写的方法时，则必须显式的使用<code>super.方法</code>的方式，表明调用的是父类中声明的方法。</li>
</ul>
</li>
<li>super调用构造器<ul>
<li>可以在子类的构造器中显式的使用<code>super(形参列表)</code>的方式，调用父类中声明的指定的构造器</li>
<li><code>super(形参列表)</code>的使用，必须声明在子类构造器的首行</li>
<li>在类的构造器中，针对于<code>this(形参列表)</code>或<code>super(形参列表)</code>只能二选一，不能同时出现</li>
<li>在构造器首行没有显式的声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认调用的是父类中空参的构造器<code>super()</code></li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了<code>super(形参列表)</code>，调用父类中的构造器</li>
</ul>
</li>
</ul>
<h1 id="多态性的使用"><a href="#多态性的使用" class="headerlink" title="多态性的使用"></a>多态性的使用</h1><ul>
<li><p>理解多态性：可以理解为一个事物的多种形态</p>
</li>
<li><p>对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法（即<strong>虚拟方法调用</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Man类重写的方法</span></span><br><span class="line">p1.eat();</span><br><span class="line">p1.walt();</span><br><span class="line"><span class="comment">//Man类特有的方法不能调用</span></span><br><span class="line">p1.earnMoney();  <span class="comment">//这行报错</span></span><br></pre></td></tr></table></figure>

<p><strong>虚拟方法调用：编译看左（父类）、运行看右（子类）</strong>：有个对象的多态性后，在编译器，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法。</p>
<p>子类中重写了父类方法，在多态情况下，此时父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。——动态绑定</p>
</li>
<li><p>多态性的使用前提：</p>
<ul>
<li>类的继承关系（继承性是多态性的前提）</li>
<li>方法的重写（否则没有必要使用多态性）</li>
</ul>
</li>
<li><p>多态性使用举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnimalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalTest</span>();</span><br><span class="line">test.func(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">test.func(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">    animal.eat();</span><br><span class="line">    animal.shout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doData</span><span class="params">(Connection conn)</span>&#123; <span class="comment">//conn = new MySqlCOnnection();或者conn = new OracleCOnnection(); </span></span><br><span class="line">    conn.method1();</span><br><span class="line">    conn.method2();</span><br><span class="line">    conn.method3();</span><br><span class="line">    <span class="comment">//调用的都是子类重写的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的多态性，只适用于方法，不适用于属性（ 编译和运行都看左边）</p>
</li>
<li><p>面试题：</p>
<ul>
<li><p>多态是编译时行为还是运行时行为？</p>
<p>答：运行时行为</p>
</li>
</ul>
</li>
</ul>
<h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><ul>
<li><p>有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类，导致编译时只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
</li>
<li><p>如何才能调用子类特有的属性和方法？</p>
<p>向下转型：使用强制类型转换（向上转型就是多态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用强制类型转换时，可能出现ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Woman</span> <span class="variable">w1</span> <span class="operator">=</span> (Woman)p1;</span><br><span class="line">w1.goShopping();    <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，需要用到<code>instanceof</code>关键字</p>
</li>
<li><p><code>instanceof</code>关键字的使用</p>
<ul>
<li><p><code>a instanceof A</code> ：判断对象a是否时类A的实例。如果是，返回true；如果不是，返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Woman)&#123;  <span class="comment">//false</span></span><br><span class="line">    <span class="type">Woman</span> <span class="variable">w1</span> <span class="operator">=</span> (Woman)p1;</span><br><span class="line">	w1.goShopping(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Man)&#123;  <span class="comment">//true</span></span><br><span class="line">    <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1;</span><br><span class="line">	w1.earnMoney(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>B是A的父类，如果<code>a instanceof A</code>返回true，则<code>a instanceof B</code>也返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Man)&#123;  <span class="comment">//true</span></span><br><span class="line">    <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1;</span><br><span class="line">	w1.earnMoney(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Person)&#123;  <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Object)&#123;  <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="Object类结构"><a href="#Object类结构" class="headerlink" title="Object类结构"></a>Object类结构</h1><ul>
<li>Object类中的功能（属性、方法）就具有通用性<ul>
<li>属性：无</li>
<li>方法：equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait()、notify()、notifyAll()</li>
</ul>
</li>
<li>Object类只声明了一个空参的构造器</li>
</ul>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><ul>
<li><p>面试题：&#x3D;&#x3D;和equals()的区别</p>
<p><strong>&#x3D;&#x3D;：运算符</strong></p>
<ul>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定要类型相同）</p>
<p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同（即两个引用是否指向同一个对象实体）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> d=<span class="number">10.0</span>;</span><br><span class="line">System.out.println(i==j); <span class="comment">//true</span></span><br><span class="line">System.out.println(i==d); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(i==b); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c=<span class="number">10</span>;</span><br><span class="line">System.out.println(i==c); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1==cust2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>equals()方法的使用：</strong></p>
<ul>
<li><p>是一个方法，不是运算符</p>
</li>
<li><p>只适用于引用数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1.equals(cust2)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Object类中equals()的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>==obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的。</p>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>自定义类重写equals()方法：</p>
<ul>
<li>手动实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>==obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Customer)&#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> (Customer)obj;<span class="comment">//obj是Object类，Customer是Object的子类，obj不能直接调用子类特有的属性，需要向下转型</span></span><br><span class="line">        <span class="comment">//接下来比骄傲两个对象的每个属性是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age == cust.age &amp;&amp; <span class="built_in">this</span>.name.equals(cust.name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Customer</span> <span class="variable">cust1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">cust2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1.equals(cust2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自动生成：使用编译器</p>
<p>eclipse：Source –&gt; Generate hashCode() and equals()</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><ul>
<li><p>当输出一个对象的引用时，实际上就是使用当前对象的toString()</p>
</li>
<li><p>Object类中toString()的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的同String()时，返回”实体内容”信息。</p>
</li>
<li><p>自定义类重写toString()方法：</p>
<ul>
<li>手动实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Customer[name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自动生成：使用编译器</p>
<p>eclipse：Source –&gt; Generate toString()</p>
</li>
</ul>
</li>
</ul>
<h1 id="包装类-Wrapper-的使用"><a href="#包装类-Wrapper-的使用" class="headerlink" title="包装类(Wrapper)的使用"></a>包装类(Wrapper)的使用</h1><h2 id="基本数据类型、包装类与String类间的转换"><a href="#基本数据类型、包装类与String类间的转换" class="headerlink" title="基本数据类型、包装类与String类间的转换"></a>基本数据类型、包装类与String类间的转换</h2><h3 id="基本数据类型和包装类间的转换"><a href="#基本数据类型和包装类间的转换" class="headerlink" title="基本数据类型和包装类间的转换"></a>基本数据类型和包装类间的转换</h3><ul>
<li><p>Java提供了8中数据类型对于的包装类，使得基本数据类型的变量具有类的特征</p>
</li>
<li><p>基本数据类型 —-&gt; 包装类：调用包装类的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num1);</span><br><span class="line">System.out.println(in1.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装类 —-&gt; 基本数据类型：调用包装类的xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="type">int</span>.intValue();</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动装箱与自动拆箱</p>
<p>jdk5.0 新特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱:基本数据类型 ----&gt; 包装类</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num2;</span><br><span class="line"><span class="comment">//自动拆箱:包装类 ----&gt; 基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> in1;</span><br></pre></td></tr></table></figure>

<p>Integer内部定义的IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128<del>127范围的整数。如果使用自动装箱的方式，给Integer赋值的范围在-128</del>127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率（超过则需要再new）</p>
</li>
</ul>
<h3 id="基本数据类型、包装类间与Strin类的转换"><a href="#基本数据类型、包装类间与Strin类的转换" class="headerlink" title="基本数据类型、包装类间与Strin类的转换"></a>基本数据类型、包装类间与Strin类的转换</h3><ul>
<li><p>基本数据类型、包装类 —&gt; String类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">int</span> num1= <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> num1+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3f</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(f1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>String类型 —&gt; 基本数据类型、包装类：调用包装类的parseXxx()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str12</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(str2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h1><blockquote>
<p>有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。（例如，所有中国人共享国家的名称）</p>
</blockquote>
<ul>
<li><p>static：静态的</p>
</li>
<li><p>static可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>使用static修饰属性：静态变量（类变量）</p>
<ul>
<li>属性按是否使用static修饰，又分为静态属性 vs 非静态属性（实例变量）</li>
<li>实例变量：创建多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象的非静态所熟悉时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：创建多个对象，多个对象共享一个静态变量，当通过某个对象修改静态变量时，会导致其他对象调用此静态变量时也是修改过了的。</li>
<li>其他说明：<ul>
<li>静态变量随着类的加载而加载：可以通过<code>类.静态变量</code>的方法进行调用</li>
<li>静态变量的加载早于对象的创建</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份，存在<strong>方法区的静态域</strong>中。</li>
</ul>
</li>
<li>静态属性举例：System.out; Math.PI</li>
</ul>
</li>
<li><p>使用static修饰方法：静态方法</p>
<ul>
<li><p>随着类的加载而加载：可以通过<code>类.静态方法</code>的方法进行调用</p>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
<p>非静态方法中，可以调用非静态&#x2F;静态的方法或属性</p>
<p>（从它们生命周期的角度理解，静态结构加载时非静态结构还没加载）</p>
</li>
</ul>
</li>
<li><p>static注意点</p>
<ul>
<li>在静态的方法内，不能使用this、super关键字</li>
</ul>
</li>
<li><p>开发中，如何确定一个属性是否声明为static？</p>
<ul>
<li>属性时可以被多个对象所共享的，不会随着对象的不同而不同的。</li>
</ul>
</li>
<li><p>开发中，如何确定一个方法是否声明为static？</p>
<ul>
<li>操作静态属性的方法，通常设置为static</li>
<li>工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections</li>
</ul>
</li>
</ul>
<h1 id="单例（Singleton）设计模式"><a href="#单例（Singleton）设计模式" class="headerlink" title="单例（Singleton）设计模式"></a>单例（Singleton）设计模式</h1><ul>
<li><p>单例设计模式：采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例</p>
</li>
<li><p>实现步骤：</p>
<p><strong>饿汉式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line"><span class="type">Bank</span> <span class="variable">bank2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">System.out.println(bank1==bank2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器，避免外部通过new创建实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 内部创建类的对象</span></span><br><span class="line">    <span class="comment">//4. 要求此对象也必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="comment">//3. 提供公共的方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式</strong>：啥时候用啥时候造，延迟创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line"><span class="type">Bank</span> <span class="variable">bank2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">System.out.println(bank1==bank2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器，避免外部通过new创建实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">//4. 要求此对象也必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//3. 提供公共的方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式和懒汉式的区别</p>
<ul>
<li>饿汉式：<ul>
<li>坏处：对象加载时间过长</li>
<li>好处：线程安全的</li>
</ul>
</li>
<li>懒汉式：<ul>
<li>好处：延迟对象的创建</li>
<li>（目前的写法）坏处：线程不安全</li>
</ul>
</li>
</ul>
</li>
<li><p>单例模式的优点：减少系统性能开销</p>
</li>
<li><p>单例模式的应用：</p>
<ul>
<li>java.lang.Runtime</li>
<li>网站的计数器</li>
<li>应用程序的日志应用</li>
<li>数据库连接池</li>
<li>读取配置文件的类</li>
<li>Application</li>
<li>Windows的任务管理器</li>
<li>Windows的回收站</li>
</ul>
</li>
</ul>
<h1 id="类中的代码块结构"><a href="#类中的代码块结构" class="headerlink" title="类中的代码块结构"></a>类中的代码块结构</h1><ul>
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块只能使用static修饰</li>
<li>静态代码块 vs 非静态代码块<ul>
<li>静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着类的加载而执行，且只执行一次</li>
<li>作用：初始化类的属性</li>
<li>如果类中定义了多个静态代码块，则按声明顺序执行</li>
<li>静态代码块执行要优于非静态代码块的执行</li>
<li>静态代码块内只能调用静态属性、方法</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以下创建对象时，对对象的属性进行初始化</li>
<li>如果类中定义了多个非静态代码块，则按声明顺序执行</li>
<li>非静态代码块中能调用静态&#x2F;非静态属性、方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="final关键字的使用"><a href="#final关键字的使用" class="headerlink" title="final关键字的使用"></a>final关键字的使用</h1><ul>
<li><p>final：最终的</p>
</li>
<li><p>final可以用来修饰：类、方法、变量</p>
</li>
<li><p>final用来修饰一个类：该类不能被继承</p>
<p>比如：String类、System类、StringBuffer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final用来修饰方法：该方法不能被重写</p>
<p>Object类中的getClass()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;   <span class="comment">//报错，不能重写</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final用来修饰变量：该”变量”就成为是一个常量</p>
<ul>
<li><p>final修饰属性：可以考虑的赋值位置有：显式初始化、代码块中赋值、构造器中初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WIDTH</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> LEFT;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> RIGHT;</span><br><span class="line">    &#123;</span><br><span class="line">        LEFT = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        RIGHT = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        RIGHT = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final修饰局部变量：</p>
<p>尤其使用final修饰形参时，表明此形参是一个常量。当调用此方法是，给常量形参赋一个实参，一旦赋值后，就只能在方法内使用此形参，但不能重新赋值。</p>
</li>
</ul>
</li>
<li><p>static final 用来修饰属性：全局常量</p>
</li>
</ul>
<h1 id="abstract关键字的使用"><a href="#abstract关键字的使用" class="headerlink" title="abstract关键字的使用"></a>abstract关键字的使用</h1><ul>
<li><p>abstract：抽象的</p>
</li>
<li><p>abstract可以用来修饰的结构：类、方法</p>
</li>
<li><p>abstract修饰类：抽象类</p>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化使用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类实例化，完成相关操作</li>
</ul>
</li>
<li><p>abstract修饰方法：抽象方法</p>
<ul>
<li><p>只有方法的声明，没有方法体</p>
</li>
<li><p>包含抽象方法的类，一定是抽象类。反之，抽象类中可以没有抽象方法</p>
</li>
<li><p>若子类重写了父类中所有的抽象方法后，此子类方可实例化</p>
<p>若子类没有重写父类中所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>abstract不能用来修饰：属性、构造器等结构</p>
<p>abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
</li>
</ul>
<h2 id="抽象类的匿名子类"><a href="#抽象类的匿名子类" class="headerlink" title="抽象类的匿名子类"></a>抽象类的匿名子类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了一匿名子类的非匿名对象：p</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">method(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建匿名子类的匿名对象</span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h2><ul>
<li>抽象类的应用：模板方法的设计模式</li>
<li>应用：<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet&#x2F;doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、HibernateTemplate等</li>
</ul>
</li>
</ul>
<h1 id="interface接口关键字的使用"><a href="#interface接口关键字的使用" class="headerlink" title="interface接口关键字的使用"></a>interface接口关键字的使用</h1><ul>
<li><p>Java不支持多重继承，但有了接口，就可以达到多重继承的效果</p>
</li>
<li><p>接口和类是两个并列的结构</p>
</li>
<li><p>定义接口中的成员</p>
<ul>
<li><p>jdk7及以前：只能定义全局常量和抽象方法</p>
<ul>
<li>全局常量：public static final的，但是书写时可以省略不写</li>
<li>抽象方法：public abstract的，但是书写时可以省略不写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">7900</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MIN_SPEED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//省略了public static final</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>; <span class="comment">// 省略了public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jdk8：除了定义全局常量和抽象方法之外，还可也定义静态方法、默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接口中不能定义构造器，意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过类去实现（implement）的方式来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> implement Flyable&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Kite</span> implement Flyable&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</p>
<p>如果实现类没有覆盖(实现)接口中的所有抽象方法，则此实现类仍为一个抽象类</p>
</li>
<li><p>Java类可以实现多个接口 —-&gt; 弥补了Java单继承性的局限性</p>
<p>格式：<code>class AA extends BB implement CC,DD,EE&#123;&#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">extends</span> <span class="title class_">Object</span> implement Flyable,Attackable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口与接口之间可以继承，且可以多继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span> <span class="keyword">extends</span> <span class="title class_">AA</span>,BB&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的具体使用，体现多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"><span class="type">Flash</span> <span class="variable">flash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line">com.transferData(flash);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123; <span class="comment">//USB usb = new Flash();</span></span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口：实际上可以看作是一种规范</p>
</li>
</ul>
<h2 id="接口匿名实现类"><a href="#接口匿名实现类" class="headerlink" title="接口匿名实现类"></a>接口匿名实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"><span class="comment">// 接口的非匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">Flash</span> <span class="variable">flash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line">com.transferData(flash);</span><br><span class="line"><span class="comment">// 接口的非匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">Flash</span>());</span><br><span class="line"><span class="comment">// 接口的匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">USB</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">com.transferData(phone);</span><br><span class="line"><span class="comment">// 接口的匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>接口应用：<ul>
<li>代理模式（Proxy）</li>
<li>工厂模式</li>
</ul>
</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul>
<li>Java中运行将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</li>
<li>内部类的分类：成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：Java基础（二）：面向对象</li>
        <li>本文作者：Wu Shihan</li>
        <li>创建时间：2023-01-16 10:55:10</li>
        <li>
            本文链接：https://keep.xpoet.cn/2023/01/16/Java基础（二）：面向对象/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="../../../../tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">#面向对象</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="../../19/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java基础（三）：异常处理</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="../../15/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java基础（一）：数组</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'QexeIUQCFCuu3ci1cg6PeWFt-gzGzoHsz',
                    appKey: 'R9AnejwulsdWWkdHCjtubrKR',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Wu Shihan';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Wu Shihan</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%89%E6%9D%A1%E4%B8%BB%E7%BA%BF"><span class="nav-number">1.</span> <span class="nav-text">Java面向对象学习的三条主线</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89vs%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">属性（成员变量）vs局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">不同点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">JVM内存解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">匿名对象的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-overload"><span class="nav-number">5.</span> <span class="nav-text">方法的重载(overload)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">可变个数形参的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">方法参数的值传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">7.1.</span> <span class="nav-text">关于变量的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.</span> <span class="nav-text">方法的形参的传递机制：值传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-number">8.</span> <span class="nav-text">封装性的体现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">9.</span> <span class="nav-text">4种权限修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="nav-number">10.</span> <span class="nav-text">属性赋值的先后顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaBean"><span class="nav-number">11.</span> <span class="nav-text">JavaBean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">12.</span> <span class="nav-text">this关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#package%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">package关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">import关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">MVC设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">16.</span> <span class="nav-text">继承性的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88override-x2F-overwrite%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">方法的重写（override&#x2F;overwrite）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">18.</span> <span class="nav-text">super关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">19.</span> <span class="nav-text">多态性的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">19.1.</span> <span class="nav-text">instanceof关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">20.</span> <span class="nav-text">Object类结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">20.1.</span> <span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">20.2.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-Wrapper-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">21.</span> <span class="nav-text">包装类(Wrapper)的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8EString%E7%B1%BB%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">21.1.</span> <span class="nav-text">基本数据类型、包装类与String类间的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">21.1.1.</span> <span class="nav-text">基本数据类型和包装类间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E9%97%B4%E4%B8%8EStrin%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">21.1.2.</span> <span class="nav-text">基本数据类型、包装类间与Strin类的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">22.</span> <span class="nav-text">static关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%EF%BC%88Singleton%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">单例（Singleton）设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BB%93%E6%9E%84"><span class="nav-number">24.</span> <span class="nav-text">类中的代码块结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">25.</span> <span class="nav-text">final关键字的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#abstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">26.</span> <span class="nav-text">abstract关键字的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB"><span class="nav-number">26.1.</span> <span class="nav-text">抽象类的匿名子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TemplateMethod%EF%BC%89"><span class="nav-number">26.2.</span> <span class="nav-text">模板方法设计模式（TemplateMethod）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#interface%E6%8E%A5%E5%8F%A3%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">27.</span> <span class="nav-text">interface接口关键字的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">27.1.</span> <span class="nav-text">接口匿名实现类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">28.</span> <span class="nav-text">内部类</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
